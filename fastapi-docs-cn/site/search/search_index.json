{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation : https://fastapi.tiangolo.com Source Code : https://github.com/tiangolo/fastapi FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. The key features are: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300% *. Fewer bugs : Reduce about 40% of human (developer) induced errors. * Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . * estimation based on tests on an internal development team, building production applications. Opinions \u00b6 \" [...] I'm using FastAPI a ton these days. [...] I'm actually planning to use it for all of my team's ML services at Microsoft . Some of them are getting integrated into the core Windows product and some Office products. \" Kabir Khan - Microsoft (ref) \" I\u2019m over the moon excited about FastAPI . It\u2019s so fun! \" Brian Okken - Python Bytes podcast host (ref) \" Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted Hug to be - it's really inspiring to see someone build that. \" Timothy Crosley - Hug creator (ref) \" If you're looking to learn one modern framework for building REST APIs, check out FastAPI [...] It's fast, easy to use and easy to learn [...] \" \" We've switched over to FastAPI for our APIs [...] I think you'll like it [...] \" Ines Montani - Matthew Honnibal - Explosion AI founders - spaCy creators (ref) - (ref) \" We adopted the FastAPI library to spawn a REST server that can be queried to obtain predictions . [for Ludwig] \" Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - Uber (ref) Requirements \u00b6 Python 3.6+ FastAPI stands on the shoulders of giants: Starlette for the web parts. Pydantic for the data parts. Installation \u00b6 pip install fastapi You will also need an ASGI server, for production such as Uvicorn or Hypercorn . pip install uvicorn Example \u00b6 Create it \u00b6 Create a file main.py with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } Or use async def ... If your code uses async / await , use async def : from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } Note : If you don't know, check the \"In a hurry?\" section about async and await in the docs . Run it \u00b6 Run the server with: uvicorn main:app --reload About the command uvicorn main:app --reload ... The command uvicorn main:app refers to: main : the file main.py (the Python \"module\"). app : the object created inside of main.py with the line app = FastAPI() . --reload : make the server restart after code changes. Only do this for development. Check it \u00b6 Open your browser at http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { \"item_id\" : 5 , \"q\" : \"somequery\" } You already created an API that: Receives HTTP requests in the paths / and /items/{item_id} . Both paths take GET operations (also known as HTTP methods ). The path /items/{item_id} has a path parameter item_id that should be an int . The path /items/{item_id} has an optional str query parameter q . Interactive API docs \u00b6 Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ): Alternative API docs \u00b6 And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ): Example upgrade \u00b6 Now modify the file main.py to receive a body from a PUT request. Declare the body using standard Python types, thanks to Pydantic. from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str price : float is_offer : bool = None @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } @app . put ( \"/items/ {item_id} \" ) def update_item ( item_id : int , item : Item ): return { \"item_name\" : item . name , \"item_id\" : item_id } The server should reload automatically (because you added --reload to the uvicorn command above). Interactive API docs upgrade \u00b6 Now go to http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button \"Try it out\", it allows you to fill the parameters and directly interact with the API: Then click on the \"Execute\" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade \u00b6 And now, go to http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body: Recap \u00b6 In summary, you declare once the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : item_id : int or for a more complex Item model: item : Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str , int , float , bool , list , etc). datetime objects. UUID objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example, FastAPI will: Validate that there is an item_id in the path for GET and PUT requests. Validate that the item_id is of type int for GET and PUT requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery ) for GET requests. As the q parameter is declared with = None , it is optional. Without the None it would be required (as is the body in the case with PUT ). For PUT requests to /items/{item_id} , Read the body as JSON: Check that it has a required attribute name that should be a str . Check that it has a required attribute price that has to be a float . Check that it has an optional attribute is_offer , that should be a bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return { \"item_name\" : item . name , \"item_id\" : item_id } ...from: ... \"item_name\" : item . name ... ...to: ... \"item_price\" : item . price ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of parameters from other different places as: headers , cookies , form fields and files . How to set validation constraints as maximum_length or regex . A very powerful and easy to use Dependency Injection system. Security and authentication, including support for OAuth2 with JWT tokens and HTTP Basic auth. More advanced (but equally easy) techniques for declaring deeply nested JSON models (thanks to Pydantic). Many extra features (thanks to Starlette) as: WebSockets GraphQL extremely easy tests based on requests and pytest CORS Cookie Sessions ...and more. Performance \u00b6 Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section Benchmarks . Optional Dependencies \u00b6 Used by Pydantic: ujson - for faster JSON \"parsing\" . email_validator - for email validation. Used by Starlette: requests - Required if you want to use the TestClient . aiofiles - Required if you want to use FileResponse or StaticFiles . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form \"parsing\" , with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for Starlette's SchemaGenerator support (you probably don't need it with FastAPI). graphene - Required for GraphQLApp support. ujson - Required if you want to use UJSONResponse . Used by FastAPI / Starlette: uvicorn - for the server that loads and serves your application. You can install all of these with pip install fastapi[all] . License \u00b6 This project is licensed under the terms of the MIT license.","title":"FastAPI"},{"location":"#opinions","text":"\" [...] I'm using FastAPI a ton these days. [...] I'm actually planning to use it for all of my team's ML services at Microsoft . Some of them are getting integrated into the core Windows product and some Office products. \" Kabir Khan - Microsoft (ref) \" I\u2019m over the moon excited about FastAPI . It\u2019s so fun! \" Brian Okken - Python Bytes podcast host (ref) \" Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted Hug to be - it's really inspiring to see someone build that. \" Timothy Crosley - Hug creator (ref) \" If you're looking to learn one modern framework for building REST APIs, check out FastAPI [...] It's fast, easy to use and easy to learn [...] \" \" We've switched over to FastAPI for our APIs [...] I think you'll like it [...] \" Ines Montani - Matthew Honnibal - Explosion AI founders - spaCy creators (ref) - (ref) \" We adopted the FastAPI library to spawn a REST server that can be queried to obtain predictions . [for Ludwig] \" Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - Uber (ref)","title":"Opinions"},{"location":"#requirements","text":"Python 3.6+ FastAPI stands on the shoulders of giants: Starlette for the web parts. Pydantic for the data parts.","title":"Requirements"},{"location":"#installation","text":"pip install fastapi You will also need an ASGI server, for production such as Uvicorn or Hypercorn . pip install uvicorn","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#create-it","text":"Create a file main.py with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } Or use async def ... If your code uses async / await , use async def : from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } Note : If you don't know, check the \"In a hurry?\" section about async and await in the docs .","title":"Create it"},{"location":"#run-it","text":"Run the server with: uvicorn main:app --reload About the command uvicorn main:app --reload ... The command uvicorn main:app refers to: main : the file main.py (the Python \"module\"). app : the object created inside of main.py with the line app = FastAPI() . --reload : make the server restart after code changes. Only do this for development.","title":"Run it"},{"location":"#check-it","text":"Open your browser at http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { \"item_id\" : 5 , \"q\" : \"somequery\" } You already created an API that: Receives HTTP requests in the paths / and /items/{item_id} . Both paths take GET operations (also known as HTTP methods ). The path /items/{item_id} has a path parameter item_id that should be an int . The path /items/{item_id} has an optional str query parameter q .","title":"Check it"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"#alternative-api-docs","text":"And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ):","title":"Alternative API docs"},{"location":"#example-upgrade","text":"Now modify the file main.py to receive a body from a PUT request. Declare the body using standard Python types, thanks to Pydantic. from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str price : float is_offer : bool = None @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } @app . put ( \"/items/ {item_id} \" ) def update_item ( item_id : int , item : Item ): return { \"item_name\" : item . name , \"item_id\" : item_id } The server should reload automatically (because you added --reload to the uvicorn command above).","title":"Example upgrade"},{"location":"#interactive-api-docs-upgrade","text":"Now go to http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button \"Try it out\", it allows you to fill the parameters and directly interact with the API: Then click on the \"Execute\" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:","title":"Interactive API docs upgrade"},{"location":"#alternative-api-docs-upgrade","text":"And now, go to http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body:","title":"Alternative API docs upgrade"},{"location":"#recap","text":"In summary, you declare once the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : item_id : int or for a more complex Item model: item : Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str , int , float , bool , list , etc). datetime objects. UUID objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example, FastAPI will: Validate that there is an item_id in the path for GET and PUT requests. Validate that the item_id is of type int for GET and PUT requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery ) for GET requests. As the q parameter is declared with = None , it is optional. Without the None it would be required (as is the body in the case with PUT ). For PUT requests to /items/{item_id} , Read the body as JSON: Check that it has a required attribute name that should be a str . Check that it has a required attribute price that has to be a float . Check that it has an optional attribute is_offer , that should be a bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return { \"item_name\" : item . name , \"item_id\" : item_id } ...from: ... \"item_name\" : item . name ... ...to: ... \"item_price\" : item . price ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of parameters from other different places as: headers , cookies , form fields and files . How to set validation constraints as maximum_length or regex . A very powerful and easy to use Dependency Injection system. Security and authentication, including support for OAuth2 with JWT tokens and HTTP Basic auth. More advanced (but equally easy) techniques for declaring deeply nested JSON models (thanks to Pydantic). Many extra features (thanks to Starlette) as: WebSockets GraphQL extremely easy tests based on requests and pytest CORS Cookie Sessions ...and more.","title":"Recap"},{"location":"#performance","text":"Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section Benchmarks .","title":"Performance"},{"location":"#optional-dependencies","text":"Used by Pydantic: ujson - for faster JSON \"parsing\" . email_validator - for email validation. Used by Starlette: requests - Required if you want to use the TestClient . aiofiles - Required if you want to use FileResponse or StaticFiles . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form \"parsing\" , with request.form() . itsdangerous - Required for SessionMiddleware support. pyyaml - Required for Starlette's SchemaGenerator support (you probably don't need it with FastAPI). graphene - Required for GraphQLApp support. ujson - Required if you want to use UJSONResponse . Used by FastAPI / Starlette: uvicorn - for the server that loads and serves your application. You can install all of these with pip install fastapi[all] .","title":"Optional Dependencies"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"alternatives/","text":"What inspired FastAPI , how it compares to other alternatives and what it learned from them. Intro \u00b6 FastAPI wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation. I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools. But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints). Previous tools \u00b6 Django \u00b6 It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram. It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy. It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like IoT devices) communicating with it. Django REST Framework \u00b6 Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities. It is used by many companies including Mozilla, Red Hat and Eventbrite. It was one of the first examples of automatic API documentation , and this was specifically one of the first ideas that inspired \"the search for\" FastAPI . Note Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which FastAPI is based. Inspired FastAPI to Have an automatic API documentation web user interface. Flask \u00b6 Flask is a \"microframework\", it doesn't include database integrations nor many of the things that come by default in Django. This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system. As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points. It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins. This decoupling of parts, and being a \"microframework\" that could be extended to cover exactly what is needed was a key feature that I wanted to keep. Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a \"Django REST Framework\" for Flask. Inspired FastAPI to Be a micro-framework. Making it easy to mix and match the tools and parts needed. Have a simple and easy to use routing system. Requests \u00b6 FastAPI is not actually an alternative to Requests . Their scope is very different. It would actually be common to use Requests inside of a FastAPI application. But still, FastAPI got quite some inspiration from Requests. Requests is a library to interact with APIs (as a client), while FastAPI is a library to build APIs (as a server). They are, more or less, at opposite ends, complementing each other. Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable. That's why, as said in the official website: Requests is one of the most downloaded Python packages of all time The way you use it is very simple. For example, to do a GET request, you would write: response = requests . get ( \"http://example.com/some/url\" ) The FastAPI counterpart API path operation could look like: @app . get ( \"/some/url\" ) def read_url (): return { \"message\" : \"Hello World\" } See the similarities in requests.get(...) and @app.get(...) . Inspired FastAPI to Have a simple and intuitive API. Use HTTP method names (operations) directly, in a straightforward and intuitive way. Have sensible defaults, but powerful customizations. Swagger / OpenAPI \u00b6 The main feature I wanted from Django REST Framework was the automatic API documentation. Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger. And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically. At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI. That's why when talking about version 2.0 it's common to say \"Swagger\", and for version 3+ \"OpenAPI\". Inspired FastAPI to Adopt and use an open standard for API specifications, instead of a custom schema. And integrate standards-based user interface tools: Swagger UI ReDoc These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of additional alternative user interfaces for OpenAPI (that you can use with FastAPI ). Flask REST frameworks \u00b6 There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit. Marshmallow \u00b6 One of the main features needed by API systems is data \" serialization \" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting datetime objects into strings, etc. Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an int , and not some random string. This is especially useful for incoming data. Without a data validation system, you would have to do all the checks by hand, in code. These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before. But it was created before there existed Python type hints. So, to define every schema you need to use specific utils and classes provided by Marshmallow. Inspired FastAPI to Use code to define \"schemas\" that provide data types and validation, automatically. Webargs \u00b6 Another big feature required by APIs is parsing data from incoming requests. Webargs is a tool that was made to provide that on top of several frameworks, including Flask. It uses Marshmallow underneath to do the data validation. And it was created by the same developers. It's a great tool and I have used it a lot too, before having FastAPI . Info Webargs was created by the same Marshmallow developers. Inspired FastAPI to Have automatic validation of incoming request data. APISpec \u00b6 Marshmallow and Webargs provide validation, parsing and serialization as plug-ins. But documentation is still missing. Then APISpec was created. It is a plug-in for many frameworks (and there's a plug-in for Starlette too). The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route. And it generates OpenAPI schemas. That's how it works in Flask, Starlette, Responder, etc. But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML). The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete. Info APISpec was created by the same Marshmallow developers. Inspired FastAPI to Support the open standard for APIs, OpenAPI. Flask-apispec \u00b6 It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec. It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec. It's a great tool, very under-rated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract. This solved having to write YAML (another syntax) inside of Python docstrings. This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building FastAPI . Using it led to the creation of several Flask full-stack generators. These are the main stack I (and several external teams) have been using up to now: https://github.com/tiangolo/full-stack https://github.com/tiangolo/full-stack-flask-couchbase https://github.com/tiangolo/full-stack-flask-couchdb And these same full-stack generators were the base of the FastAPI Project Generators . Info Flask-apispec was created by the same Marshmallow developers. Inspired FastAPI to Generate the OpenAPI schema automatically, from the same code that defines serialization and validation. NestJS (and Angular ) \u00b6 This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular. It achieves something somewhat similar to what can be done with Flask-apispec. It has an integrated dependency injection system, inspired by Angular two. It requires pre-registering the \"injectables\" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition. As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good. But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose. It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated. Inspired FastAPI to Use Python types to have great editor support. Have a powerful dependency injection system. Find a way to minimize code repetition. Sanic \u00b6 It was one of the first extremely fast Python frameworks based on asyncio . It was made to be very similar to Flask. Technical Details It used uvloop instead of the default Python asyncio loop. That's what made it so fast. It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks. Inspired FastAPI to Find a way to have a crazy performance. That's why FastAPI is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks). Falcon \u00b6 Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug. It uses the previous standard for Python web frameworks (WSGI) which is synchronous, so it can't handle WebSockets and other use cases. Nevertheless, it also has a very good performance. It is designed to have functions that receive two parameters, one \"request\" and one \"response\". Then you \"read\" parts from the request, and \"write\" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters. So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters. Inspired FastAPI to Find ways to get great performance. Along with Hug (as Hug is based on Falcon) inspired FastAPI to declare a response parameter in functions. Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes. Molten \u00b6 I discovered Molten in the first stages of building FastAPI . And it has quite similar ideas: Based on Python type hints. Validation and documentation from these types. Dependency Injection system. It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily. It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high-performance provided by tools like Uvicorn, Starlette and Sanic. The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one \"component\" that provides a certain type. Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled. Inspired FastAPI to Define extra validations for data types using the \"default\" value of model attributes. This improves editor support, and it was not available in Pydantic before. This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic). Hug \u00b6 Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same. It used custom types in its declarations instead of standard Python types, but it was still a huge step forward. It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON. It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea. It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs. As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too. Info Hug was created by Timothy Crosley, the same creator of isort , a great tool to automatically sort imports in Python files. Ideas inspired in FastAPI Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar. Hug helped inspiring FastAPI to use Python type hints to declare parameters, and to generate a schema defining the API automatically. Hug inspired FastAPI to declare a response parameter in functions to set headers and cookies. APIStar (<= 0.5) \u00b6 Right before deciding to build FastAPI I found APIStar server. It had almost everything I was looking for and had a great design. It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard. It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places. Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option. It had the best performance benchmarks at the time (only surpassed by Starlette). At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it. It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature. I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality. But then, the project's focus shifted. It was no longer an API web framework, as the creator needed to focus on Starlette. Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework. Info APIStar was created by Tom Christie. The same guy that created: Django REST Framework Starlette (in which FastAPI is based) Uvicorn (used by Starlette and FastAPI ) Inspired FastAPI to Exist. The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea. And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available. Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build FastAPI . I consider FastAPI a \"spiritual successor\" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools. Used by FastAPI \u00b6 Pydantic \u00b6 Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints. That makes it extremely intuitive. It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great. FastAPI uses it to Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema). FastAPI then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does. Starlette \u00b6 Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high-performance asyncio services. It is very simple and intuitive. It's designed to be easily extensible, and have modular components. It has: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests. CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies. Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server. Starlette provides all the basic web microframework functionality. But it doesn't provide automatic data validation, serialization or documentation. That's one of the main things that FastAPI adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc. Technical Details ASGI is a new \"standard\" being developed by Django core team members. It is still not a \"Python standard\" (a PEP), although they are in the process of doing that. Nevertheless, it is already being used as a \"standard\" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like python-socketio . FastAPI uses it to Handle all the core web parts. Adding features on top. The class FastAPI itself inherits directly from the class Starlette . So, anything that you can do with Starlette, you can do it directly with FastAPI , as it is basically Starlette on steroids. Uvicorn \u00b6 Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools. It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or FastAPI ) would provide on top. It is the recommended server for Starlette and FastAPI . FastAPI recommends it as The main web server to run FastAPI applications. You can combine it with Gunicorn, to have an asynchronous multi-process server. Check more details in the Deployment section. Benchmarks and speed \u00b6 To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about Benchmarks .","title":"Alternatives, Inspiration and Comparisons"},{"location":"alternatives/#intro","text":"FastAPI wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation. I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools. But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).","title":"Intro"},{"location":"alternatives/#previous-tools","text":"","title":"Previous tools"},{"location":"alternatives/#django","text":"It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram. It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy. It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like IoT devices) communicating with it.","title":"Django"},{"location":"alternatives/#django-rest-framework","text":"Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities. It is used by many companies including Mozilla, Red Hat and Eventbrite. It was one of the first examples of automatic API documentation , and this was specifically one of the first ideas that inspired \"the search for\" FastAPI . Note Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which FastAPI is based. Inspired FastAPI to Have an automatic API documentation web user interface.","title":"Django REST Framework"},{"location":"alternatives/#flask","text":"Flask is a \"microframework\", it doesn't include database integrations nor many of the things that come by default in Django. This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system. As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points. It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins. This decoupling of parts, and being a \"microframework\" that could be extended to cover exactly what is needed was a key feature that I wanted to keep. Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a \"Django REST Framework\" for Flask. Inspired FastAPI to Be a micro-framework. Making it easy to mix and match the tools and parts needed. Have a simple and easy to use routing system.","title":"Flask"},{"location":"alternatives/#requests","text":"FastAPI is not actually an alternative to Requests . Their scope is very different. It would actually be common to use Requests inside of a FastAPI application. But still, FastAPI got quite some inspiration from Requests. Requests is a library to interact with APIs (as a client), while FastAPI is a library to build APIs (as a server). They are, more or less, at opposite ends, complementing each other. Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable. That's why, as said in the official website: Requests is one of the most downloaded Python packages of all time The way you use it is very simple. For example, to do a GET request, you would write: response = requests . get ( \"http://example.com/some/url\" ) The FastAPI counterpart API path operation could look like: @app . get ( \"/some/url\" ) def read_url (): return { \"message\" : \"Hello World\" } See the similarities in requests.get(...) and @app.get(...) . Inspired FastAPI to Have a simple and intuitive API. Use HTTP method names (operations) directly, in a straightforward and intuitive way. Have sensible defaults, but powerful customizations.","title":"Requests"},{"location":"alternatives/#swagger-openapi","text":"The main feature I wanted from Django REST Framework was the automatic API documentation. Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger. And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically. At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI. That's why when talking about version 2.0 it's common to say \"Swagger\", and for version 3+ \"OpenAPI\". Inspired FastAPI to Adopt and use an open standard for API specifications, instead of a custom schema. And integrate standards-based user interface tools: Swagger UI ReDoc These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of additional alternative user interfaces for OpenAPI (that you can use with FastAPI ).","title":"Swagger / OpenAPI"},{"location":"alternatives/#flask-rest-frameworks","text":"There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit.","title":"Flask REST frameworks"},{"location":"alternatives/#marshmallow","text":"One of the main features needed by API systems is data \" serialization \" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting datetime objects into strings, etc. Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an int , and not some random string. This is especially useful for incoming data. Without a data validation system, you would have to do all the checks by hand, in code. These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before. But it was created before there existed Python type hints. So, to define every schema you need to use specific utils and classes provided by Marshmallow. Inspired FastAPI to Use code to define \"schemas\" that provide data types and validation, automatically.","title":"Marshmallow"},{"location":"alternatives/#webargs","text":"Another big feature required by APIs is parsing data from incoming requests. Webargs is a tool that was made to provide that on top of several frameworks, including Flask. It uses Marshmallow underneath to do the data validation. And it was created by the same developers. It's a great tool and I have used it a lot too, before having FastAPI . Info Webargs was created by the same Marshmallow developers. Inspired FastAPI to Have automatic validation of incoming request data.","title":"Webargs"},{"location":"alternatives/#apispec","text":"Marshmallow and Webargs provide validation, parsing and serialization as plug-ins. But documentation is still missing. Then APISpec was created. It is a plug-in for many frameworks (and there's a plug-in for Starlette too). The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route. And it generates OpenAPI schemas. That's how it works in Flask, Starlette, Responder, etc. But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML). The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete. Info APISpec was created by the same Marshmallow developers. Inspired FastAPI to Support the open standard for APIs, OpenAPI.","title":"APISpec"},{"location":"alternatives/#flask-apispec","text":"It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec. It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec. It's a great tool, very under-rated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract. This solved having to write YAML (another syntax) inside of Python docstrings. This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building FastAPI . Using it led to the creation of several Flask full-stack generators. These are the main stack I (and several external teams) have been using up to now: https://github.com/tiangolo/full-stack https://github.com/tiangolo/full-stack-flask-couchbase https://github.com/tiangolo/full-stack-flask-couchdb And these same full-stack generators were the base of the FastAPI Project Generators . Info Flask-apispec was created by the same Marshmallow developers. Inspired FastAPI to Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.","title":"Flask-apispec"},{"location":"alternatives/#nestjs-and-angular","text":"This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular. It achieves something somewhat similar to what can be done with Flask-apispec. It has an integrated dependency injection system, inspired by Angular two. It requires pre-registering the \"injectables\" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition. As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good. But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose. It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated. Inspired FastAPI to Use Python types to have great editor support. Have a powerful dependency injection system. Find a way to minimize code repetition.","title":"NestJS (and Angular)"},{"location":"alternatives/#sanic","text":"It was one of the first extremely fast Python frameworks based on asyncio . It was made to be very similar to Flask. Technical Details It used uvloop instead of the default Python asyncio loop. That's what made it so fast. It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks. Inspired FastAPI to Find a way to have a crazy performance. That's why FastAPI is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).","title":"Sanic"},{"location":"alternatives/#falcon","text":"Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug. It uses the previous standard for Python web frameworks (WSGI) which is synchronous, so it can't handle WebSockets and other use cases. Nevertheless, it also has a very good performance. It is designed to have functions that receive two parameters, one \"request\" and one \"response\". Then you \"read\" parts from the request, and \"write\" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters. So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters. Inspired FastAPI to Find ways to get great performance. Along with Hug (as Hug is based on Falcon) inspired FastAPI to declare a response parameter in functions. Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.","title":"Falcon"},{"location":"alternatives/#molten","text":"I discovered Molten in the first stages of building FastAPI . And it has quite similar ideas: Based on Python type hints. Validation and documentation from these types. Dependency Injection system. It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily. It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high-performance provided by tools like Uvicorn, Starlette and Sanic. The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one \"component\" that provides a certain type. Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled. Inspired FastAPI to Define extra validations for data types using the \"default\" value of model attributes. This improves editor support, and it was not available in Pydantic before. This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic).","title":"Molten"},{"location":"alternatives/#hug","text":"Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same. It used custom types in its declarations instead of standard Python types, but it was still a huge step forward. It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON. It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea. It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs. As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too. Info Hug was created by Timothy Crosley, the same creator of isort , a great tool to automatically sort imports in Python files. Ideas inspired in FastAPI Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar. Hug helped inspiring FastAPI to use Python type hints to declare parameters, and to generate a schema defining the API automatically. Hug inspired FastAPI to declare a response parameter in functions to set headers and cookies.","title":"Hug"},{"location":"alternatives/#apistar-05","text":"Right before deciding to build FastAPI I found APIStar server. It had almost everything I was looking for and had a great design. It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard. It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places. Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option. It had the best performance benchmarks at the time (only surpassed by Starlette). At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it. It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature. I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality. But then, the project's focus shifted. It was no longer an API web framework, as the creator needed to focus on Starlette. Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework. Info APIStar was created by Tom Christie. The same guy that created: Django REST Framework Starlette (in which FastAPI is based) Uvicorn (used by Starlette and FastAPI ) Inspired FastAPI to Exist. The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea. And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available. Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build FastAPI . I consider FastAPI a \"spiritual successor\" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools.","title":"APIStar (&lt;= 0.5)"},{"location":"alternatives/#used-by-fastapi","text":"","title":"Used by FastAPI"},{"location":"alternatives/#pydantic","text":"Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints. That makes it extremely intuitive. It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great. FastAPI uses it to Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema). FastAPI then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does.","title":"Pydantic"},{"location":"alternatives/#starlette","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high-performance asyncio services. It is very simple and intuitive. It's designed to be easily extensible, and have modular components. It has: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests. CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies. Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server. Starlette provides all the basic web microframework functionality. But it doesn't provide automatic data validation, serialization or documentation. That's one of the main things that FastAPI adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc. Technical Details ASGI is a new \"standard\" being developed by Django core team members. It is still not a \"Python standard\" (a PEP), although they are in the process of doing that. Nevertheless, it is already being used as a \"standard\" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like python-socketio . FastAPI uses it to Handle all the core web parts. Adding features on top. The class FastAPI itself inherits directly from the class Starlette . So, anything that you can do with Starlette, you can do it directly with FastAPI , as it is basically Starlette on steroids.","title":"Starlette"},{"location":"alternatives/#uvicorn","text":"Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools. It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or FastAPI ) would provide on top. It is the recommended server for Starlette and FastAPI . FastAPI recommends it as The main web server to run FastAPI applications. You can combine it with Gunicorn, to have an asynchronous multi-process server. Check more details in the Deployment section.","title":"Uvicorn"},{"location":"alternatives/#benchmarks-and-speed","text":"To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about Benchmarks .","title":"Benchmarks and speed"},{"location":"async/","text":"Details about the async def syntax for path operation functions and some background about asynchronous code, concurrency, and parallelism. In a hurry? \u00b6 TL;DR: If you are using third party libraries that tell you to call them with await , like: results = await some_library () Then, declare your path operation functions with async def like: @app . get ( '/' ) async def read_results (): results = await some_library () return results Note You can only use await inside of functions created with async def . If you are using a third party library that communicates with something (a database, an API, the file system, etc) and doesn't have support for using await , (this is currently the case for most database libraries), then declare your path operation functions as normally, with just def , like: @app . get ( '/' ) def results (): results = some_library () return results If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use async def . If you just don't know, use normal def . Note : you can mix def and async def in your path operation functions as much as you need and define each one using the best option for you. FastAPI will do the right thing with them. Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast. But by following the steps above, it will be able to do some performance optimizations. Technical Details \u00b6 Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\" , with async and await syntax. Let's see that phrase by parts in the sections below, below: Asynchronous Code async and await Coroutines Asynchronous Code \u00b6 Asynchronous code just means that the language has a way to tell the computer / program that at some point in the code, he will have to wait for something else to finish somewhere else. Let's say that something else is called \"slow-file\". So, during that time, the computer can go and do some other work, while \"slow-file\" finishes. Then the computer / program will come back every time it has a chance because it's waiting again, or whenever he finished all the work he had at that point. And it will see if any of the tasks he was waiting for has already finished doing whatever it had to do. And then it takes the first task to finish (let's say, our \"slow-file\") and continues whatever it had to do with it. That \"wait for something else\" normally refers to I/O operations that are relatively \"slow\" (compared to the speed of the processor and the RAM memory), like waiting for: the data from the client to be sent through the network the data sent by your program to be received by the client through the network the contents of a file in the disk to be read by the system and given to your program the contents your program gave to the system to be written to disk a remote API operation a database operation to finish a database query to return the results etc. As the execution time is consumed mostly by waiting for I/O operations, so they call them \"I/O bound\". It's called \"asynchronous\" because the computer / program doesn't have to be \"synchronized\" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work. Instead of that, by being an \"asynchronous\" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them. For \"synchronous\" (contrary to \"asynchronous\") they commonly also use the term \"sequential\", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting. Concurrency and Burgers \u00b6 This idea of asynchronous code described above is also sometimes called \"concurrency\" . It is different from \"parallelism\" . Concurrency and parallelism both relate to \"different things happening more or less at the same time\". But the details between concurrency and parallelism are quite different. To see the difference, imagine the following story about burgers: Concurrent Burgers \u00b6 You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. You pay. The cashier says something to the guy in the kitchen so he knows he has to prepare your burgers (even though he is currently preparing the ones for the previous clients). The cashier gives you the number of your turn. While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare). As you are seating on the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is. While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already. Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table. You and your crush eat the burgers and have a nice time. Imagine you are the computer / program in that story. While you are at the line, you are just idle, waiting for your turn, not doing anything very \"productive\". But the line is fast because the cashier is only taking the orders, so that's fine. Then, when it's your turn, you do actual \"productive\" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc. But then, even though you still don't have your burgers, your work with the cashier is \"on pause\", because you have to wait for your burgers to be ready. But as you go away from the counter and seat on the table with a number for your turn, you can switch your attention to your crush, and \"work\" on that. Then you are again doing something very \"productive\", as is flirting with your crush. Then the cashier says \"I'm finished with doing the burgers\" by putting your number on the counter display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs. So you wait for your crush to finish the story (finish the current work / task being processed), smile gently and say that you are going for the burgers. Then you go to the counter, to the initial task that is now finished, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter. That in turn, creates a new task, of \"eating burgers\", but the previous one of \"getting burgers\" is finished. Parallel Burgers \u00b6 You go with your crush to get parallel fast food. You stand in line while several (let's say 8) cashiers take the orders from the people in front of you. Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes himself and prepares the burger right away before getting the next order. Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you. You pay. The cashier goes to the kitchen. You wait, standing in front of the counter, so that no one else takes your burgers before you, as there are no numbers for turns. As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. This is \"synchronous\" work, you are \"synchronized\" with the cashier/cook. You have to wait and be there at the exact moment that the cashier/cook finishes the burgers and gives them to you, or otherwise, someone else might take them. Then your cashier/cook finally comes back with your burgers, after a long time waiting there in front of the counter. You take your burgers and go to the table with your crush. You just eat them, and you are done. There was not much talk or flirting as most of the time was spent waiting in front of the counter. In this scenario of the parallel burgers, you are a computer / program with two processors (you and your crush), both waiting and dedicating their attention to be \"waiting on the counter\" for a long time. The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook). But still, the final experience is not the best. This would be the parallel equivalent story for burgers. For a more \"real life\" example of this, imagine a bank. Up to recently, most of the banks had multiple cashiers and a big line. All of the cashiers doing all the work with one client after the other. And you have to wait in the line for a long time or you lose your turn. You probably wouldn't want to take your crush with you to do errands at the bank. Burger Conclusion \u00b6 In this scenario of \"fast food burgers with your crush\", as there is a lot of waiting, it makes a lot more sense to have a concurrent system. This is the case for most of the web applications. Many, many users, but your server is waiting for their not-so-good connection to send their requests. And then waiting again for the responses to come back. This \"waiting\" is measured in microseconds, but still, summing it all, it's a lot of waiting in the end. That's why it makes a lot of sense to use asynchronous code for web APIs. Most of the existing popular Python frameworks (including Flask and Django) were created before the new asynchronous features in Python existed. So, the ways they can be deployed support parallel execution and an older form of asynchronous execution that is not as powerful as the new capabilities. Even though the main specification for asynchronous web Python (ASGI) was developed at Django, to add support for WebSockets. That kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programing language. And that's the same level of performance you get with FastAPI . And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C (all thanks to Starlette) . Is concurrency better than parallelism? \u00b6 Nope! That's not the moral of the story. Concurrency is different than parallelism. And it is better on specific scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything. So, to balance that out, imagine the following short story: You have to clean a big, dirty house. Yep, that's the whole story . There's no waiting anywhere, just a lot of work to be done, on multiple places of the house. You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting for anything, just cleaning and cleaning, the turns wouldn't affect anything. It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work. But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in parallel , with the extra help, and finish much sooner. In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job. And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a CPU , they call these problems \"CPU bound\". Common examples of CPU bound operations are things that require complex math processing. For example: Audio or image processing Computer vision : an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time) Machine Learning : it normally requires lots of \"matrix\" and \"vector\" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time. Deep Learning : this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models. Concurrency + Parallelism: Web + Machine Learning \u00b6 With FastAPI you can take the advantage of concurrency that is very common for web development (the same main attractive of NodeJS). But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for CPU bound workloads like those in Machine Learning systems. That, plus the simple fact that Python is the main language for Data Science , Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others). To see how to achieve this parallelism in production see the section about Deployment . async and await \u00b6 Modern versions of python have a very intuitive way to define asynchronous code. This makes it look just like normal \"sequential\" code and do the \"awaiting\" for you at the right moments. When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like: burgers = await get_burgers ( 2 ) The key here is the await . It tells Python that it has to wait for get_burgers(2) to finish doing its thing before storing the results in burgers . With that, Python will know that it can go and do something else in the meanwhile (like receiving another request). For await to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with async def : async def get_burgers ( number : int ): # Do some asynchronous stuff to create the burgers return burgers ...instead of def : # This is not asynchronous def get_sequential_burgers ( number : int ): # Do some sequential stuff to create the burgers return burgers With async def , Python knows that, inside that function, it has to be aware of await expressions, and that it can \"pause\" the execution of that function and go do something else before coming back. When you want to call an async def function, you have to \"await\" it. So, this won't work: # This won't work, because get_burgers was defined with: async def burgers = get_burgers ( 2 ) So, if you are using a library that tells you that you can call it with await , you need to create the path operation functions that uses it with async def , like in: @app . get ( '/burgers' ) async def read_burgers (): burgers = await get_burgers ( 2 ) return burgers More technical details \u00b6 You might have noticed that await can only be used inside of functions defined with async def . But at the same time, functions defined with async def have to be \"awaited\". So, functions with async def can only be called inside of functions defined with async def too. So, about the egg and the chicken, how do you call the first async function? If you are working with FastAPI you don't have to worry about that, because that \"first\" function will be your path operation function , and FastAPI will know how to do the right thing. But if you want to use async / await without FastAPI, check the official Python docs . Other forms of asynchronous code \u00b6 This style of using async and await is relatively new in the language. But it makes working with asynchronous code a lot easier. This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS). But before that, handling asynchronous code was quite more complex and difficult. In previous versions of Python, you could have used threads or Gevent . But the code is way more complex to understand, debug, and think about. In previous versions of NodeJS / Browser JavaScript, you would have used \"callbacks\". Which lead to callback hell . Coroutines \u00b6 Coroutine is just the very fancy term for the thing returned by an async def function. Python knows that it is something like a function that it can start and that it will end at some point, but that it might be paused internally too, whenever there is an await inside of it. But all this functionality of using asynchronous code with async and await is many times summarized as using \"coroutines\". It is comparable to the main key feature of Go, the \"Goroutines\". Conclusion \u00b6 Let's see the same phrase from above: Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\" , with async and await syntax. That should make more sense now. All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance. Very Technical Details \u00b6 Warning You can probably skip this. These are very technical details of how FastAPI works underneath. If you have quite some technical knowledge (co-routines, threads, blocking, etc) and are curious about how FastAPI handles async def vs normal def , go ahead. Path operation functions \u00b6 When you declare a path operation function with normal def instead of async def , it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server). If you are coming from another async framework that does not work in the way described above and you are used to define trivial compute-only path operation functions with plain def for a tiny performance gain (about 100 nanoseconds), please note that in FastAPI the effect would be quite opposite. In these cases, it's better to use async def unless your path operation functions use code that performs blocking IO . Still, in both situations, chances are that FastAPI will still be faster than (or at least comparable to) your previous framework. Dependencies \u00b6 The same applies for dependencies. If a dependency is a standard def function instead of async def , it is run in the external threadpool. Sub-dependencies \u00b6 You can have multiple dependencies and sub-dependencies requiring each other (as parameters of the function definitions), some of them might be created with async def and some with normal def . It would still work, and the ones created with normal def would be called on an external thread instead of being \"awaited\". Other utility functions \u00b6 Any other utility function that you call directly can be created with normal def or async def and FastAPI won't affect the way you call it. This is in contrast to the functions that FastAPI calls for you: path operation functions and dependencies. If your utility function is a normal function with def , it will be called directly (as you write it in your code), not in a threadpool, if the function is created with async def then you should await for that function when you call it in your code. Again, these are very technical details that would probably be useful if you came searching for them. Otherwise, you should be good with the guidelines from the section above: In a hurry? .","title":"Concurrency and async / await"},{"location":"async/#in-a-hurry","text":"TL;DR: If you are using third party libraries that tell you to call them with await , like: results = await some_library () Then, declare your path operation functions with async def like: @app . get ( '/' ) async def read_results (): results = await some_library () return results Note You can only use await inside of functions created with async def . If you are using a third party library that communicates with something (a database, an API, the file system, etc) and doesn't have support for using await , (this is currently the case for most database libraries), then declare your path operation functions as normally, with just def , like: @app . get ( '/' ) def results (): results = some_library () return results If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use async def . If you just don't know, use normal def . Note : you can mix def and async def in your path operation functions as much as you need and define each one using the best option for you. FastAPI will do the right thing with them. Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast. But by following the steps above, it will be able to do some performance optimizations.","title":"In a hurry?"},{"location":"async/#technical-details","text":"Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\" , with async and await syntax. Let's see that phrase by parts in the sections below, below: Asynchronous Code async and await Coroutines","title":"Technical Details"},{"location":"async/#asynchronous-code","text":"Asynchronous code just means that the language has a way to tell the computer / program that at some point in the code, he will have to wait for something else to finish somewhere else. Let's say that something else is called \"slow-file\". So, during that time, the computer can go and do some other work, while \"slow-file\" finishes. Then the computer / program will come back every time it has a chance because it's waiting again, or whenever he finished all the work he had at that point. And it will see if any of the tasks he was waiting for has already finished doing whatever it had to do. And then it takes the first task to finish (let's say, our \"slow-file\") and continues whatever it had to do with it. That \"wait for something else\" normally refers to I/O operations that are relatively \"slow\" (compared to the speed of the processor and the RAM memory), like waiting for: the data from the client to be sent through the network the data sent by your program to be received by the client through the network the contents of a file in the disk to be read by the system and given to your program the contents your program gave to the system to be written to disk a remote API operation a database operation to finish a database query to return the results etc. As the execution time is consumed mostly by waiting for I/O operations, so they call them \"I/O bound\". It's called \"asynchronous\" because the computer / program doesn't have to be \"synchronized\" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work. Instead of that, by being an \"asynchronous\" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them. For \"synchronous\" (contrary to \"asynchronous\") they commonly also use the term \"sequential\", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting.","title":"Asynchronous Code"},{"location":"async/#concurrency-and-burgers","text":"This idea of asynchronous code described above is also sometimes called \"concurrency\" . It is different from \"parallelism\" . Concurrency and parallelism both relate to \"different things happening more or less at the same time\". But the details between concurrency and parallelism are quite different. To see the difference, imagine the following story about burgers:","title":"Concurrency and Burgers"},{"location":"async/#concurrent-burgers","text":"You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. You pay. The cashier says something to the guy in the kitchen so he knows he has to prepare your burgers (even though he is currently preparing the ones for the previous clients). The cashier gives you the number of your turn. While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare). As you are seating on the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is. While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already. Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table. You and your crush eat the burgers and have a nice time. Imagine you are the computer / program in that story. While you are at the line, you are just idle, waiting for your turn, not doing anything very \"productive\". But the line is fast because the cashier is only taking the orders, so that's fine. Then, when it's your turn, you do actual \"productive\" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc. But then, even though you still don't have your burgers, your work with the cashier is \"on pause\", because you have to wait for your burgers to be ready. But as you go away from the counter and seat on the table with a number for your turn, you can switch your attention to your crush, and \"work\" on that. Then you are again doing something very \"productive\", as is flirting with your crush. Then the cashier says \"I'm finished with doing the burgers\" by putting your number on the counter display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs. So you wait for your crush to finish the story (finish the current work / task being processed), smile gently and say that you are going for the burgers. Then you go to the counter, to the initial task that is now finished, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter. That in turn, creates a new task, of \"eating burgers\", but the previous one of \"getting burgers\" is finished.","title":"Concurrent Burgers"},{"location":"async/#parallel-burgers","text":"You go with your crush to get parallel fast food. You stand in line while several (let's say 8) cashiers take the orders from the people in front of you. Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes himself and prepares the burger right away before getting the next order. Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you. You pay. The cashier goes to the kitchen. You wait, standing in front of the counter, so that no one else takes your burgers before you, as there are no numbers for turns. As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. This is \"synchronous\" work, you are \"synchronized\" with the cashier/cook. You have to wait and be there at the exact moment that the cashier/cook finishes the burgers and gives them to you, or otherwise, someone else might take them. Then your cashier/cook finally comes back with your burgers, after a long time waiting there in front of the counter. You take your burgers and go to the table with your crush. You just eat them, and you are done. There was not much talk or flirting as most of the time was spent waiting in front of the counter. In this scenario of the parallel burgers, you are a computer / program with two processors (you and your crush), both waiting and dedicating their attention to be \"waiting on the counter\" for a long time. The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook). But still, the final experience is not the best. This would be the parallel equivalent story for burgers. For a more \"real life\" example of this, imagine a bank. Up to recently, most of the banks had multiple cashiers and a big line. All of the cashiers doing all the work with one client after the other. And you have to wait in the line for a long time or you lose your turn. You probably wouldn't want to take your crush with you to do errands at the bank.","title":"Parallel Burgers"},{"location":"async/#burger-conclusion","text":"In this scenario of \"fast food burgers with your crush\", as there is a lot of waiting, it makes a lot more sense to have a concurrent system. This is the case for most of the web applications. Many, many users, but your server is waiting for their not-so-good connection to send their requests. And then waiting again for the responses to come back. This \"waiting\" is measured in microseconds, but still, summing it all, it's a lot of waiting in the end. That's why it makes a lot of sense to use asynchronous code for web APIs. Most of the existing popular Python frameworks (including Flask and Django) were created before the new asynchronous features in Python existed. So, the ways they can be deployed support parallel execution and an older form of asynchronous execution that is not as powerful as the new capabilities. Even though the main specification for asynchronous web Python (ASGI) was developed at Django, to add support for WebSockets. That kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programing language. And that's the same level of performance you get with FastAPI . And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C (all thanks to Starlette) .","title":"Burger Conclusion"},{"location":"async/#is-concurrency-better-than-parallelism","text":"Nope! That's not the moral of the story. Concurrency is different than parallelism. And it is better on specific scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything. So, to balance that out, imagine the following short story: You have to clean a big, dirty house. Yep, that's the whole story . There's no waiting anywhere, just a lot of work to be done, on multiple places of the house. You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting for anything, just cleaning and cleaning, the turns wouldn't affect anything. It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work. But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in parallel , with the extra help, and finish much sooner. In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job. And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a CPU , they call these problems \"CPU bound\". Common examples of CPU bound operations are things that require complex math processing. For example: Audio or image processing Computer vision : an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time) Machine Learning : it normally requires lots of \"matrix\" and \"vector\" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time. Deep Learning : this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models.","title":"Is concurrency better than parallelism?"},{"location":"async/#concurrency-parallelism-web-machine-learning","text":"With FastAPI you can take the advantage of concurrency that is very common for web development (the same main attractive of NodeJS). But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for CPU bound workloads like those in Machine Learning systems. That, plus the simple fact that Python is the main language for Data Science , Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others). To see how to achieve this parallelism in production see the section about Deployment .","title":"Concurrency + Parallelism: Web + Machine Learning"},{"location":"async/#async-and-await","text":"Modern versions of python have a very intuitive way to define asynchronous code. This makes it look just like normal \"sequential\" code and do the \"awaiting\" for you at the right moments. When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like: burgers = await get_burgers ( 2 ) The key here is the await . It tells Python that it has to wait for get_burgers(2) to finish doing its thing before storing the results in burgers . With that, Python will know that it can go and do something else in the meanwhile (like receiving another request). For await to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with async def : async def get_burgers ( number : int ): # Do some asynchronous stuff to create the burgers return burgers ...instead of def : # This is not asynchronous def get_sequential_burgers ( number : int ): # Do some sequential stuff to create the burgers return burgers With async def , Python knows that, inside that function, it has to be aware of await expressions, and that it can \"pause\" the execution of that function and go do something else before coming back. When you want to call an async def function, you have to \"await\" it. So, this won't work: # This won't work, because get_burgers was defined with: async def burgers = get_burgers ( 2 ) So, if you are using a library that tells you that you can call it with await , you need to create the path operation functions that uses it with async def , like in: @app . get ( '/burgers' ) async def read_burgers (): burgers = await get_burgers ( 2 ) return burgers","title":"async and await"},{"location":"async/#more-technical-details","text":"You might have noticed that await can only be used inside of functions defined with async def . But at the same time, functions defined with async def have to be \"awaited\". So, functions with async def can only be called inside of functions defined with async def too. So, about the egg and the chicken, how do you call the first async function? If you are working with FastAPI you don't have to worry about that, because that \"first\" function will be your path operation function , and FastAPI will know how to do the right thing. But if you want to use async / await without FastAPI, check the official Python docs .","title":"More technical details"},{"location":"async/#other-forms-of-asynchronous-code","text":"This style of using async and await is relatively new in the language. But it makes working with asynchronous code a lot easier. This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS). But before that, handling asynchronous code was quite more complex and difficult. In previous versions of Python, you could have used threads or Gevent . But the code is way more complex to understand, debug, and think about. In previous versions of NodeJS / Browser JavaScript, you would have used \"callbacks\". Which lead to callback hell .","title":"Other forms of asynchronous code"},{"location":"async/#coroutines","text":"Coroutine is just the very fancy term for the thing returned by an async def function. Python knows that it is something like a function that it can start and that it will end at some point, but that it might be paused internally too, whenever there is an await inside of it. But all this functionality of using asynchronous code with async and await is many times summarized as using \"coroutines\". It is comparable to the main key feature of Go, the \"Goroutines\".","title":"Coroutines"},{"location":"async/#conclusion","text":"Let's see the same phrase from above: Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\" , with async and await syntax. That should make more sense now. All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance.","title":"Conclusion"},{"location":"async/#very-technical-details","text":"Warning You can probably skip this. These are very technical details of how FastAPI works underneath. If you have quite some technical knowledge (co-routines, threads, blocking, etc) and are curious about how FastAPI handles async def vs normal def , go ahead.","title":"Very Technical Details"},{"location":"async/#path-operation-functions","text":"When you declare a path operation function with normal def instead of async def , it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server). If you are coming from another async framework that does not work in the way described above and you are used to define trivial compute-only path operation functions with plain def for a tiny performance gain (about 100 nanoseconds), please note that in FastAPI the effect would be quite opposite. In these cases, it's better to use async def unless your path operation functions use code that performs blocking IO . Still, in both situations, chances are that FastAPI will still be faster than (or at least comparable to) your previous framework.","title":"Path operation functions"},{"location":"async/#dependencies","text":"The same applies for dependencies. If a dependency is a standard def function instead of async def , it is run in the external threadpool.","title":"Dependencies"},{"location":"async/#sub-dependencies","text":"You can have multiple dependencies and sub-dependencies requiring each other (as parameters of the function definitions), some of them might be created with async def and some with normal def . It would still work, and the ones created with normal def would be called on an external thread instead of being \"awaited\".","title":"Sub-dependencies"},{"location":"async/#other-utility-functions","text":"Any other utility function that you call directly can be created with normal def or async def and FastAPI won't affect the way you call it. This is in contrast to the functions that FastAPI calls for you: path operation functions and dependencies. If your utility function is a normal function with def , it will be called directly (as you write it in your code), not in a threadpool, if the function is created with async def then you should await for that function when you call it in your code. Again, these are very technical details that would probably be useful if you came searching for them. Otherwise, you should be good with the guidelines from the section above: In a hurry? .","title":"Other utility functions"},{"location":"benchmarks/","text":"Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) But when checking benchmarks and comparisons you should have the following in mind. Benchmarks and speed \u00b6 When you check the benchmarks, it is common to see several tools of different types compared as equivalent. Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools). The simplest the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool. The hierarchy is like: Uvicorn : an ASGI server Starlette : (uses Uvicorn) a web microframework FastAPI : (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc. Uvicorn : Will have the best performance, as it doesn't have much extra code apart from the server itself. You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or FastAPI ). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs. If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers. Starlette : Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get \"slower\" than Uvicorn by having to execute more code. But it provides you the tools to build simple web applications, with routing based on paths, etc. If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks). FastAPI : The same way that Starlette uses Uvicorn and cannot be faster than it, FastAPI uses Starlette, so it cannot be faster than it. FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup). If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications. So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code). If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.","title":"Benchmarks"},{"location":"benchmarks/#benchmarks-and-speed","text":"When you check the benchmarks, it is common to see several tools of different types compared as equivalent. Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools). The simplest the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool. The hierarchy is like: Uvicorn : an ASGI server Starlette : (uses Uvicorn) a web microframework FastAPI : (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc. Uvicorn : Will have the best performance, as it doesn't have much extra code apart from the server itself. You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or FastAPI ). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs. If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers. Starlette : Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get \"slower\" than Uvicorn by having to execute more code. But it provides you the tools to build simple web applications, with routing based on paths, etc. If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks). FastAPI : The same way that Starlette uses Uvicorn and cannot be faster than it, FastAPI uses Starlette, so it cannot be faster than it. FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup). If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications. So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code). If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.","title":"Benchmarks and speed"},{"location":"contributing/","text":"First, you might want to see the basic ways to help FastAPI and get help . Developing \u00b6 If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. Virtual environment with venv \u00b6 You can create a virtual environment in a directory using Python's venv module: $ python -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment. Activate the environment \u00b6 Activate the new environment with: $ source ./env/bin/activate Or in Windows' PowerShell: $ . \\e nv \\S cripts \\A ctivate.ps1 Or if you use Bash for Windows (e.g. Git Bash ): $ source ./env/Scripts/activate To check it worked, use: $ which pip some/directory/fastapi/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Or in Windows PowerShell: Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally. Flit \u00b6 FastAPI uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI in your local environment. Using your local FastAPI \u00b6 If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your local FastAPI source code. And if you update that local FastAPI source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI you just edited. That way, you don't have to \"install\" your local version to be able to test every change. Format \u00b6 There is a script that you can run that will format and clean all your code: $ bash scripts/format.sh It will also auto-sort all your imports. For it to sort them correctly, you need to have FastAPI installed locally in your environment, with the command in the section above: $ flit install --symlink Format imports \u00b6 There is another script that formats all the imports and makes sure you don't have unused imports: $ bash scripts/format-imports.sh As it runs one command after the other and modifies and reverts many files, it takes a bit longer to run, so it might be easier to use scripts/format.sh frequently and scripts/format-imports.sh only before committing. Docs \u00b6 The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the tutorials have blocks of code. In most of the cases, these blocks of code are actual complete applications that can be run as is. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs/src/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for tests \u00b6 Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:8008 . That way, you can edit the documentation/source files and see the changes live. Apps and docs at the same time \u00b6 If you run the examples with, e.g.: $ uvicorn tutorial001:app --reload as Uvicorn by default will use the port 8000 , the documentation on port 8008 won't clash. Tests \u00b6 There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/test-cov-html.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing. Tests in your editor \u00b6 If you want to use the integrated tests in your editor add ./docs/src to your PYTHONPATH variable. For example, in VS Code you can create a file .env with: PYTHONPATH=./docs/src","title":"Development - Contributing"},{"location":"contributing/#developing","text":"If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.","title":"Developing"},{"location":"contributing/#virtual-environment-with-venv","text":"You can create a virtual environment in a directory using Python's venv module: $ python -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment.","title":"Virtual environment with venv"},{"location":"contributing/#activate-the-environment","text":"Activate the new environment with: $ source ./env/bin/activate Or in Windows' PowerShell: $ . \\e nv \\S cripts \\A ctivate.ps1 Or if you use Bash for Windows (e.g. Git Bash ): $ source ./env/Scripts/activate To check it worked, use: $ which pip some/directory/fastapi/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Or in Windows PowerShell: Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally.","title":"Activate the environment"},{"location":"contributing/#flit","text":"FastAPI uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI in your local environment.","title":"Flit"},{"location":"contributing/#using-your-local-fastapi","text":"If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your local FastAPI source code. And if you update that local FastAPI source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI you just edited. That way, you don't have to \"install\" your local version to be able to test every change.","title":"Using your local FastAPI"},{"location":"contributing/#format","text":"There is a script that you can run that will format and clean all your code: $ bash scripts/format.sh It will also auto-sort all your imports. For it to sort them correctly, you need to have FastAPI installed locally in your environment, with the command in the section above: $ flit install --symlink","title":"Format"},{"location":"contributing/#format-imports","text":"There is another script that formats all the imports and makes sure you don't have unused imports: $ bash scripts/format-imports.sh As it runs one command after the other and modifies and reverts many files, it takes a bit longer to run, so it might be easier to use scripts/format.sh frequently and scripts/format-imports.sh only before committing.","title":"Format imports"},{"location":"contributing/#docs","text":"The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the tutorials have blocks of code. In most of the cases, these blocks of code are actual complete applications that can be run as is. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs/src/ directory. And those Python files are included/injected in the documentation when generating the site.","title":"Docs"},{"location":"contributing/#docs-for-tests","text":"Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:8008 . That way, you can edit the documentation/source files and see the changes live.","title":"Docs for tests"},{"location":"contributing/#apps-and-docs-at-the-same-time","text":"If you run the examples with, e.g.: $ uvicorn tutorial001:app --reload as Uvicorn by default will use the port 8000 , the documentation on port 8008 won't clash.","title":"Apps and docs at the same time"},{"location":"contributing/#tests","text":"There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/test-cov-html.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Tests"},{"location":"contributing/#tests-in-your-editor","text":"If you want to use the integrated tests in your editor add ./docs/src to your PYTHONPATH variable. For example, in VS Code you can create a file .env with: PYTHONPATH=./docs/src","title":"Tests in your editor"},{"location":"deployment/","text":"You can use Docker for deployment. It has several advantages like security, replicability, development simplicity, etc. In this section you'll see instructions and links to guides to know how to: Make your FastAPI application a Docker image/container with maximum performance. In about 5 min . (Optionally) understand what you, as a developer, need to know about HTTPS. Set up a Docker Swarm mode cluster with automatic HTTPS, even on a simple $5 USD/month server. In about 20 min . Generate and deploy a full FastAPI application, using your Docker Swarm cluster, with HTTPS, etc. In about 10 min . You can also easily use FastAPI in a standard server directly too (without Docker). Docker \u00b6 If you are using Docker, you can use the official Docker image: tiangolo/uvicorn-gunicorn-fastapi \u00b6 This image has an \"auto-tuning\" mechanism included, so that you can just add your code and get very high performance automatically. And without making sacrifices. But you can still change and update all the configurations with environment variables or configuration files. Tip To see all the configurations and options, go to the Docker image page: tiangolo/uvicorn-gunicorn-fastapi . Create a Dockerfile \u00b6 Go to your project directory. Create a Dockerfile with: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7 COPY ./app /app Bigger Applications \u00b6 If you followed the section about creating Bigger Applications with Multiple Files , your Dockerfile might instead look like: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7 COPY ./app /app/app Raspberry Pi and other architectures \u00b6 If you are running Docker in a Raspberry Pi (that has an ARM processor) or any other architecture, you can create a Dockerfile from scratch, based on a Python base image (that is multi-architecture) and use Uvicorn alone. In this case, your Dockerfile could look like: FROM python:3.7 RUN pip install fastapi uvicorn EXPOSE 80 COPY ./app /app CMD [ \"uvicorn\" , \"app.main:app\" , \"--host\" , \"0.0.0.0\" , \"--port\" , \"80\" ] Create the FastAPI Code \u00b6 Create an app directory and enter in it. Create a main.py file with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } You should now have a directory structure like: . \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 Dockerfile Build the Docker image \u00b6 Go to the project directory (in where your Dockerfile is, containing your app directory). Build your FastAPI image: docker build -t myimage . Start the Docker container \u00b6 Run a container based on your image: docker run -d --name mycontainer -p 80 :80 myimage Now you have an optimized FastAPI server in a Docker container. Auto-tuned for your current server (and number of CPU cores). Check it \u00b6 You should be able to check it in your Docker container's URL, for example: http://192.168.99.100/items/5?q=somequery or http://127.0.0.1/items/5?q=somequery (or equivalent, using your Docker host). You will see something like: { \"item_id\" : 5 , \"q\" : \"somequery\" } Interactive API docs \u00b6 Now you can go to http://192.168.99.100/docs or http://127.0.0.1/docs (or equivalent, using your Docker host). You will see the automatic interactive API documentation (provided by Swagger UI ): Alternative API docs \u00b6 And you can also go to http://192.168.99.100/redoc or http://127.0.0.1/redoc (or equivalent, using your Docker host). You will see the alternative automatic documentation (provided by ReDoc ): HTTPS \u00b6 About HTTPS \u00b6 It is easy to assume that HTTPS is something that is just \"enabled\" or not. But it is way more complex than that. Tip If you are in a hurry or don't care, continue with the next section for step by step instructions to set everything up. To learn the basics of HTTPS, from a consumer perspective, check https://howhttps.works/ . Now, from a developer's perspective, here are several things to have in mind while thinking about HTTPS: For HTTPS, the server needs to have \"certificates\" generated by a third party. Those certificates are actually acquired from the third-party, not \"generated\". Certificates have a lifetime. They expire. And then they need to be renewed, acquired again from the third party. The encryption of the connection happens at the TCP level. That's one layer below HTTP. So, the certificate and encryption handling is done before HTTP. TCP doesn't know about \"domains\". Only about IP addresses. The information about the specific domain requested goes in the HTTP data. The HTTPS certificates \"certify\" a certain domain, but the protocol and encryption happen at the TCP level, before knowing which domain is being dealt with. By default, that would mean that you can only have one HTTPS certificate per IP address. No matter how big your server is or how small each application you have on it might be. There is a solution to this, however. There's an extension to the TLS protocol (the one handling the encryption at the TCP level, before HTTP) called SNI . This SNI extension allows one single server (with a single IP address) to have several HTTPS certificates and serve multiple HTTPS domains/applications. For this to work, a single component (program) running on the server, listening on the public IP address, must have all the HTTPS certificates in the server. After obtaining a secure connection, the communication protocol is still HTTP. The contents are encrypted, even though they are being sent with the HTTP protocol. It is a common practice to have one program/HTTP server running on the server (the machine, host, etc.) and managing all the HTTPS parts : sending the decrypted HTTP requests to the actual HTTP application running in the same server (the FastAPI application, in this case), take the HTTP response from the application, encrypt it using the appropriate certificate and sending it back to the client using HTTPS. This server is often called a TLS Termination Proxy . Let's Encrypt \u00b6 Before Let's Encrypt, these HTTPS certificates were sold by trusted third-parties. The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive. But then Let's Encrypt was created. It is a project from the Linux Foundation. It provides HTTPS certificates for free. In an automated way. These certificates use all the standard cryptographic security, and are short lived (about 3 months), so the security is actually better because of their reduced lifespan. The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates. The idea is to automate the acquisition and renewal of these certificates, so that you can have secure HTTPS, for free, forever. Traefik \u00b6 Traefik is a high performance reverse proxy / load balancer. It can do the \"TLS Termination Proxy\" job (apart from other features). It has integration with Let's Encrypt. So, it can handle all the HTTPS parts, including certificate acquisition and renewal. It also has integrations with Docker. So, you can declare your domains in each application configurations and have it read those configurations, generate the HTTPS certificates and serve HTTPS to your application automatically, without requiring any change in its configuration. With this information and tools, continue with the next section to combine everything. Docker Swarm mode cluster with Traefik and HTTPS \u00b6 You can have a Docker Swarm mode cluster set up in minutes (about 20 min) with a main Traefik handling HTTPS (including certificate acquisition and renewal). By using Docker Swarm mode, you can start with a \"cluster\" of a single machine (it can even be a $5 USD / month server) and then you can grow as much as you need adding more servers. To set up a Docker Swarm Mode cluster with Traefik and HTTPS handling, follow this guide: Docker Swarm Mode and Traefik for an HTTPS cluster \u00b6 Deploy a FastAPI application \u00b6 The easiest way to set everything up, would be using the FastAPI Project Generators . It is designed to be integrated with this Docker Swarm cluster with Traefik and HTTPS described above. You can generate a project in about 2 min. The generated project has instructions to deploy it, doing it takes another 2 min. Alternatively, deploy FastAPI without Docker \u00b6 You can deploy FastAPI directly without Docker too. You just need to install an ASGI compatible server like: Uvicorn , a lightning-fast ASGI server, built on uvloop and httptools. pip install uvicorn Hypercorn , an ASGI server also compatible with HTTP/2. pip install hypercorn ...or any other ASGI server. And run your application the same way you have done in the tutorials, but without the --reload option, e.g.: uvicorn main:app --host 0 .0.0.0 --port 80 or with Hypercorn: hypercorn main:app --bind 0 .0.0.0:80 You might want to set up some tooling to make sure it is restarted automatically if it stops. You might also want to install Gunicorn and use it as a manager for Uvicorn , or use Hypercorn with multiple workers. Making sure to fine-tune the number of workers, etc. But if you are doing all that, you might just use the Docker image that does it automatically.","title":"Deployment"},{"location":"deployment/#docker","text":"If you are using Docker, you can use the official Docker image:","title":"Docker"},{"location":"deployment/#tiangolouvicorn-gunicorn-fastapi","text":"This image has an \"auto-tuning\" mechanism included, so that you can just add your code and get very high performance automatically. And without making sacrifices. But you can still change and update all the configurations with environment variables or configuration files. Tip To see all the configurations and options, go to the Docker image page: tiangolo/uvicorn-gunicorn-fastapi .","title":"tiangolo/uvicorn-gunicorn-fastapi"},{"location":"deployment/#create-a-dockerfile","text":"Go to your project directory. Create a Dockerfile with: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7 COPY ./app /app","title":"Create a Dockerfile"},{"location":"deployment/#bigger-applications","text":"If you followed the section about creating Bigger Applications with Multiple Files , your Dockerfile might instead look like: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7 COPY ./app /app/app","title":"Bigger Applications"},{"location":"deployment/#raspberry-pi-and-other-architectures","text":"If you are running Docker in a Raspberry Pi (that has an ARM processor) or any other architecture, you can create a Dockerfile from scratch, based on a Python base image (that is multi-architecture) and use Uvicorn alone. In this case, your Dockerfile could look like: FROM python:3.7 RUN pip install fastapi uvicorn EXPOSE 80 COPY ./app /app CMD [ \"uvicorn\" , \"app.main:app\" , \"--host\" , \"0.0.0.0\" , \"--port\" , \"80\" ]","title":"Raspberry Pi and other architectures"},{"location":"deployment/#create-the-fastapi-code","text":"Create an app directory and enter in it. Create a main.py file with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } You should now have a directory structure like: . \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 Dockerfile","title":"Create the FastAPI Code"},{"location":"deployment/#build-the-docker-image","text":"Go to the project directory (in where your Dockerfile is, containing your app directory). Build your FastAPI image: docker build -t myimage .","title":"Build the Docker image"},{"location":"deployment/#start-the-docker-container","text":"Run a container based on your image: docker run -d --name mycontainer -p 80 :80 myimage Now you have an optimized FastAPI server in a Docker container. Auto-tuned for your current server (and number of CPU cores).","title":"Start the Docker container"},{"location":"deployment/#check-it","text":"You should be able to check it in your Docker container's URL, for example: http://192.168.99.100/items/5?q=somequery or http://127.0.0.1/items/5?q=somequery (or equivalent, using your Docker host). You will see something like: { \"item_id\" : 5 , \"q\" : \"somequery\" }","title":"Check it"},{"location":"deployment/#interactive-api-docs","text":"Now you can go to http://192.168.99.100/docs or http://127.0.0.1/docs (or equivalent, using your Docker host). You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"deployment/#alternative-api-docs","text":"And you can also go to http://192.168.99.100/redoc or http://127.0.0.1/redoc (or equivalent, using your Docker host). You will see the alternative automatic documentation (provided by ReDoc ):","title":"Alternative API docs"},{"location":"deployment/#https","text":"","title":"HTTPS"},{"location":"deployment/#about-https","text":"It is easy to assume that HTTPS is something that is just \"enabled\" or not. But it is way more complex than that. Tip If you are in a hurry or don't care, continue with the next section for step by step instructions to set everything up. To learn the basics of HTTPS, from a consumer perspective, check https://howhttps.works/ . Now, from a developer's perspective, here are several things to have in mind while thinking about HTTPS: For HTTPS, the server needs to have \"certificates\" generated by a third party. Those certificates are actually acquired from the third-party, not \"generated\". Certificates have a lifetime. They expire. And then they need to be renewed, acquired again from the third party. The encryption of the connection happens at the TCP level. That's one layer below HTTP. So, the certificate and encryption handling is done before HTTP. TCP doesn't know about \"domains\". Only about IP addresses. The information about the specific domain requested goes in the HTTP data. The HTTPS certificates \"certify\" a certain domain, but the protocol and encryption happen at the TCP level, before knowing which domain is being dealt with. By default, that would mean that you can only have one HTTPS certificate per IP address. No matter how big your server is or how small each application you have on it might be. There is a solution to this, however. There's an extension to the TLS protocol (the one handling the encryption at the TCP level, before HTTP) called SNI . This SNI extension allows one single server (with a single IP address) to have several HTTPS certificates and serve multiple HTTPS domains/applications. For this to work, a single component (program) running on the server, listening on the public IP address, must have all the HTTPS certificates in the server. After obtaining a secure connection, the communication protocol is still HTTP. The contents are encrypted, even though they are being sent with the HTTP protocol. It is a common practice to have one program/HTTP server running on the server (the machine, host, etc.) and managing all the HTTPS parts : sending the decrypted HTTP requests to the actual HTTP application running in the same server (the FastAPI application, in this case), take the HTTP response from the application, encrypt it using the appropriate certificate and sending it back to the client using HTTPS. This server is often called a TLS Termination Proxy .","title":"About HTTPS"},{"location":"deployment/#lets-encrypt","text":"Before Let's Encrypt, these HTTPS certificates were sold by trusted third-parties. The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive. But then Let's Encrypt was created. It is a project from the Linux Foundation. It provides HTTPS certificates for free. In an automated way. These certificates use all the standard cryptographic security, and are short lived (about 3 months), so the security is actually better because of their reduced lifespan. The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates. The idea is to automate the acquisition and renewal of these certificates, so that you can have secure HTTPS, for free, forever.","title":"Let's Encrypt"},{"location":"deployment/#traefik","text":"Traefik is a high performance reverse proxy / load balancer. It can do the \"TLS Termination Proxy\" job (apart from other features). It has integration with Let's Encrypt. So, it can handle all the HTTPS parts, including certificate acquisition and renewal. It also has integrations with Docker. So, you can declare your domains in each application configurations and have it read those configurations, generate the HTTPS certificates and serve HTTPS to your application automatically, without requiring any change in its configuration. With this information and tools, continue with the next section to combine everything.","title":"Traefik"},{"location":"deployment/#docker-swarm-mode-cluster-with-traefik-and-https","text":"You can have a Docker Swarm mode cluster set up in minutes (about 20 min) with a main Traefik handling HTTPS (including certificate acquisition and renewal). By using Docker Swarm mode, you can start with a \"cluster\" of a single machine (it can even be a $5 USD / month server) and then you can grow as much as you need adding more servers. To set up a Docker Swarm Mode cluster with Traefik and HTTPS handling, follow this guide:","title":"Docker Swarm mode cluster with Traefik and HTTPS"},{"location":"deployment/#docker-swarm-mode-and-traefik-for-an-https-cluster","text":"","title":"Docker Swarm Mode and Traefik for an HTTPS cluster"},{"location":"deployment/#deploy-a-fastapi-application","text":"The easiest way to set everything up, would be using the FastAPI Project Generators . It is designed to be integrated with this Docker Swarm cluster with Traefik and HTTPS described above. You can generate a project in about 2 min. The generated project has instructions to deploy it, doing it takes another 2 min.","title":"Deploy a FastAPI application"},{"location":"deployment/#alternatively-deploy-fastapi-without-docker","text":"You can deploy FastAPI directly without Docker too. You just need to install an ASGI compatible server like: Uvicorn , a lightning-fast ASGI server, built on uvloop and httptools. pip install uvicorn Hypercorn , an ASGI server also compatible with HTTP/2. pip install hypercorn ...or any other ASGI server. And run your application the same way you have done in the tutorials, but without the --reload option, e.g.: uvicorn main:app --host 0 .0.0.0 --port 80 or with Hypercorn: hypercorn main:app --bind 0 .0.0.0:80 You might want to set up some tooling to make sure it is restarted automatically if it stops. You might also want to install Gunicorn and use it as a manager for Uvicorn , or use Hypercorn with multiple workers. Making sure to fine-tune the number of workers, etc. But if you are doing all that, you might just use the Docker image that does it automatically.","title":"Alternatively, deploy FastAPI without Docker"},{"location":"external-links/","text":"FastAPI has a great community constantly growing. There are many posts, articles, tools, and projects, related to FastAPI . Here's an incomplete list of some of them. Tip If you have an article, project, tool, or anything related to FastAPI that is not yet listed here, create a Pull Request adding it . Articles \u00b6 English \u00b6 FastAPI/Starlette debug vs prod by William Hayes . FastAPI\u200a\u2014\u200aGoogle as an external authentication provider by Nils de Bruin . FastAPI\u200a\u2014\u200aHow to add basic and cookie authentication by Nils de Bruin . Introduction to the fastapi python framework by Errieta Kostala . FastAPI and Scikit-Learn: Easily Deploy Models by Nick Cortale . FastAPI authentication revisited: Enabling API key authentication by Nils de Bruin . FastAPI, a simple use case on logging by @euri10 . Deploying a scikit-learn model with ONNX and FastAPI by Nico Axtmann . Top 5 Asynchronous Web Frameworks for Python by Ankush Thakur on GeekFlare . JWT Authentication with FastAPI and AWS Cognito by Johannes Gontrum . How to Deploy a Machine Learning Model by Maarten Grootendorst on Towards Data Science . Uber: Ludwig v0.2 Adds New Features and Other Improvements to its Deep Learning Toolbox [including a FastAPI server] on Uber Engineering . A FastAPI and Swagger UI visual cheatsheet by @euri10 Using Docker Compose to deploy a lightweight Python REST API with a job queue by Mike Moritz . Setting up Tortoise ORM with FastAPI by Rob Wagner . Why I'm Leaving Flask by Dylan Anthony . How To Deploy Tensorflow 2.0 Models As An API Service With FastAPI & Docker by Bernard Brenyah . TestDriven.io: Developing and Testing an Asynchronous API with FastAPI and Pytest by Michael Herman . Towards Data Science: Deploying Iris Classifications with FastAPI and Docker by Mandy Gu . Deploy Machine Learning Models with Keras, FastAPI, Redis and Docker by Shane Soh . Another Boilerplate to FastAPI: Azure Pipeline CI + Pytest by Arthur Henrique . How to continuously deploy a FastAPI to AWS Lambda with AWS SAM by Benjamin Ramser . Create and Deploy FastAPI app to Heroku without using Docker by Navule Pavan Kumar Rao . Japanese \u00b6 FastAPI\uff5cDB\u63a5\u7d9a\u3057\u3066CRUD\u3059\u308bPython\u88fdAPI\u30b5\u30fc\u30d0\u30fc\u3092\u69cb\u7bc9 by @mtitg . python\u88fd\u306e\u6700\u65b0API\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI \u3092\u89e6\u3063\u3066\u307f\u305f by @ryoryomaru . FastAPI\u3067CORS\u3092\u56de\u907f by @angel_katayoku . FastAPI\u3092MySQL\u3068\u63a5\u7d9a\u3057\u3066Docker\u3067\u7ba1\u7406\u3057\u3066\u307f\u308b by @angel_katayoku . FastAPI\u3067POST\u3055\u308c\u305fJSON\u306e\u30ec\u30b9\u30dd\u30f3\u30b9body\u3092\u53d7\u3051\u53d6\u308b by @angel_katayoku . \u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u958b\u767a\u8005\u5411\u3051\u306eDocker\u306b\u3088\u308bPython\u958b\u767a\u74b0\u5883\u69cb\u7bc9 by Hikaru Takahashi . \u3010\u7b2c1\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: ToDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u74b0\u5883\u69cb\u7bc9\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c2\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: ToDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u30e2\u30c7\u30eb\u69cb\u7bc9\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c3\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: toDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u8a8d\u8a3c\u30fb\u30e6\u30fc\u30b6\u767b\u9332\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c4\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: toDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u7ba1\u7406\u8005\u30da\u30fc\u30b8\u6539\u826f\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 Python\u306eWeb framework\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u6bd4\u8f03 (Django, Flask, responder, FastAPI, japronto) by @bee2 . [FastAPI] Python\u88fd\u306eASGI Web \u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI\u306b\u5165\u9580\u3059\u308b by @bee2 . Chinese \u00b6 \u4f7f\u7528FastAPI\u6846\u67b6\u5feb\u901f\u6784\u5efa\u9ad8\u6027\u80fd\u7684api\u670d\u52a1 by \u900d\u9065\u6563\u4eba . FastAPI\u6846\u67b6\u4e2d\u6587\u6587\u6863 by \u4f55\u5927\u4ed9 . Vietnamese \u00b6 FASTAPI: TRI\u1ec2N KHAI B\u1eb0NG DOCKER by Nguy\u1ec5n Nh\u00e2n . Russian \u00b6 \u041c\u0435\u043b\u043a\u0430\u044f \u043f\u0438\u0442\u043e\u043d\u044f\u0447\u0430\u044f \u0440\u0430\u0434\u043e\u0441\u0442\u044c #2: Starlette - \u0421\u043e\u043b\u0438\u0434\u043d\u0430\u044f \u043f\u0440\u0438\u043c\u043e\u0447\u043a\u0430 \u2013 FastAPI by Andrey Korchak . \u041f\u043e\u0447\u0435\u043c\u0443 \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c FastAPI? by prostomarkeloff . German \u00b6 Inbetriebnahme eines scikit-learn-Modells mit ONNX und FastAPI by Nico Axtmann . Podcasts \u00b6 FastAPI on PythonBytes by Python Bytes FM . Talks \u00b6 PyCon UK 2019: FastAPI from the ground up by Chris Withers . Projects \u00b6 Latest GitHub projects with the topic fastapi :","title":"External Links and Articles"},{"location":"external-links/#articles","text":"","title":"Articles"},{"location":"external-links/#english","text":"FastAPI/Starlette debug vs prod by William Hayes . FastAPI\u200a\u2014\u200aGoogle as an external authentication provider by Nils de Bruin . FastAPI\u200a\u2014\u200aHow to add basic and cookie authentication by Nils de Bruin . Introduction to the fastapi python framework by Errieta Kostala . FastAPI and Scikit-Learn: Easily Deploy Models by Nick Cortale . FastAPI authentication revisited: Enabling API key authentication by Nils de Bruin . FastAPI, a simple use case on logging by @euri10 . Deploying a scikit-learn model with ONNX and FastAPI by Nico Axtmann . Top 5 Asynchronous Web Frameworks for Python by Ankush Thakur on GeekFlare . JWT Authentication with FastAPI and AWS Cognito by Johannes Gontrum . How to Deploy a Machine Learning Model by Maarten Grootendorst on Towards Data Science . Uber: Ludwig v0.2 Adds New Features and Other Improvements to its Deep Learning Toolbox [including a FastAPI server] on Uber Engineering . A FastAPI and Swagger UI visual cheatsheet by @euri10 Using Docker Compose to deploy a lightweight Python REST API with a job queue by Mike Moritz . Setting up Tortoise ORM with FastAPI by Rob Wagner . Why I'm Leaving Flask by Dylan Anthony . How To Deploy Tensorflow 2.0 Models As An API Service With FastAPI & Docker by Bernard Brenyah . TestDriven.io: Developing and Testing an Asynchronous API with FastAPI and Pytest by Michael Herman . Towards Data Science: Deploying Iris Classifications with FastAPI and Docker by Mandy Gu . Deploy Machine Learning Models with Keras, FastAPI, Redis and Docker by Shane Soh . Another Boilerplate to FastAPI: Azure Pipeline CI + Pytest by Arthur Henrique . How to continuously deploy a FastAPI to AWS Lambda with AWS SAM by Benjamin Ramser . Create and Deploy FastAPI app to Heroku without using Docker by Navule Pavan Kumar Rao .","title":"English"},{"location":"external-links/#japanese","text":"FastAPI\uff5cDB\u63a5\u7d9a\u3057\u3066CRUD\u3059\u308bPython\u88fdAPI\u30b5\u30fc\u30d0\u30fc\u3092\u69cb\u7bc9 by @mtitg . python\u88fd\u306e\u6700\u65b0API\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI \u3092\u89e6\u3063\u3066\u307f\u305f by @ryoryomaru . FastAPI\u3067CORS\u3092\u56de\u907f by @angel_katayoku . FastAPI\u3092MySQL\u3068\u63a5\u7d9a\u3057\u3066Docker\u3067\u7ba1\u7406\u3057\u3066\u307f\u308b by @angel_katayoku . FastAPI\u3067POST\u3055\u308c\u305fJSON\u306e\u30ec\u30b9\u30dd\u30f3\u30b9body\u3092\u53d7\u3051\u53d6\u308b by @angel_katayoku . \u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u958b\u767a\u8005\u5411\u3051\u306eDocker\u306b\u3088\u308bPython\u958b\u767a\u74b0\u5883\u69cb\u7bc9 by Hikaru Takahashi . \u3010\u7b2c1\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: ToDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u74b0\u5883\u69cb\u7bc9\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c2\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: ToDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u30e2\u30c7\u30eb\u69cb\u7bc9\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c3\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: toDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u8a8d\u8a3c\u30fb\u30e6\u30fc\u30b6\u767b\u9332\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 \u3010\u7b2c4\u56de\u3011FastAPI\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb: toDo\u30a2\u30d7\u30ea\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3010\u7ba1\u7406\u8005\u30da\u30fc\u30b8\u6539\u826f\u7de8\u3011 by \u30e9\u30a4\u30c8\u30b3\u30fc\u30c9\u30e1\u30c7\u30a3\u30a2\u7de8\u96c6\u90e8 Python\u306eWeb framework\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u6bd4\u8f03 (Django, Flask, responder, FastAPI, japronto) by @bee2 . [FastAPI] Python\u88fd\u306eASGI Web \u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI\u306b\u5165\u9580\u3059\u308b by @bee2 .","title":"Japanese"},{"location":"external-links/#chinese","text":"\u4f7f\u7528FastAPI\u6846\u67b6\u5feb\u901f\u6784\u5efa\u9ad8\u6027\u80fd\u7684api\u670d\u52a1 by \u900d\u9065\u6563\u4eba . FastAPI\u6846\u67b6\u4e2d\u6587\u6587\u6863 by \u4f55\u5927\u4ed9 .","title":"Chinese"},{"location":"external-links/#vietnamese","text":"FASTAPI: TRI\u1ec2N KHAI B\u1eb0NG DOCKER by Nguy\u1ec5n Nh\u00e2n .","title":"Vietnamese"},{"location":"external-links/#russian","text":"\u041c\u0435\u043b\u043a\u0430\u044f \u043f\u0438\u0442\u043e\u043d\u044f\u0447\u0430\u044f \u0440\u0430\u0434\u043e\u0441\u0442\u044c #2: Starlette - \u0421\u043e\u043b\u0438\u0434\u043d\u0430\u044f \u043f\u0440\u0438\u043c\u043e\u0447\u043a\u0430 \u2013 FastAPI by Andrey Korchak . \u041f\u043e\u0447\u0435\u043c\u0443 \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c FastAPI? by prostomarkeloff .","title":"Russian"},{"location":"external-links/#german","text":"Inbetriebnahme eines scikit-learn-Modells mit ONNX und FastAPI by Nico Axtmann .","title":"German"},{"location":"external-links/#podcasts","text":"FastAPI on PythonBytes by Python Bytes FM .","title":"Podcasts"},{"location":"external-links/#talks","text":"PyCon UK 2019: FastAPI from the ground up by Chris Withers .","title":"Talks"},{"location":"external-links/#projects","text":"Latest GitHub projects with the topic fastapi :","title":"Projects"},{"location":"features/","text":"FastAPI features \u00b6 FastAPI gives you the following: Based on open standards \u00b6 OpenAPI for API creation, including declarations of path operations , parameters, body requests, security, etc. Automatic data model documentation with JSON Schema (as OpenAPI itself is based on JSON Schema). Designed around these standards, after a meticulous study. Instead of an afterthought layer on top. This also allows using automatic client code generation in many languages. Automatic docs \u00b6 Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default. Swagger UI , with interactive exploration, call and test your API directly from the browser. Alternative API documentation with ReDoc . Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial: Python Types . You write standard Python with types: from typing import List , Dict from datetime import date from pydantic import BaseModel # Declare a variable as a str # and get editor support inside the function def main ( user_id : str ): return user_id # A Pydantic model class User ( BaseModel ): id : int name : str joined : date That can then be used like: my_user : User = User ( id = 3 , name = \"John Doe\" , joined = \"2018-07-19\" ) second_user_data = { \"id\" : 4 , \"name\" : \"Mary\" , \"joined\" : \"2018-11-30\" , } my_second_user : User = User ( ** second_user_data ) Info **second_user_data means: Pass the keys and values of the second_user_data dict directly as key-value arguments, equivalent to: User(id=4, name=\"Mary\", joined=\"2018-11-30\") Editor support \u00b6 All the framework was designed to be easy and intuitive to use, all the decisions where tested on multiple editors even before starting development, to ensure the best development experience. In the last Python developer survey it was clear that the most used feature is \"autocompletion\" . The whole FastAPI framework is based to satisfy that. Autocompletion works everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion in code you might even consider impossible before. As for example, the price key inside a JSON body (that could have been nested) that comes from a request. No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used username or user_name . Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need. But by default, it all \"just works\" . Validation \u00b6 Validation for most (or all?) Python data types , including: JSON objects ( dict ). JSON array ( list ) defining item types. String ( str ) fields, defining min and max lengths. Numbers ( int , float ) with min and max values, etc. Validation for more exotic types, like: URL. Email. UUID. ...and others. All the validation is handled by the well-established and robust Pydantic . Security and authentication \u00b6 Security and authentication integrated. Without any compromise with databases or data models. All the security schemes defined in OpenAPI, including: HTTP Basic. OAuth2 (also with JWT tokens ). Check the tutorial on OAuth2 with JWT . API keys in: Headers. Query parameters. Cookies, etc. Plus all the security features from Starlette (including session cookies ). All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc. Dependency Injection \u00b6 FastAPI includes an extremely easy to use, but extremely powerful Dependency Injection system. Even dependencies can have dependencies, creating a hierarchy or \"graph\" of dependencies . All automatically handled by the framework. All the dependencies can require data from requests and augment the path operation constraints and automatic documentation. Automatic validation even for path operation parameters defined in dependencies. Support for complex user authentication systems, database connections , etc. No compromise with databases, frontends, etc. But easy integration with all of them. Unlimited \"plug-ins\" \u00b6 Or in other way, no need for them, import and use the code you need. Any integration is designed to be so simple to use (with dependencies) that you can create a \"plug-in\" for your application in 2 lines of code using the same structure and syntax used for your path operations . Tested \u00b6 100% test coverage . 100% type annotated code base. Used in production applications. Starlette features \u00b6 FastAPI is fully compatible with (and based on) Starlette . So, any additional Starlette code you have, will also work. FastAPI is actually a sub-class of Starlette . So, if you already know or use Starlette, most of the functionality will work the same way. With FastAPI you get all of Starlette 's features (as FastAPI is just Starlette on steroids): Seriously impressive performance. It is one of the fastest Python frameworks available, on par with NodeJS and Go . WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS , GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Pydantic features \u00b6 FastAPI is fully compatible with (and based on) Pydantic . So, any additional Pydantic code you have, will also work. Including external libraries also based on Pydantic, as ORM s, ODM s for databases. This also means that in many cases you can pass the same object you get from a request directly to the database , as everything is validated automatically. The same applies the other way around, in many cases you can just pass the object you get from the database directly to the client . With FastAPI you get all of Pydantic 's features (as FastAPI is based on Pydantic for all the data handling): No brainfuck : No new schema definition micro-language to learn. If you know Python types you know how to use Pydantic. Plays nicely with your IDE / linter /brain : Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data. Fast : in benchmarks Pydantic is faster than all other tested libraries. Validate complex structures : Use of hierarchical Pydantic models, Python typing \u2019s List and Dict , etc. And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema. You can have deeply nested JSON objects and have them all validated and annotated. Extendible : Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator. 100% test coverage.","title":"Features"},{"location":"features/#fastapi-features","text":"FastAPI gives you the following:","title":"FastAPI features"},{"location":"features/#based-on-open-standards","text":"OpenAPI for API creation, including declarations of path operations , parameters, body requests, security, etc. Automatic data model documentation with JSON Schema (as OpenAPI itself is based on JSON Schema). Designed around these standards, after a meticulous study. Instead of an afterthought layer on top. This also allows using automatic client code generation in many languages.","title":"Based on open standards"},{"location":"features/#automatic-docs","text":"Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default. Swagger UI , with interactive exploration, call and test your API directly from the browser. Alternative API documentation with ReDoc .","title":"Automatic docs"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial: Python Types . You write standard Python with types: from typing import List , Dict from datetime import date from pydantic import BaseModel # Declare a variable as a str # and get editor support inside the function def main ( user_id : str ): return user_id # A Pydantic model class User ( BaseModel ): id : int name : str joined : date That can then be used like: my_user : User = User ( id = 3 , name = \"John Doe\" , joined = \"2018-07-19\" ) second_user_data = { \"id\" : 4 , \"name\" : \"Mary\" , \"joined\" : \"2018-11-30\" , } my_second_user : User = User ( ** second_user_data ) Info **second_user_data means: Pass the keys and values of the second_user_data dict directly as key-value arguments, equivalent to: User(id=4, name=\"Mary\", joined=\"2018-11-30\")","title":"Just Modern Python"},{"location":"features/#editor-support","text":"All the framework was designed to be easy and intuitive to use, all the decisions where tested on multiple editors even before starting development, to ensure the best development experience. In the last Python developer survey it was clear that the most used feature is \"autocompletion\" . The whole FastAPI framework is based to satisfy that. Autocompletion works everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion in code you might even consider impossible before. As for example, the price key inside a JSON body (that could have been nested) that comes from a request. No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used username or user_name .","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#validation","text":"Validation for most (or all?) Python data types , including: JSON objects ( dict ). JSON array ( list ) defining item types. String ( str ) fields, defining min and max lengths. Numbers ( int , float ) with min and max values, etc. Validation for more exotic types, like: URL. Email. UUID. ...and others. All the validation is handled by the well-established and robust Pydantic .","title":"Validation"},{"location":"features/#security-and-authentication","text":"Security and authentication integrated. Without any compromise with databases or data models. All the security schemes defined in OpenAPI, including: HTTP Basic. OAuth2 (also with JWT tokens ). Check the tutorial on OAuth2 with JWT . API keys in: Headers. Query parameters. Cookies, etc. Plus all the security features from Starlette (including session cookies ). All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc.","title":"Security and authentication"},{"location":"features/#dependency-injection","text":"FastAPI includes an extremely easy to use, but extremely powerful Dependency Injection system. Even dependencies can have dependencies, creating a hierarchy or \"graph\" of dependencies . All automatically handled by the framework. All the dependencies can require data from requests and augment the path operation constraints and automatic documentation. Automatic validation even for path operation parameters defined in dependencies. Support for complex user authentication systems, database connections , etc. No compromise with databases, frontends, etc. But easy integration with all of them.","title":"Dependency Injection"},{"location":"features/#unlimited-plug-ins","text":"Or in other way, no need for them, import and use the code you need. Any integration is designed to be so simple to use (with dependencies) that you can create a \"plug-in\" for your application in 2 lines of code using the same structure and syntax used for your path operations .","title":"Unlimited \"plug-ins\""},{"location":"features/#tested","text":"100% test coverage . 100% type annotated code base. Used in production applications.","title":"Tested"},{"location":"features/#starlette-features","text":"FastAPI is fully compatible with (and based on) Starlette . So, any additional Starlette code you have, will also work. FastAPI is actually a sub-class of Starlette . So, if you already know or use Starlette, most of the functionality will work the same way. With FastAPI you get all of Starlette 's features (as FastAPI is just Starlette on steroids): Seriously impressive performance. It is one of the fastest Python frameworks available, on par with NodeJS and Go . WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS , GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase.","title":"Starlette features"},{"location":"features/#pydantic-features","text":"FastAPI is fully compatible with (and based on) Pydantic . So, any additional Pydantic code you have, will also work. Including external libraries also based on Pydantic, as ORM s, ODM s for databases. This also means that in many cases you can pass the same object you get from a request directly to the database , as everything is validated automatically. The same applies the other way around, in many cases you can just pass the object you get from the database directly to the client . With FastAPI you get all of Pydantic 's features (as FastAPI is based on Pydantic for all the data handling): No brainfuck : No new schema definition micro-language to learn. If you know Python types you know how to use Pydantic. Plays nicely with your IDE / linter /brain : Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data. Fast : in benchmarks Pydantic is faster than all other tested libraries. Validate complex structures : Use of hierarchical Pydantic models, Python typing \u2019s List and Dict , etc. And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema. You can have deeply nested JSON objects and have them all validated and annotated. Extendible : Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator. 100% test coverage.","title":"Pydantic features"},{"location":"help-fastapi/","text":"Do you like FastAPI ? Would you like to help FastAPI, other users, and the author? Or would you like to get help with FastAPI ? There are very simple ways to help (several involve just one or two clicks). And there are several ways to get help too. Star FastAPI in GitHub \u00b6 You can \"star\" FastAPI in GitHub (clicking the star button at the top right): https://github.com/tiangolo/fastapi . By adding a star, other users will be able to find it more easily and see that it has been already useful for others. Watch the GitHub repository for releases \u00b6 You can \"watch\" FastAPI in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/fastapi . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of FastAPI with bug fixes and new features. Join the chat \u00b6 Join the chat on Gitter: https://gitter.im/tiangolo/fastapi . There you can ask quick questions, help others, share ideas, etc. Connect with the author \u00b6 You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use FastAPI (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me) on Medium . Read other ideas, articles and tools I have created. Follow me to see when I publish something new. Tweet about FastAPI \u00b6 Tweet about FastAPI and let me and others know why you like it. Let me know how are you using FastAPI \u00b6 I love to hear about how FastAPI is being used, what have you liked in it, in which project/company are you using it, etc. You can let me know: On Twitter . On Linkedin . On Medium . Vote for FastAPI \u00b6 Vote to include FastAPI in awesome-python . Vote for FastAPI in Slant . Help others with issues in GitHub \u00b6 You can see existing issues and try and help others. Watch the GitHub repository \u00b6 You can \"watch\" FastAPI in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/fastapi . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues. Create issues \u00b6 You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question. Create a Pull Request \u00b6 You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Help FastAPI - Get Help"},{"location":"help-fastapi/#star-fastapi-in-github","text":"You can \"star\" FastAPI in GitHub (clicking the star button at the top right): https://github.com/tiangolo/fastapi . By adding a star, other users will be able to find it more easily and see that it has been already useful for others.","title":"Star FastAPI in GitHub"},{"location":"help-fastapi/#watch-the-github-repository-for-releases","text":"You can \"watch\" FastAPI in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/fastapi . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of FastAPI with bug fixes and new features.","title":"Watch the GitHub repository for releases"},{"location":"help-fastapi/#join-the-chat","text":"Join the chat on Gitter: https://gitter.im/tiangolo/fastapi . There you can ask quick questions, help others, share ideas, etc.","title":"Join the chat"},{"location":"help-fastapi/#connect-with-the-author","text":"You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use FastAPI (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me) on Medium . Read other ideas, articles and tools I have created. Follow me to see when I publish something new.","title":"Connect with the author"},{"location":"help-fastapi/#tweet-about-fastapi","text":"Tweet about FastAPI and let me and others know why you like it.","title":"Tweet about FastAPI"},{"location":"help-fastapi/#let-me-know-how-are-you-using-fastapi","text":"I love to hear about how FastAPI is being used, what have you liked in it, in which project/company are you using it, etc. You can let me know: On Twitter . On Linkedin . On Medium .","title":"Let me know how are you using FastAPI"},{"location":"help-fastapi/#vote-for-fastapi","text":"Vote to include FastAPI in awesome-python . Vote for FastAPI in Slant .","title":"Vote for FastAPI"},{"location":"help-fastapi/#help-others-with-issues-in-github","text":"You can see existing issues and try and help others.","title":"Help others with issues in GitHub"},{"location":"help-fastapi/#watch-the-github-repository","text":"You can \"watch\" FastAPI in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/fastapi . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues.","title":"Watch the GitHub repository"},{"location":"help-fastapi/#create-issues","text":"You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question.","title":"Create issues"},{"location":"help-fastapi/#create-a-pull-request","text":"You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Create a Pull Request"},{"location":"history-design-future/","text":"Some time ago, a FastAPI user asked : What\u2019s the history of this project? It seems to have come from nowhere to awesome in a few weeks [...] Here's a little bit of that history. Alternatives \u00b6 I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers. As part of that, I needed to investigate, test and use many alternatives. The history of FastAPI is in great part the history of its predecessors. As said in the section Alternatives : FastAPI wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation. I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools. But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints). Investigation \u00b6 By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with. For example, it was clear that ideally it should be based on standard Python type hints. Also, the best approach was to use already existing standards. So, before even starting to code FastAPI , I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences. Design \u00b6 Then I spent some time designing the developer \"API\" I wanted to have as a user (as a developer using FastAPI). I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors. By the last Python Developer Survey , that covers about 80% of the users. It means that FastAPI was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors. That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc. All in a way that provided the best development experience for all the developers. Requirements \u00b6 After testing several alternatives, I decided that I was going to use Pydantic for its advantages. Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors. During the development, I also contributed to Starlette , the other key requirement. Development \u00b6 By the time I started creating FastAPI itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh. Future \u00b6 By this point, it's already clear that FastAPI with its ideas is being useful for many people. It is being chosen over previous alternatives for suiting many use cases better. Many developers and teams already depend on FastAPI for their projects (including me and my team). But still, there are many improvements and features to come. FastAPI has a great future ahead. And your help is greatly appreciated.","title":"History, Design and Future"},{"location":"history-design-future/#alternatives","text":"I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers. As part of that, I needed to investigate, test and use many alternatives. The history of FastAPI is in great part the history of its predecessors. As said in the section Alternatives : FastAPI wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation. I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools. But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).","title":"Alternatives"},{"location":"history-design-future/#investigation","text":"By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with. For example, it was clear that ideally it should be based on standard Python type hints. Also, the best approach was to use already existing standards. So, before even starting to code FastAPI , I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences.","title":"Investigation"},{"location":"history-design-future/#design","text":"Then I spent some time designing the developer \"API\" I wanted to have as a user (as a developer using FastAPI). I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors. By the last Python Developer Survey , that covers about 80% of the users. It means that FastAPI was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors. That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc. All in a way that provided the best development experience for all the developers.","title":"Design"},{"location":"history-design-future/#requirements","text":"After testing several alternatives, I decided that I was going to use Pydantic for its advantages. Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors. During the development, I also contributed to Starlette , the other key requirement.","title":"Requirements"},{"location":"history-design-future/#development","text":"By the time I started creating FastAPI itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh.","title":"Development"},{"location":"history-design-future/#future","text":"By this point, it's already clear that FastAPI with its ideas is being useful for many people. It is being chosen over previous alternatives for suiting many use cases better. Many developers and teams already depend on FastAPI for their projects (including me and my team). But still, there are many improvements and features to come. FastAPI has a great future ahead. And your help is greatly appreciated.","title":"Future"},{"location":"project-generation/","text":"There is a project generator that you can use to get started, with a lot of the initial set up, security, database and first API endpoints already done for you. Full-Stack-FastAPI-PostgreSQL \u00b6 GitHub: https://github.com/tiangolo/full-stack-fastapi-postgresql Full-Stack-FastAPI-PostgreSQL Features \u00b6 Full Docker integration (Docker based). Docker Swarm Mode deployment. Docker Compose integration and optimization for local development Production ready Python web server using Uvicorn and Gunicorn. Python FastAPI backend: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI and JSON Schema . Many other features including automatic validation, serialization, interactive documentation, authentication with OAuth2 JWT tokens, etc. Secure password hashing by default. JWT token authentication. SQLAlchemy models (independent of Flask extensions, so they can be used with Celery workers directly). Basic starting models for users (modify and remove as you need). Alembic migrations. CORS (Cross Origin Resource Sharing). Celery worker that can import and use models and code from the rest of the backend selectively (you don't have to install the complete app in each worker). REST backend tests based on Pytest , integrated with Docker, so you can test the full API interaction, independent on the database. As it runs in Docker, it can build a new data store from scratch each time (so you can use ElasticSearch, MongoDB, CouchDB, or whatever you want, and just test that the API works). Easy Python integration with Jupyter Kernels for remote or in-Docker development with extensions like Atom Hydrogen or Visual Studio Code Jupyter. Vue frontend: Generated with Vue CLI. JWT Authentication handling. Login view. After login, main dashboard view. Main dashboard with user creation and edition. Self user edition. Vuex . Vue-router . Vuetify for beautiful material design components. TypeScript . Docker server based on Nginx (configured to play nicely with Vue-router). Docker multi-stage building, so you don't need to save or commit compiled code. Frontend tests ran at build time (can be disabled too). Made as modular as possible, so it works out of the box, but you can re-generate with Vue CLI or create it as you need, and re-use what you want. PGAdmin for PostgreSQL database, you can modify it to use PHPMyAdmin and MySQL easily. Flower for Celery jobs monitoring. Load balancing between frontend and backend with Traefik , so you can have both under the same domain, separated by path, but served by different containers. Traefik integration, including Let's Encrypt HTTPS certificates automatic generation. GitLab CI (continuous integration), including frontend and backend testing. Full-Stack-FastAPI-Couchbase \u00b6 GitHub: https://github.com/tiangolo/full-stack-fastapi-couchbase Full-Stack-FastAPI-Couchbase Features \u00b6 Full Docker integration (Docker based). Docker Swarm Mode deployment. Docker Compose integration and optimization for local development. Production ready Python web server using Uvicorn and Gunicorn. Python FastAPI backend: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : OpenAPI and JSON Schema . Many other features including automatic validation, serialization, interactive documentation, authentication with OAuth2 JWT tokens, etc. Secure password hashing by default. JWT token authentication. CORS (Cross Origin Resource Sharing). Celery worker that can import and use code from the rest of the backend selectively (you don't have to install the complete app in each worker). NoSQL Couchbase database that supports direct synchronization via Couchbase Sync Gateway for offline-first applications. Full Text Search integrated, using Couchbase. REST backend tests based on Pytest, integrated with Docker, so you can test the full API interaction, independent on the database. As it runs in Docker, it can build a new data store from scratch each time (so you can use ElasticSearch, MongoDB, or whatever you want, and just test that the API works). Easy Python integration with Jupyter Kernels for remote or in-Docker development with extensions like Atom Hydrogen or Visual Studio Code Jupyter. Email notifications for account creation and password recovery, compatible with: Mailgun SparkPost SendGrid ...any other provider that can generate standard SMTP credentials. Vue frontend: Generated with Vue CLI. JWT Authentication handling. Login view. After login, main dashboard view. Main dashboard with user creation and edition. Self user edition. Vuex . Vue-router . Vuetify for beautiful material design components. TypeScript . Docker server based on Nginx (configured to play nicely with Vue-router). Docker multi-stage building, so you don't need to save or commit compiled code. Frontend tests ran at build time (can be disabled too). Made as modular as possible, so it works out of the box, but you can re-generate with Vue CLI or create it as you need, and re-use what you want. Flower for Celery jobs monitoring. Load balancing between frontend and backend with Traefik , so you can have both under the same domain, separated by path, but served by different containers. Traefik integration, including Let's Encrypt HTTPS certificates automatic generation. GitLab CI (continuous integration), including frontend and backend testing.","title":"Project Generation - Template"},{"location":"project-generation/#full-stack-fastapi-postgresql","text":"GitHub: https://github.com/tiangolo/full-stack-fastapi-postgresql","title":"Full-Stack-FastAPI-PostgreSQL"},{"location":"project-generation/#full-stack-fastapi-postgresql-features","text":"Full Docker integration (Docker based). Docker Swarm Mode deployment. Docker Compose integration and optimization for local development Production ready Python web server using Uvicorn and Gunicorn. Python FastAPI backend: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI and JSON Schema . Many other features including automatic validation, serialization, interactive documentation, authentication with OAuth2 JWT tokens, etc. Secure password hashing by default. JWT token authentication. SQLAlchemy models (independent of Flask extensions, so they can be used with Celery workers directly). Basic starting models for users (modify and remove as you need). Alembic migrations. CORS (Cross Origin Resource Sharing). Celery worker that can import and use models and code from the rest of the backend selectively (you don't have to install the complete app in each worker). REST backend tests based on Pytest , integrated with Docker, so you can test the full API interaction, independent on the database. As it runs in Docker, it can build a new data store from scratch each time (so you can use ElasticSearch, MongoDB, CouchDB, or whatever you want, and just test that the API works). Easy Python integration with Jupyter Kernels for remote or in-Docker development with extensions like Atom Hydrogen or Visual Studio Code Jupyter. Vue frontend: Generated with Vue CLI. JWT Authentication handling. Login view. After login, main dashboard view. Main dashboard with user creation and edition. Self user edition. Vuex . Vue-router . Vuetify for beautiful material design components. TypeScript . Docker server based on Nginx (configured to play nicely with Vue-router). Docker multi-stage building, so you don't need to save or commit compiled code. Frontend tests ran at build time (can be disabled too). Made as modular as possible, so it works out of the box, but you can re-generate with Vue CLI or create it as you need, and re-use what you want. PGAdmin for PostgreSQL database, you can modify it to use PHPMyAdmin and MySQL easily. Flower for Celery jobs monitoring. Load balancing between frontend and backend with Traefik , so you can have both under the same domain, separated by path, but served by different containers. Traefik integration, including Let's Encrypt HTTPS certificates automatic generation. GitLab CI (continuous integration), including frontend and backend testing.","title":"Full-Stack-FastAPI-PostgreSQL Features"},{"location":"project-generation/#full-stack-fastapi-couchbase","text":"GitHub: https://github.com/tiangolo/full-stack-fastapi-couchbase","title":"Full-Stack-FastAPI-Couchbase"},{"location":"project-generation/#full-stack-fastapi-couchbase-features","text":"Full Docker integration (Docker based). Docker Swarm Mode deployment. Docker Compose integration and optimization for local development. Production ready Python web server using Uvicorn and Gunicorn. Python FastAPI backend: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : OpenAPI and JSON Schema . Many other features including automatic validation, serialization, interactive documentation, authentication with OAuth2 JWT tokens, etc. Secure password hashing by default. JWT token authentication. CORS (Cross Origin Resource Sharing). Celery worker that can import and use code from the rest of the backend selectively (you don't have to install the complete app in each worker). NoSQL Couchbase database that supports direct synchronization via Couchbase Sync Gateway for offline-first applications. Full Text Search integrated, using Couchbase. REST backend tests based on Pytest, integrated with Docker, so you can test the full API interaction, independent on the database. As it runs in Docker, it can build a new data store from scratch each time (so you can use ElasticSearch, MongoDB, or whatever you want, and just test that the API works). Easy Python integration with Jupyter Kernels for remote or in-Docker development with extensions like Atom Hydrogen or Visual Studio Code Jupyter. Email notifications for account creation and password recovery, compatible with: Mailgun SparkPost SendGrid ...any other provider that can generate standard SMTP credentials. Vue frontend: Generated with Vue CLI. JWT Authentication handling. Login view. After login, main dashboard view. Main dashboard with user creation and edition. Self user edition. Vuex . Vue-router . Vuetify for beautiful material design components. TypeScript . Docker server based on Nginx (configured to play nicely with Vue-router). Docker multi-stage building, so you don't need to save or commit compiled code. Frontend tests ran at build time (can be disabled too). Made as modular as possible, so it works out of the box, but you can re-generate with Vue CLI or create it as you need, and re-use what you want. Flower for Celery jobs monitoring. Load balancing between frontend and backend with Traefik , so you can have both under the same domain, separated by path, but served by different containers. Traefik integration, including Let's Encrypt HTTPS certificates automatic generation. GitLab CI (continuous integration), including frontend and backend testing.","title":"Full-Stack-FastAPI-Couchbase Features"},{"location":"python-types/","text":"Python 3.6+ has support for optional \"type hints\". These \"type hints\" are a new syntax (since Python 3.6+) that allow declaring the type of a variable. By declaring types for your variables, editors and tools can give you better support. This is just a quick tutorial / refresher about Python type hints. It covers only the minimum necessary to use them with FastAPI ... which is actually very little. FastAPI is all based on these type hints, they give it many advantages and benefits. But even if you never use FastAPI , you would benefit from learning a bit about them. Note If you are a Python expert, and you already know everything about type hints, skip to the next chapter. Motivation \u00b6 Let's start with a simple example: def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Calling this program outputs: John Doe The function does the following: Takes a first_name and last_name . Converts the first letter of each one to upper case with title() . Concatenates them with a space in the middle. def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Edit it \u00b6 It's a very simple program. But now imagine that you were writing it from scratch. At some point you would have started the definition of the function, you had the parameters ready... But then you have to call \"that method that converts the first letter to upper case\". Was it upper ? Was it uppercase ? first_uppercase ? capitalize ? Then, you try with the old programmer's friend, editor autocompletion. You type the first parameter of the function, first_name , then a dot ( . ) and then hit Ctrl+Space to trigger the completion. But, sadly, you get nothing useful: Add types \u00b6 Let's modify a single line from the previous version. We will change exactly this fragment, the parameters of the function, from: first_name , last_name to: first_name : str , last_name : str That's it. Those are the \"type hints\": def get_full_name ( first_name : str , last_name : str ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) That is not the same as declaring default values like would be with: first_name = \"john\" , last_name = \"doe\" It's a different thing. We are using colons ( : ), not equals ( = ). And adding type hints normally doesn't change what happens from what would happen without them. But now, imagine you are again in the middle of creating that function, but with type hints. At the same point, you try to trigger the autocomplete with Ctrl+Space and you see: With that, you can scroll, seeing the options, until you find the one that \"rings a bell\": More motivation \u00b6 Check this function, it already has type hints: def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + age return name_with_age Because the editor knows the types of the variables, you don't only get completion, you also get error checks: Now you know that you have to fix it, convert age to a string with str(age) : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + str ( age ) return name_with_age Declaring types \u00b6 You just saw the main place to declare type hints. As function parameters. This is also the main place you would use them with FastAPI . Simple types \u00b6 You can declare all the standard Python types, not only str . You can use, for example: int float bool bytes def get_items ( item_a : str , item_b : int , item_c : float , item_d : bool , item_e : bytes ): return item_a , item_b , item_c , item_d , item_d , item_e Types with subtypes \u00b6 There are some data structures that can contain other values, like dict , list , set and tuple . And the internal values can have their own type too. To declare those types and the subtypes, you can use the standard Python module typing . It exists specifically to support these type hints. Lists \u00b6 For example, let's define a variable to be a list of str . From typing , import List (with a capital L ): from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) Declare the variable, with the same colon ( : ) syntax. As the type, put the List . As the list is a type that takes a \"subtype\", you put the subtype in square brackets: from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) That means: \"the variable items is a list , and each of the items in this list is a str \". By doing that, your editor can provide support even while processing items from the list. Without types, that's almost impossible to achieve: Notice that the variable item is one of the elements in the list items . And still, the editor knows it is a str , and provides support for that. Tuples and Sets \u00b6 You would do the same to declare tuple s and set s: from typing import Set , Tuple def process_items ( items_t : Tuple [ int ], items_s : Set [ bytes ]): return items_t , items_s This means: The variable items_t is a tuple , and each of its items is an int . The variable items_s is a set , and each of its items is of type bytes . Dicts \u00b6 To define a dict , you pass 2 subtypes, separated by commas. The first subtype is for the keys of the dict . The second subtype is for the values of the dict : from typing import Dict def process_items ( prices : Dict [ str , float ]): for item_name , item_price in prices . items (): print ( item_name ) print ( item_price ) This means: The variable prices is a dict : The keys of this dict are of type str (let's say, the name of each item). The values of this dict are of type float (let's say, the price of each item). Classes as types \u00b6 You can also declare a class as the type of a variable. Let's say you have a class Person , with a name: class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Then you can declare a variable to be of type Person : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name And then, again, you get all the editor support: Pydantic models \u00b6 Pydantic is a Python library to perform data validation. You declare the \"shape\" of the data as classes with attributes. And each attribute has a type. Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data. And you get all the editor support with that resulting object. Taken from the official Pydantic docs: from datetime import datetime from typing import List from pydantic import BaseModel class User ( BaseModel ): id : int name = \"John Doe\" signup_ts : datetime = None friends : List [ int ] = [] external_data = { \"id\" : \"123\" , \"signup_ts\" : \"2017-06-01 12:22\" , \"friends\" : [ 1 , \"2\" , b \"3\" ], } user = User ( ** external_data ) print ( user ) # > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3] print ( user . id ) # > 123 Info To learn more about Pydantic, check its docs . FastAPI is all based on Pydantic. You will see a lot more of all this in practice in the Tutorial - User Guide . Type hints in FastAPI \u00b6 FastAPI takes advantage of these type hints to do several things. With FastAPI you declare parameters with type hints and you get: Editor support . Type checks . ...and FastAPI uses the same declarations to: Define requirements : from request path parameters, query parameters, headers, bodies, dependencies, etc. Convert data : from the request to the required type. Validate data : coming from each request: Generating automatic errors returned to the client when the data is invalid. Document the API using OpenAPI: which is then used by the automatic interactive documentation user interfaces. This might all sound abstract. Don't worry. You'll see all this in action in the Tutorial - User Guide . The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc), FastAPI will do a lot of the work for you. Info If you already went through all the tutorial and came back to see more about types, a good resource is the \"cheat sheet\" from mypy .","title":"Python types intro"},{"location":"python-types/#motivation","text":"Let's start with a simple example: def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Calling this program outputs: John Doe The function does the following: Takes a first_name and last_name . Converts the first letter of each one to upper case with title() . Concatenates them with a space in the middle. def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" ))","title":"Motivation"},{"location":"python-types/#edit-it","text":"It's a very simple program. But now imagine that you were writing it from scratch. At some point you would have started the definition of the function, you had the parameters ready... But then you have to call \"that method that converts the first letter to upper case\". Was it upper ? Was it uppercase ? first_uppercase ? capitalize ? Then, you try with the old programmer's friend, editor autocompletion. You type the first parameter of the function, first_name , then a dot ( . ) and then hit Ctrl+Space to trigger the completion. But, sadly, you get nothing useful:","title":"Edit it"},{"location":"python-types/#add-types","text":"Let's modify a single line from the previous version. We will change exactly this fragment, the parameters of the function, from: first_name , last_name to: first_name : str , last_name : str That's it. Those are the \"type hints\": def get_full_name ( first_name : str , last_name : str ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) That is not the same as declaring default values like would be with: first_name = \"john\" , last_name = \"doe\" It's a different thing. We are using colons ( : ), not equals ( = ). And adding type hints normally doesn't change what happens from what would happen without them. But now, imagine you are again in the middle of creating that function, but with type hints. At the same point, you try to trigger the autocomplete with Ctrl+Space and you see: With that, you can scroll, seeing the options, until you find the one that \"rings a bell\":","title":"Add types"},{"location":"python-types/#more-motivation","text":"Check this function, it already has type hints: def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + age return name_with_age Because the editor knows the types of the variables, you don't only get completion, you also get error checks: Now you know that you have to fix it, convert age to a string with str(age) : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + str ( age ) return name_with_age","title":"More motivation"},{"location":"python-types/#declaring-types","text":"You just saw the main place to declare type hints. As function parameters. This is also the main place you would use them with FastAPI .","title":"Declaring types"},{"location":"python-types/#simple-types","text":"You can declare all the standard Python types, not only str . You can use, for example: int float bool bytes def get_items ( item_a : str , item_b : int , item_c : float , item_d : bool , item_e : bytes ): return item_a , item_b , item_c , item_d , item_d , item_e","title":"Simple types"},{"location":"python-types/#types-with-subtypes","text":"There are some data structures that can contain other values, like dict , list , set and tuple . And the internal values can have their own type too. To declare those types and the subtypes, you can use the standard Python module typing . It exists specifically to support these type hints.","title":"Types with subtypes"},{"location":"python-types/#lists","text":"For example, let's define a variable to be a list of str . From typing , import List (with a capital L ): from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) Declare the variable, with the same colon ( : ) syntax. As the type, put the List . As the list is a type that takes a \"subtype\", you put the subtype in square brackets: from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) That means: \"the variable items is a list , and each of the items in this list is a str \". By doing that, your editor can provide support even while processing items from the list. Without types, that's almost impossible to achieve: Notice that the variable item is one of the elements in the list items . And still, the editor knows it is a str , and provides support for that.","title":"Lists"},{"location":"python-types/#tuples-and-sets","text":"You would do the same to declare tuple s and set s: from typing import Set , Tuple def process_items ( items_t : Tuple [ int ], items_s : Set [ bytes ]): return items_t , items_s This means: The variable items_t is a tuple , and each of its items is an int . The variable items_s is a set , and each of its items is of type bytes .","title":"Tuples and Sets"},{"location":"python-types/#dicts","text":"To define a dict , you pass 2 subtypes, separated by commas. The first subtype is for the keys of the dict . The second subtype is for the values of the dict : from typing import Dict def process_items ( prices : Dict [ str , float ]): for item_name , item_price in prices . items (): print ( item_name ) print ( item_price ) This means: The variable prices is a dict : The keys of this dict are of type str (let's say, the name of each item). The values of this dict are of type float (let's say, the price of each item).","title":"Dicts"},{"location":"python-types/#classes-as-types","text":"You can also declare a class as the type of a variable. Let's say you have a class Person , with a name: class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Then you can declare a variable to be of type Person : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name And then, again, you get all the editor support:","title":"Classes as types"},{"location":"python-types/#pydantic-models","text":"Pydantic is a Python library to perform data validation. You declare the \"shape\" of the data as classes with attributes. And each attribute has a type. Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data. And you get all the editor support with that resulting object. Taken from the official Pydantic docs: from datetime import datetime from typing import List from pydantic import BaseModel class User ( BaseModel ): id : int name = \"John Doe\" signup_ts : datetime = None friends : List [ int ] = [] external_data = { \"id\" : \"123\" , \"signup_ts\" : \"2017-06-01 12:22\" , \"friends\" : [ 1 , \"2\" , b \"3\" ], } user = User ( ** external_data ) print ( user ) # > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3] print ( user . id ) # > 123 Info To learn more about Pydantic, check its docs . FastAPI is all based on Pydantic. You will see a lot more of all this in practice in the Tutorial - User Guide .","title":"Pydantic models"},{"location":"python-types/#type-hints-in-fastapi","text":"FastAPI takes advantage of these type hints to do several things. With FastAPI you declare parameters with type hints and you get: Editor support . Type checks . ...and FastAPI uses the same declarations to: Define requirements : from request path parameters, query parameters, headers, bodies, dependencies, etc. Convert data : from the request to the required type. Validate data : coming from each request: Generating automatic errors returned to the client when the data is invalid. Document the API using OpenAPI: which is then used by the automatic interactive documentation user interfaces. This might all sound abstract. Don't worry. You'll see all this in action in the Tutorial - User Guide . The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc), FastAPI will do a lot of the work for you. Info If you already went through all the tutorial and came back to see more about types, a good resource is the \"cheat sheet\" from mypy .","title":"Type hints in FastAPI"},{"location":"release-notes/","text":"Latest changes \u00b6 0.49.0 \u00b6 Fix encoding of pathlib paths in jsonable_encoder . PR #978 by @patrickmckenna . Add articles to External Links : Python\u306eWeb framework\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u6bd4\u8f03 (Django, Flask, responder, FastAPI, japronto) and [FastAPI] Python\u88fd\u306eASGI Web \u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI\u306b\u5165\u9580\u3059\u308b . PR #974 by @tokusumi . Fix broken links in docs. PR #949 by @tsotnikov . Fix small typos. PR #941 by @NikitaKolesov . Update and clarify docs for dependencies with yield . PR #986 . Add Mermaid JS support for diagrams in docs. Add first diagrams to Dependencies: First Steps and Dependencies with yield and HTTPException . PR #985 . Update CI to run docs deployment in GitHub actions. PR #983 . Allow callable s in path operation functions , like functions modified with functools.partial . PR #977 . 0.48.0 \u00b6 Run linters first in tests to error out faster. PR #948 . Log warning about email-validator only when used. PR #946 . Simplify Peewee docs with double dependency with yield . PR #947 . Add article External Links : Create and Deploy FastAPI app to Heroku . PR #942 by @windson . Update description of Sanic, as it is now ASGI too. PR #932 by @raphaelauv . Fix typo in main page. PR #920 by @mMarzeta . Fix parsing of possibly invalid bodies. PR #918 by @dmontagu . Fix typo #916 by @adursun . Allow Any type for enums in OpenAPI. PR #906 by @songzhi . Add article to External Links : How to continuously deploy a FastAPI to AWS Lambda with AWS SAM . PR #901 by @iwpnd . Add note about using Body parameters without Pydantic. PR #900 by @pawamoy . Fix Pydantic field clone logic. PR #899 by @deuce2367 . Fix link in middleware docs. PR #893 by @linchiwei123 . Rename default API title from \"Fast API\" to \"FastAPI\" for consistency. PR #890 . 0.47.1 \u00b6 Fix model filtering in response_model , cloning sub-models. PR #889 . Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR #888 . 0.47.0 \u00b6 Refactor documentation to make a simpler and shorter Tutorial - User Guide and an additional Advanced User Guide with all the additional docs. PR #887 . Tweak external links, Markdown format, typos. PR #881 . Fix bug in tutorial handling HTTP Basic Auth username and password . PR #865 by @isaevpd . Fix handling form path operation parameters declared with pure classes like list , tuple , etc. PR #856 by @nsidnev . Add request body to RequestValidationError , new docs: Use the RequestValidationError body . Initial PR #853 by @aviramha . Update External Links with new links and dynamic GitHub projects with fastapi topic. PR #850 . Fix Peewee contextvars handling in docs: SQL (Relational) Databases with Peewee . PR #879 . Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs: Development - Contributing . PR #877 . Update docs for HTTP Basic Auth to improve security against timing attacks. Initial PR #807 by @zwass . 0.46.0 \u00b6 Fix typos and tweak configs. PR #837 . Add link to Chinese article in External Links . PR 810 by @wxq0309 . Implement OAuth2AuthorizationCodeBearer class. PR #797 by @kuwv . Update example upgrade in docs main page. PR #795 by @cdeil . Fix callback handling for sub-routers. PR #792 by @jekirl . Fix typos. PR #784 by @kkinder . Add 4 Japanese articles to External Links . PR #783 by @HymanZHAN . Add support for subtypes of main types in jsonable_encoder , e.g. asyncpg's UUIDs. PR #756 by @RmStorm . Fix usage of Pydantic's HttpUrl in docs. PR #832 by @Dustyposa . Fix Twitter links in docs. PR #813 by @justindujardin . Add docs for correctly using FastAPI with Peewee ORM . Including how to overwrite parts of Peewee to correctly handle async threads. PR #789 . 0.45.0 \u00b6 Add support for OpenAPI Callbacks: New docs: OpenAPI Callbacks . Refactor generation of operationId s to be valid Python names (also valid variables in most languages). Add default_response_class parameter to APIRouter . Original PR #722 by @booooh . Refactor logging to use the same logger everywhere, update log strings and levels. PR #781 . Add article to External Links : \u041f\u043e\u0447\u0435\u043c\u0443 \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c FastAPI? . PR #766 by @prostomarkeloff . Remove gender bias in docs for handling errors. PR #780 . Original idea in PR #761 by @classywhetten . Rename docs and references to body-schema to body-fields to keep in line with Pydantic. PR #746 by @prostomarkeloff . 0.44.1 \u00b6 Add GitHub social preview images to git. PR #752 . Update PyPI \"trove classifiers\". PR #751 . Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR 749 . Update \"new issue\" templates. PR #749 . Fix serialization of errors for exotic Pydantic types. PR #748 by @dmontagu . 0.44.0 \u00b6 Add GitHub action Issue Manager . PR #742 . Fix typos in docs. PR 734 by @bundabrg . Fix usage of custom_encoder in jsonable_encoder . PR #715 by @matrixise . Fix invalid XML example. PR 710 by @OcasoProtal . Fix typos and update wording in deployment docs. PR #700 by @marier-nico . Add note about dependencies in APIRouter docs. PR #698 by @marier-nico . Add support for async class methods as dependencies #681 by @frankie567 . Add FastAPI with Swagger UI cheatsheet to external links. PR #671 by @euri10 . Fix typo in HTTP protocol in CORS example. PR #647 by @forestmonster . Add support for Pydantic versions 1.0.0 and above, with temporary (deprecated) backwards compatibility for Pydantic 0.32.2 . PR #646 by @dmontagu . 0.43.0 \u00b6 Update docs to reduce gender bias. PR #645 by @ticosax . Add docs about overriding the operationId for all the path operations based on their function name. PR #642 by @SKalt . Fix validators in models generating an incorrect key order. PR #637 by @jaddison . Generate correct OpenAPI docs for responses with no content. PR #621 by @brotskydotcom . Remove $ from Bash code blocks in docs for consistency. PR #613 by @nstapelbroek . Add docs for self-serving docs' (Swagger UI) static assets , e.g. to use the docs offline, or without Internet. Initial PR #557 by @svalouch . Fix black linting after upgrade. PR #682 by @frankie567 . 0.42.0 \u00b6 Add dependencies with yield , a.k.a. exit steps, context managers, cleanup, teardown, ... This allows adding extra code after a dependency is done. It can be used, for example, to close database connections. Dependencies with yield can be normal or async , FastAPI will run normal dependencies in a threadpool. They can be combined with normal dependencies. It's possible to have arbitrary trees/levels of dependencies with yield and exit steps are handled in the correct order automatically. It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies: async-exit-stack async-generator New docs at Dependencies with yield . Updated database docs SQL (Relational) Databases: Main FastAPI app . PR #595 . Fix sitemap.xml in website. PR #598 by @samuelcolvin . 0.41.0 \u00b6 Upgrade required Starlette to 0.12.9 , the new range is >=0.12.9,<=0.12.9 . Add State to FastAPI apps at app.state . PR #593 . Improve handling of custom classes for Request s and APIRoute s. This helps to more easily solve use cases like: Reading a body before and/or after a request (equivalent to a middleware). Run middleware-like code only for a subset of path operations . Process a request before passing it to a path operation function . E.g. decompressing, deserializing, etc. Processing a response after being generated by path operation functions but before returning it. E.g. adding custom headers, logging, adding extra metadata. New docs section: Custom Request and APIRoute class . PR #589 by @dmontagu . Fix preserving custom route class in routers when including other sub-routers. PR #538 by @dmontagu . 0.40.0 \u00b6 Add notes to docs about installing python-multipart when using forms. PR #574 by @sliptonic . Generate OpenAPI schemas in alphabetical order. PR #554 by @dmontagu . Add support for truncating docstrings from path operation functions . New docs at Advanced description from docstring . PR #556 by @svalouch . Fix DOCTYPE in HTML files generated for Swagger UI and ReDoc. PR #537 by @Trim21 . Fix handling 4XX responses overriding default 422 validation error responses. PR #517 by @tsouvarev . Fix typo in documentation for Simple HTTP Basic Auth . PR #514 by @prostomarkeloff . Fix incorrect documentation example in first steps . PR #511 by @IgnatovFedor . Add support for Swagger UI initOauth settings with the parameter swagger_ui_init_oauth . PR #499 by @zamiramir . 0.39.0 \u00b6 Allow path parameters to have default values (e.g. None ) and discard them instead of raising an error. This allows declaring a parameter like user_id: str = None that can be taken from a query parameter, but the same path operation can be included in a router with a path /users/{user_id} , in which case will be taken from the path and will be required. PR #464 by @jonathanunderwood . Add support for setting a default_response_class in the FastAPI instance or in include_router . Initial PR #467 by @toppk . Add support for type annotations using strings and from __future__ import annotations . PR #451 by @dmontagu . 0.38.1 \u00b6 Fix incorrect Request class import. PR #493 by @kamalgill . 0.38.0 \u00b6 Add recent articles to External Links and recent opinions. PR #490 . Upgrade support range for Starlette to include 0.12.8 . The new range is >=0.11.1,<=0.12.8\" . PR #477 by @dmontagu . Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR #463 by @dmontagu . 0.37.0 \u00b6 Add support for custom route classes for advanced use cases. PR #468 by @dmontagu . Allow disabling Google fonts in ReDoc. PR #481 by @b1-luettje . Fix security issue: when returning a sub-class of a response model and using skip_defaults it could leak information. PR #485 by @dmontagu . Enable tests for Python 3.8-dev. PR #465 by @Jamim . Add support and tests for Pydantic dataclasses in response_model . PR #454 by @dconathan . Fix typo in OAuth2 JWT tutorial. PR #447 by @pablogamboa . Use the media_type parameter in Body() params to set the media type in OpenAPI for requestBody . PR #439 by @divums . Add article Deploying a scikit-learn model with ONNX and FastAPI by https://www.linkedin.com/in/nico-axtmann . PR #438 by @naxty . Allow setting custom 422 (validation error) response/schema in OpenAPI. And use media type from response class instead of fixed application/json (the default). PR #437 by @divums . Fix using \"default\" extra response with status codes at the same time. PR #489 . Allow additional responses to use status code ranges (like 5XX and 4XX ) and \"default\" . PR #435 by @divums . 0.36.0 \u00b6 Fix implementation for skip_defaults when returning a Pydantic model. PR #422 by @dmontagu . Fix OpenAPI generation when using the same dependency in multiple places for the same path operation . PR #417 by @dmontagu . Allow having empty paths in path operations used with include_router and a prefix . This allows having a router for /cats and all its path operations , while having one of them for /cats . Now it doesn't have to be only /cats/ (with a trailing slash). To use it, declare the path in the path operation as the empty string ( \"\" ). PR #415 by @vitalik . Fix mypy error after merging PR #415. PR #462 . 0.35.0 \u00b6 Fix typo in routing assert . PR #419 by @pablogamboa . Fix typo in docs. PR #411 by @bronsen . Fix parsing a body type declared with Union . PR #400 by @koxudaxi . 0.34.0 \u00b6 Upgrade Starlette supported range to include the latest 0.12.7 . The new range is 0.11.1,<=0.12.7 . PR #367 by @dedsm . Add test for OpenAPI schema with duplicate models from PR #333 by @dmontagu . PR #385 . 0.33.0 \u00b6 Upgrade Pydantic version to 0.30.0 . PR #384 by @jekirl . 0.32.0 \u00b6 Fix typo in docs for features. PR #380 by @MartinoMensio . Fix source code limit for example in Query Parameters . PR #366 by @Smashman . Update wording in docs about OAuth2 scopes . PR #371 by @cjw296 . Update docs for Enum s to inherit from str and improve Swagger UI rendering. PR #351 . Fix regression, add Swagger UI deep linking again. PR #350 . Add test for having path templates in prefix of .include_router . PR #349 . Add note to docs: Include the same router multiple times with different prefix . PR #348 . Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies. Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules. The same new ID generation applies to response models. This also changes the generated title for those models. Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file). This also adds the possibility of using .include_router() with the same APIRouter multiple times, with different prefixes, e.g. /api/v2 and /api/latest , and it will now work correctly. PR #347 . 0.31.0 \u00b6 Upgrade Pydantic supported version to 0.29.0 . New supported version range is \"pydantic >=0.28,<=0.29.0\" . This adds support for Pydantic Generic Models , kudos to @dmontagu . PR #344 . 0.30.1 \u00b6 Add section in docs about External Links and Articles . PR #341 . Remove Pipfile.lock from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR #340 . Update section about Help FastAPI - Get Help . PR #339 . Refine internal type declarations to improve/remove Mypy errors in users' code. PR #338 . Update and clarify SQL tutorial with SQLAlchemy . PR #331 by @mariacamilagl . Add SQLite online viewers to the docs . PR #330 by @cyrilbois . 0.30.0 \u00b6 Add support for Pydantic's ORM mode: Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs: SQL (Relational) Databases . The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using @property decorators) and several other use cases. This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other. If your path operations return an arbitrary object with attributes (e.g. my_item.name instead of my_item[\"name\"] ) AND you use a response_model , make sure to update the Pydantic models with orm_mode = True as described in the docs (link above). New documentation about receiving plain dict s as request bodies: Bodies of arbitrary dict s . New documentation about returning arbitrary dict s in responses: Response with arbitrary dict . Technical Details : When declaring a response_model it is used directly to generate the response content, from whatever was returned from the path operation function . Before this, the return content was first passed through jsonable_encoder to ensure it was a \"jsonable\" object, like a dict , instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use orm_mode = True . If you don't have a response_model , the return object will still be passed through jsonable_encoder first. When a response_model is declared, the same response_model type declaration won't be used as is, it will be \"cloned\" to create an new one (a cloned Pydantic Field with all the submodels cloned as well). This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the response_model (e.g. you return a UserInDB that inherits from User but contains extra fields, like hashed_password , and User is used in the response_model ), it would still pass the validation (because UserInDB is a subclass of User ) and the object would be returned as-is, including the hashed_password . To fix this, the declared response_model is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a List[Item] ), the Pydantic model class(es) will be a different one (the \"cloned\" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned response_model . Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned response_model , containing only the declared fields as normally. PR #322 . Remove/clean unused RegEx code in routing. PR #314 by @dmontagu . Use default response status code descriptions for additional responses. PR #313 by @duxiaoyao . Upgrade Pydantic support to 0.28 . PR #320 by @jekirl . 0.29.1 \u00b6 Fix handling an empty-body request with a required body param. PR #311 . Fix broken link in docs: Return a Response directly . PR #306 by @dmontagu . Fix docs discrepancy in docs for Response Model . PR #288 by @awiddersheim . 0.29.0 \u00b6 Add support for declaring a Response parameter: This allows declaring: Response Cookies . Response Headers . An HTTP Status Code different than the default: Response - Change Status Code . All of this while still being able to return arbitrary objects ( dict , DB model, etc). Update attribution to Hug, for inspiring the response parameter pattern. PR #294 . 0.28.0 \u00b6 Implement dependency cache per request. This avoids calling each dependency multiple times for the same request. This is useful while calling external services, performing costly computation, etc. This also means that if a dependency was declared as a path operation decorator dependency, possibly at the router level (with .include_router() ) and then it is declared again in a specific path operation , the dependency will be called only once. The cache can be disabled per dependency declaration, using use_cache=False as in Depends(your_dependency, use_cache=False) . Updated docs at: Using the same dependency multiple times . PR #292 . Implement dependency overrides for testing. This allows using overrides/mocks of dependencies during tests. New docs: Testing Dependencies with Overrides . PR #291 . 0.27.2 \u00b6 Fix path and query parameters receiving dict as a valid type. It should be mapped to a body payload. PR #287 . Updated docs at: Query parameter list / multiple values with defaults: Using list . 0.27.1 \u00b6 Fix auto_error=False handling in HTTPBearer security scheme. Do not raise when there's an incorrect Authorization header if auto_error=False . PR #282 . Fix type declaration of HTTPException . PR #279 . 0.27.0 \u00b6 Fix broken link in docs about OAuth 2.0 with scopes. PR #275 by @dmontagu . Refactor param extraction using Pydantic Field : Large refactor, improvement, and simplification of param extraction from path operations . Fix/add support for list query parameters with list defaults. New documentation: Query parameter list / multiple values with defaults . Add support for enumerations in path operation parameters. New documentation: Path Parameters: Predefined values . Add support for type annotations using Optional as in param: Optional[str] = None . New documentation: Optional type declarations . PR #278 . 0.26.0 \u00b6 Separate error handling for validation errors. This will allow developers to customize the exception handlers. Document better how to handle exceptions and use error handlers. Include RequestValidationError and WebSocketRequestValidationError (this last one will be useful once encode/starlette#527 or equivalent is merged). New documentation about exceptions handlers: Install custom exception handlers . Override the default exception handlers . Re-use FastAPI's exception handlers . PR #273 . Fix support for paths in path parameters without needing explicit Path(...) . PR #256 . Documented in PR #272 by @wshayes . New documentation at: Path Parameters containing paths . Update docs for testing FastAPI. Include using POST , sending JSON, testing headers, etc. New documentation: Testing . PR #271 . Fix type declaration of response_model to allow generic Python types as List[Model] . Mainly to fix mypy for users. PR #266 . 0.25.0 \u00b6 Add support for Pydantic's include , exclude , by_alias . Update documentation: Response Model . Add docs for: Body - updates , using Pydantic's skip_defaults . Add method consistency tests. PR #264 . Add CONTRIBUTING.md file to GitHub, to help new contributors. PR #255 by @wshayes . Add support for Pydantic's skip_defaults : There's a new path operation decorator parameter response_model_skip_defaults . The name of the parameter will most probably change in a future version to response_skip_defaults , model_skip_defaults or something similar. New documentation section about using response_model_skip_defaults . PR #248 by @wshayes . 0.24.0 \u00b6 Add support for WebSockets with dependencies and parameters. Support included for: Depends Security Cookie Header Path Query ...as these are compatible with the WebSockets protocol (e.g. Body is not). Updated documentation for WebSockets . PR #178 by @jekirl . Upgrade the compatible version of Pydantic to 0.26.0 . This includes JSON Schema support for IP address and network objects, bug fixes, and other features. PR #247 by @euri10 . 0.23.0 \u00b6 Upgrade the compatible version of Starlette to 0.12.0 . This includes support for ASGI 3 (the latest version of the standard). It's now possible to use Starlette's StreamingResponse with iterators, like file-like objects (as those returned by open() ). It's now possible to use the low level utility iterate_in_threadpool from starlette.concurrency (for advanced scenarios). PR #243 . Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add {your_origin}/docs/oauth2-redirect to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc). For example, during development, it could be http://localhost:8000/docs/oauth2-redirect . Have in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at https://yourdomain.com/login/callback . This is only to allow delegated authentication in the API docs with Swagger UI. PR #198 by @steinitzu . Make Swagger UI and ReDoc route handlers ( path operations ) be async functions instead of lambdas to improve performance. PR #241 by @Trim21 . Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR #112 by @euri10 . 0.22.0 \u00b6 Add support for dependencies parameter: A parameter in path operation decorators , for dependencies that should be executed but the return value is not important or not used in the path operation function . A parameter in the .include_router() method of FastAPI applications and routers, to include dependencies that should be executed in each path operation in a router. This is useful, for example, to require authentication or permissions in specific group of path operations . Different dependencies can be applied to different routers. These dependencies are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined. Dependencies declared in a router are executed first, then the ones defined in path operation decorators , and then the ones declared in normal parameters. They are all combined and executed. All this also supports using Security with scopes in those dependencies parameters, for more advanced OAuth 2.0 security scenarios with scopes. New documentation about dependencies in path operation decorators . New documentation about dependencies in the include_router() method . PR #235 . Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using path convertors, to take a whole path as a parameter, like /some/url/{p:path} . PR #234 by @euri10 . Make default parameter utilities exported from fastapi be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix mypy errors in FastAPI's users' code. Applies to Path , Query , Header , Cookie , Body , Form , File , Depends , and Security . PR #226 and PR #231 . Separate development scripts test.sh , lint.sh , and format.sh . PR #232 . Re-enable black formatting checks for Python 3.7. PR #229 by @zamiramir . 0.21.0 \u00b6 On body parsing errors, raise from previous exception, to allow better introspection in logging code. PR #192 by @ricardomomm . Use Python logger named \" fastapi \" instead of root logger. PR #222 by @euri10 . Upgrade Pydantic to version 0.25. PR #225 by @euri10 . Fix typo in routing. PR #221 by @djlambert . 0.20.1 \u00b6 Add typing information to package including file py.typed . PR #209 by @meadsteve . Add FastAPI bot for Gitter. To automatically announce new releases. PR #189 . 0.20.0 \u00b6 Upgrade OAuth2: Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401 UNAUTHORIZED , with WWW-Authenticate headers. Update, simplify, and improve all the security docs . Add new scope_str to SecurityScopes and update docs: OAuth2 scopes . Update docs, images, tests. PR #188 . Include Hypercorn as an alternative ASGI server in the docs. PR #187 . Add docs for Static Files and Templates . PR #186 . Add docs for handling Response Cookies and Response Headers . PR #185 . Fix typos in docs. PR #176 by @chdsbd . 0.19.0 \u00b6 Rename path operation decorator parameter content_type to response_class . PR #183 . Add docs: How to use the jsonable_encoder in JSON compatible encoder . How to Return a Response directly . Update how to use a Custom Response Class . PR #184 . 0.18.0 \u00b6 Add docs for HTTP Basic Auth . PR #177 . Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR #175 . Update dependencies for security. PR #174 . Add docs for Middleware . PR #173 . 0.17.0 \u00b6 Make Flit publish from CI. PR #170 . Add documentation about handling CORS (Cross-Origin Resource Sharing) . PR #169 . By default, encode by alias. This allows using Pydantic alias parameters working by default. PR #168 . 0.16.0 \u00b6 Upgrade path operation doctsring parsing to support proper Markdown descriptions. New documentation at Path Operation Configuration . PR #163 . Refactor internal usage of Pydantic to use correct data types. PR #164 . Upgrade Pydantic to version 0.23 . PR #160 by @euri10 . Fix typo in Tutorial about Extra Models. PR #159 by @danielmichaels . Fix Query Parameters URL examples in docs. PR #157 by @hayata-yamamoto . 0.15.0 \u00b6 Add support for multiple file uploads (as a single form field). New docs at: Multiple file uploads . PR #158 . Add docs for: Additional Status Codes . PR #156 . 0.14.0 \u00b6 Improve automatically generated names of path operations in OpenAPI (in API docs). A function read_items instead of having a generated name \"Read Items Get\" will have \"Read Items\". PR #155 . Add docs for: Testing FastAPI . PR #151 . Update /docs Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the path operation documentation in the docs. PR #148 by @wshayes . Update development dependencies, Pipfile.lock . PR #150 . Include Falcon and Hug in: Alternatives, Inspiration and Comparisons . 0.13.0 \u00b6 Improve/upgrade OAuth2 scopes support with SecurityScopes : SecurityScopes can be declared as a parameter like Request , to get the scopes of all super-dependencies/dependants. Improve Security handling, merging scopes when declaring SecurityScopes . Allow using SecurityBase (like OAuth2 ) classes with Depends and still document them. Security now is needed only to declare scopes . Updated docs about: OAuth2 with Password (and hashing), Bearer with JWT tokens . New docs about: OAuth2 scopes . PR #141 . 0.12.1 \u00b6 Fix bug: handling additional responses in APIRouter.include_router() . PR #140 . Fix typo in SQL tutorial. PR #138 by @mostaphaRoudsari . Fix typos in section about nested models and OAuth2 with JWT. PR #127 by @mmcloud . 0.12.0 \u00b6 Add additional responses parameter to path operation decorators to extend responses in OpenAPI (and API docs). It also allows extending existing responses generated from response_model , declare other media types (like images), etc. The new documentation is here: Additional Responses . responses can also be added to .include_router() , the updated docs are here: Bigger Applications . PR #97 originally initiated by @barsi . Update scripts/test-cov-html.sh to allow passing extra parameters like -vv , for development. 0.11.0 \u00b6 Add auto_error parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR #134 . Update SQL Tutorial to close database sessions even when there are exceptions. PR #89 by @alexiri . Fix duplicate dependency in pyproject.toml . PR #128 by @zxalif . 0.10.3 \u00b6 Add Gitter chat, badge, links, etc. https://gitter.im/tiangolo/fastapi . PR #117 . Add docs about Extending OpenAPI . PR #126 . Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR #92 by @blueyed . Fix duplicated param variable creation. PR #123 by @yihuang . Add note in Response Model docs about why using a function parameter instead of a function return type annotation. PR #109 by @JHSaunders . Fix event docs (startup/shutdown) function name. PR #105 by @stratosgear . 0.10.2 \u00b6 Fix OpenAPI (JSON Schema) for declarations of Python Union (JSON Schema additionalProperties ). PR #121 . Update Background Tasks with a note on Celery. Document response models using unions and lists, updated at: Extra Models . PR #108 . 0.10.1 \u00b6 Add docs and tests for encode/databases . New docs at: Async SQL (Relational) Databases . PR #107 . 0.10.0 \u00b6 Add support for Background Tasks in path operation functions and dependencies. New documentation about Background Tasks is here . PR #103 . Add support for .websocket_route() in APIRouter . PR #100 by @euri10 . New docs section about Events: startup - shutdown . PR #99 . 0.9.1 \u00b6 Document receiving Multiple values with the same query parameter and Duplicate headers . PR #95 . 0.9.0 \u00b6 Upgrade compatible Pydantic version to 0.21.0 . PR #90 . Add documentation for: Application Configuration . Fix typo in docs. PR #76 by @matthewhegarty . Fix link in \"Deployment\" to \"Bigger Applications\". 0.8.0 \u00b6 Make development scripts executable. PR #76 by @euri10 . Add support for adding tags in app.include_router() . PR #55 by @euri10 . Documentation updated in the section: Bigger Applications . Update docs related to Uvicorn to use new --reload option from version 0.5.x . PR #74 . Update isort imports and scripts to be compatible with newer versions. PR #75 . 0.7.1 \u00b6 Update technical details about async def handling with respect to previous frameworks. PR #64 by @haizaar . Add deployment documentation for Docker in Raspberry Pi and other architectures. Trigger Docker images build on Travis CI automatically. PR #65 . 0.7.0 \u00b6 Add support for UploadFile in File parameter annotations. This includes a file-like interface. Here's the updated documentation for declaring File parameters with UploadFile . And here's the updated documentation for using Form parameters mixed with File parameters, supporting bytes and UploadFile at the same time. PR #63 . 0.6.4 \u00b6 Add technical details about async def handling to docs . PR #61 . Add docs for Debugging FastAPI applications in editors . Clarify Bigger Applications deployed with Docker . Fix typos in docs. Add section about History, Design and Future . Add docs for using WebSockets with FastAPI . PR #62 . 0.6.3 \u00b6 Add Favicons to docs. PR #53 . 0.6.2 \u00b6 Introduce new project generator based on FastAPI and PostgreSQL: https://github.com/tiangolo/full-stack-fastapi-postgresql . PR #52 . Update SQL tutorial with SQLAlchemy, using Depends to improve editor support and reduce code repetition . PR #52 . Improve middleware naming in tutorial for SQL with SQLAlchemy https://fastapi.tiangolo.com/tutorial/sql-databases/ . 0.6.1 \u00b6 Add docs for GraphQL: https://fastapi.tiangolo.com/tutorial/graphql/ . PR #48 . 0.6.0 \u00b6 Update SQL with SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using the new official request.state . PR #45 . Upgrade Starlette to version 0.11.1 and add required compatibility changes. PR #44 . 0.5.1 \u00b6 Add section about helping and getting help with FastAPI . Add note about path operations order in docs . Update section about error handling with more information and make relation with Starlette error handling utilities more explicit. PR #41 . Add Development - Contributing section to the docs . PR #42 . 0.5.0 \u00b6 Add new HTTPException with support for custom headers. With new documentation for handling errors at: https://fastapi.tiangolo.com/tutorial/handling-errors/ . PR #35 . Add documentation to use Starlette Request object directly. Check #25 by @euri10 . Add issue templates to simplify reporting bugs, getting help, etc: #34 . Update example for the SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using middleware and database session attached to request. 0.4.0 \u00b6 Add openapi_prefix , support for reverse proxy and mounting sub-applications. See the docs at https://fastapi.tiangolo.com/tutorial/sub-applications-proxy/ : #26 by @kabirkhan . Update docs/tutorial for SQLAlchemy including note about DB Browser for SQLite . 0.3.0 \u00b6 Fix/add SQLAlchemy support, including ORM, and update docs for SQLAlchemy : #30 . 0.2.1 \u00b6 Fix jsonable_encoder for Pydantic models with Config but without json_encoders : #29 . 0.2.0 \u00b6 Fix typos in Security section: #24 by @kkinder . Add support for Pydantic custom JSON encoders: #21 by @euri10 . 0.1.19 \u00b6 Upgrade Starlette version to the current latest 0.10.1 : #17 by @euri10 .","title":"Release Notes"},{"location":"release-notes/#latest-changes","text":"","title":"Latest changes"},{"location":"release-notes/#0490","text":"Fix encoding of pathlib paths in jsonable_encoder . PR #978 by @patrickmckenna . Add articles to External Links : Python\u306eWeb framework\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u6bd4\u8f03 (Django, Flask, responder, FastAPI, japronto) and [FastAPI] Python\u88fd\u306eASGI Web \u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af FastAPI\u306b\u5165\u9580\u3059\u308b . PR #974 by @tokusumi . Fix broken links in docs. PR #949 by @tsotnikov . Fix small typos. PR #941 by @NikitaKolesov . Update and clarify docs for dependencies with yield . PR #986 . Add Mermaid JS support for diagrams in docs. Add first diagrams to Dependencies: First Steps and Dependencies with yield and HTTPException . PR #985 . Update CI to run docs deployment in GitHub actions. PR #983 . Allow callable s in path operation functions , like functions modified with functools.partial . PR #977 .","title":"0.49.0"},{"location":"release-notes/#0480","text":"Run linters first in tests to error out faster. PR #948 . Log warning about email-validator only when used. PR #946 . Simplify Peewee docs with double dependency with yield . PR #947 . Add article External Links : Create and Deploy FastAPI app to Heroku . PR #942 by @windson . Update description of Sanic, as it is now ASGI too. PR #932 by @raphaelauv . Fix typo in main page. PR #920 by @mMarzeta . Fix parsing of possibly invalid bodies. PR #918 by @dmontagu . Fix typo #916 by @adursun . Allow Any type for enums in OpenAPI. PR #906 by @songzhi . Add article to External Links : How to continuously deploy a FastAPI to AWS Lambda with AWS SAM . PR #901 by @iwpnd . Add note about using Body parameters without Pydantic. PR #900 by @pawamoy . Fix Pydantic field clone logic. PR #899 by @deuce2367 . Fix link in middleware docs. PR #893 by @linchiwei123 . Rename default API title from \"Fast API\" to \"FastAPI\" for consistency. PR #890 .","title":"0.48.0"},{"location":"release-notes/#0471","text":"Fix model filtering in response_model , cloning sub-models. PR #889 . Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR #888 .","title":"0.47.1"},{"location":"release-notes/#0470","text":"Refactor documentation to make a simpler and shorter Tutorial - User Guide and an additional Advanced User Guide with all the additional docs. PR #887 . Tweak external links, Markdown format, typos. PR #881 . Fix bug in tutorial handling HTTP Basic Auth username and password . PR #865 by @isaevpd . Fix handling form path operation parameters declared with pure classes like list , tuple , etc. PR #856 by @nsidnev . Add request body to RequestValidationError , new docs: Use the RequestValidationError body . Initial PR #853 by @aviramha . Update External Links with new links and dynamic GitHub projects with fastapi topic. PR #850 . Fix Peewee contextvars handling in docs: SQL (Relational) Databases with Peewee . PR #879 . Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs: Development - Contributing . PR #877 . Update docs for HTTP Basic Auth to improve security against timing attacks. Initial PR #807 by @zwass .","title":"0.47.0"},{"location":"release-notes/#0460","text":"Fix typos and tweak configs. PR #837 . Add link to Chinese article in External Links . PR 810 by @wxq0309 . Implement OAuth2AuthorizationCodeBearer class. PR #797 by @kuwv . Update example upgrade in docs main page. PR #795 by @cdeil . Fix callback handling for sub-routers. PR #792 by @jekirl . Fix typos. PR #784 by @kkinder . Add 4 Japanese articles to External Links . PR #783 by @HymanZHAN . Add support for subtypes of main types in jsonable_encoder , e.g. asyncpg's UUIDs. PR #756 by @RmStorm . Fix usage of Pydantic's HttpUrl in docs. PR #832 by @Dustyposa . Fix Twitter links in docs. PR #813 by @justindujardin . Add docs for correctly using FastAPI with Peewee ORM . Including how to overwrite parts of Peewee to correctly handle async threads. PR #789 .","title":"0.46.0"},{"location":"release-notes/#0450","text":"Add support for OpenAPI Callbacks: New docs: OpenAPI Callbacks . Refactor generation of operationId s to be valid Python names (also valid variables in most languages). Add default_response_class parameter to APIRouter . Original PR #722 by @booooh . Refactor logging to use the same logger everywhere, update log strings and levels. PR #781 . Add article to External Links : \u041f\u043e\u0447\u0435\u043c\u0443 \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c FastAPI? . PR #766 by @prostomarkeloff . Remove gender bias in docs for handling errors. PR #780 . Original idea in PR #761 by @classywhetten . Rename docs and references to body-schema to body-fields to keep in line with Pydantic. PR #746 by @prostomarkeloff .","title":"0.45.0"},{"location":"release-notes/#0441","text":"Add GitHub social preview images to git. PR #752 . Update PyPI \"trove classifiers\". PR #751 . Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR 749 . Update \"new issue\" templates. PR #749 . Fix serialization of errors for exotic Pydantic types. PR #748 by @dmontagu .","title":"0.44.1"},{"location":"release-notes/#0440","text":"Add GitHub action Issue Manager . PR #742 . Fix typos in docs. PR 734 by @bundabrg . Fix usage of custom_encoder in jsonable_encoder . PR #715 by @matrixise . Fix invalid XML example. PR 710 by @OcasoProtal . Fix typos and update wording in deployment docs. PR #700 by @marier-nico . Add note about dependencies in APIRouter docs. PR #698 by @marier-nico . Add support for async class methods as dependencies #681 by @frankie567 . Add FastAPI with Swagger UI cheatsheet to external links. PR #671 by @euri10 . Fix typo in HTTP protocol in CORS example. PR #647 by @forestmonster . Add support for Pydantic versions 1.0.0 and above, with temporary (deprecated) backwards compatibility for Pydantic 0.32.2 . PR #646 by @dmontagu .","title":"0.44.0"},{"location":"release-notes/#0430","text":"Update docs to reduce gender bias. PR #645 by @ticosax . Add docs about overriding the operationId for all the path operations based on their function name. PR #642 by @SKalt . Fix validators in models generating an incorrect key order. PR #637 by @jaddison . Generate correct OpenAPI docs for responses with no content. PR #621 by @brotskydotcom . Remove $ from Bash code blocks in docs for consistency. PR #613 by @nstapelbroek . Add docs for self-serving docs' (Swagger UI) static assets , e.g. to use the docs offline, or without Internet. Initial PR #557 by @svalouch . Fix black linting after upgrade. PR #682 by @frankie567 .","title":"0.43.0"},{"location":"release-notes/#0420","text":"Add dependencies with yield , a.k.a. exit steps, context managers, cleanup, teardown, ... This allows adding extra code after a dependency is done. It can be used, for example, to close database connections. Dependencies with yield can be normal or async , FastAPI will run normal dependencies in a threadpool. They can be combined with normal dependencies. It's possible to have arbitrary trees/levels of dependencies with yield and exit steps are handled in the correct order automatically. It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies: async-exit-stack async-generator New docs at Dependencies with yield . Updated database docs SQL (Relational) Databases: Main FastAPI app . PR #595 . Fix sitemap.xml in website. PR #598 by @samuelcolvin .","title":"0.42.0"},{"location":"release-notes/#0410","text":"Upgrade required Starlette to 0.12.9 , the new range is >=0.12.9,<=0.12.9 . Add State to FastAPI apps at app.state . PR #593 . Improve handling of custom classes for Request s and APIRoute s. This helps to more easily solve use cases like: Reading a body before and/or after a request (equivalent to a middleware). Run middleware-like code only for a subset of path operations . Process a request before passing it to a path operation function . E.g. decompressing, deserializing, etc. Processing a response after being generated by path operation functions but before returning it. E.g. adding custom headers, logging, adding extra metadata. New docs section: Custom Request and APIRoute class . PR #589 by @dmontagu . Fix preserving custom route class in routers when including other sub-routers. PR #538 by @dmontagu .","title":"0.41.0"},{"location":"release-notes/#0400","text":"Add notes to docs about installing python-multipart when using forms. PR #574 by @sliptonic . Generate OpenAPI schemas in alphabetical order. PR #554 by @dmontagu . Add support for truncating docstrings from path operation functions . New docs at Advanced description from docstring . PR #556 by @svalouch . Fix DOCTYPE in HTML files generated for Swagger UI and ReDoc. PR #537 by @Trim21 . Fix handling 4XX responses overriding default 422 validation error responses. PR #517 by @tsouvarev . Fix typo in documentation for Simple HTTP Basic Auth . PR #514 by @prostomarkeloff . Fix incorrect documentation example in first steps . PR #511 by @IgnatovFedor . Add support for Swagger UI initOauth settings with the parameter swagger_ui_init_oauth . PR #499 by @zamiramir .","title":"0.40.0"},{"location":"release-notes/#0390","text":"Allow path parameters to have default values (e.g. None ) and discard them instead of raising an error. This allows declaring a parameter like user_id: str = None that can be taken from a query parameter, but the same path operation can be included in a router with a path /users/{user_id} , in which case will be taken from the path and will be required. PR #464 by @jonathanunderwood . Add support for setting a default_response_class in the FastAPI instance or in include_router . Initial PR #467 by @toppk . Add support for type annotations using strings and from __future__ import annotations . PR #451 by @dmontagu .","title":"0.39.0"},{"location":"release-notes/#0381","text":"Fix incorrect Request class import. PR #493 by @kamalgill .","title":"0.38.1"},{"location":"release-notes/#0380","text":"Add recent articles to External Links and recent opinions. PR #490 . Upgrade support range for Starlette to include 0.12.8 . The new range is >=0.11.1,<=0.12.8\" . PR #477 by @dmontagu . Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR #463 by @dmontagu .","title":"0.38.0"},{"location":"release-notes/#0370","text":"Add support for custom route classes for advanced use cases. PR #468 by @dmontagu . Allow disabling Google fonts in ReDoc. PR #481 by @b1-luettje . Fix security issue: when returning a sub-class of a response model and using skip_defaults it could leak information. PR #485 by @dmontagu . Enable tests for Python 3.8-dev. PR #465 by @Jamim . Add support and tests for Pydantic dataclasses in response_model . PR #454 by @dconathan . Fix typo in OAuth2 JWT tutorial. PR #447 by @pablogamboa . Use the media_type parameter in Body() params to set the media type in OpenAPI for requestBody . PR #439 by @divums . Add article Deploying a scikit-learn model with ONNX and FastAPI by https://www.linkedin.com/in/nico-axtmann . PR #438 by @naxty . Allow setting custom 422 (validation error) response/schema in OpenAPI. And use media type from response class instead of fixed application/json (the default). PR #437 by @divums . Fix using \"default\" extra response with status codes at the same time. PR #489 . Allow additional responses to use status code ranges (like 5XX and 4XX ) and \"default\" . PR #435 by @divums .","title":"0.37.0"},{"location":"release-notes/#0360","text":"Fix implementation for skip_defaults when returning a Pydantic model. PR #422 by @dmontagu . Fix OpenAPI generation when using the same dependency in multiple places for the same path operation . PR #417 by @dmontagu . Allow having empty paths in path operations used with include_router and a prefix . This allows having a router for /cats and all its path operations , while having one of them for /cats . Now it doesn't have to be only /cats/ (with a trailing slash). To use it, declare the path in the path operation as the empty string ( \"\" ). PR #415 by @vitalik . Fix mypy error after merging PR #415. PR #462 .","title":"0.36.0"},{"location":"release-notes/#0350","text":"Fix typo in routing assert . PR #419 by @pablogamboa . Fix typo in docs. PR #411 by @bronsen . Fix parsing a body type declared with Union . PR #400 by @koxudaxi .","title":"0.35.0"},{"location":"release-notes/#0340","text":"Upgrade Starlette supported range to include the latest 0.12.7 . The new range is 0.11.1,<=0.12.7 . PR #367 by @dedsm . Add test for OpenAPI schema with duplicate models from PR #333 by @dmontagu . PR #385 .","title":"0.34.0"},{"location":"release-notes/#0330","text":"Upgrade Pydantic version to 0.30.0 . PR #384 by @jekirl .","title":"0.33.0"},{"location":"release-notes/#0320","text":"Fix typo in docs for features. PR #380 by @MartinoMensio . Fix source code limit for example in Query Parameters . PR #366 by @Smashman . Update wording in docs about OAuth2 scopes . PR #371 by @cjw296 . Update docs for Enum s to inherit from str and improve Swagger UI rendering. PR #351 . Fix regression, add Swagger UI deep linking again. PR #350 . Add test for having path templates in prefix of .include_router . PR #349 . Add note to docs: Include the same router multiple times with different prefix . PR #348 . Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies. Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules. The same new ID generation applies to response models. This also changes the generated title for those models. Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file). This also adds the possibility of using .include_router() with the same APIRouter multiple times, with different prefixes, e.g. /api/v2 and /api/latest , and it will now work correctly. PR #347 .","title":"0.32.0"},{"location":"release-notes/#0310","text":"Upgrade Pydantic supported version to 0.29.0 . New supported version range is \"pydantic >=0.28,<=0.29.0\" . This adds support for Pydantic Generic Models , kudos to @dmontagu . PR #344 .","title":"0.31.0"},{"location":"release-notes/#0301","text":"Add section in docs about External Links and Articles . PR #341 . Remove Pipfile.lock from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR #340 . Update section about Help FastAPI - Get Help . PR #339 . Refine internal type declarations to improve/remove Mypy errors in users' code. PR #338 . Update and clarify SQL tutorial with SQLAlchemy . PR #331 by @mariacamilagl . Add SQLite online viewers to the docs . PR #330 by @cyrilbois .","title":"0.30.1"},{"location":"release-notes/#0300","text":"Add support for Pydantic's ORM mode: Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs: SQL (Relational) Databases . The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using @property decorators) and several other use cases. This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other. If your path operations return an arbitrary object with attributes (e.g. my_item.name instead of my_item[\"name\"] ) AND you use a response_model , make sure to update the Pydantic models with orm_mode = True as described in the docs (link above). New documentation about receiving plain dict s as request bodies: Bodies of arbitrary dict s . New documentation about returning arbitrary dict s in responses: Response with arbitrary dict . Technical Details : When declaring a response_model it is used directly to generate the response content, from whatever was returned from the path operation function . Before this, the return content was first passed through jsonable_encoder to ensure it was a \"jsonable\" object, like a dict , instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use orm_mode = True . If you don't have a response_model , the return object will still be passed through jsonable_encoder first. When a response_model is declared, the same response_model type declaration won't be used as is, it will be \"cloned\" to create an new one (a cloned Pydantic Field with all the submodels cloned as well). This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the response_model (e.g. you return a UserInDB that inherits from User but contains extra fields, like hashed_password , and User is used in the response_model ), it would still pass the validation (because UserInDB is a subclass of User ) and the object would be returned as-is, including the hashed_password . To fix this, the declared response_model is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a List[Item] ), the Pydantic model class(es) will be a different one (the \"cloned\" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned response_model . Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned response_model , containing only the declared fields as normally. PR #322 . Remove/clean unused RegEx code in routing. PR #314 by @dmontagu . Use default response status code descriptions for additional responses. PR #313 by @duxiaoyao . Upgrade Pydantic support to 0.28 . PR #320 by @jekirl .","title":"0.30.0"},{"location":"release-notes/#0291","text":"Fix handling an empty-body request with a required body param. PR #311 . Fix broken link in docs: Return a Response directly . PR #306 by @dmontagu . Fix docs discrepancy in docs for Response Model . PR #288 by @awiddersheim .","title":"0.29.1"},{"location":"release-notes/#0290","text":"Add support for declaring a Response parameter: This allows declaring: Response Cookies . Response Headers . An HTTP Status Code different than the default: Response - Change Status Code . All of this while still being able to return arbitrary objects ( dict , DB model, etc). Update attribution to Hug, for inspiring the response parameter pattern. PR #294 .","title":"0.29.0"},{"location":"release-notes/#0280","text":"Implement dependency cache per request. This avoids calling each dependency multiple times for the same request. This is useful while calling external services, performing costly computation, etc. This also means that if a dependency was declared as a path operation decorator dependency, possibly at the router level (with .include_router() ) and then it is declared again in a specific path operation , the dependency will be called only once. The cache can be disabled per dependency declaration, using use_cache=False as in Depends(your_dependency, use_cache=False) . Updated docs at: Using the same dependency multiple times . PR #292 . Implement dependency overrides for testing. This allows using overrides/mocks of dependencies during tests. New docs: Testing Dependencies with Overrides . PR #291 .","title":"0.28.0"},{"location":"release-notes/#0272","text":"Fix path and query parameters receiving dict as a valid type. It should be mapped to a body payload. PR #287 . Updated docs at: Query parameter list / multiple values with defaults: Using list .","title":"0.27.2"},{"location":"release-notes/#0271","text":"Fix auto_error=False handling in HTTPBearer security scheme. Do not raise when there's an incorrect Authorization header if auto_error=False . PR #282 . Fix type declaration of HTTPException . PR #279 .","title":"0.27.1"},{"location":"release-notes/#0270","text":"Fix broken link in docs about OAuth 2.0 with scopes. PR #275 by @dmontagu . Refactor param extraction using Pydantic Field : Large refactor, improvement, and simplification of param extraction from path operations . Fix/add support for list query parameters with list defaults. New documentation: Query parameter list / multiple values with defaults . Add support for enumerations in path operation parameters. New documentation: Path Parameters: Predefined values . Add support for type annotations using Optional as in param: Optional[str] = None . New documentation: Optional type declarations . PR #278 .","title":"0.27.0"},{"location":"release-notes/#0260","text":"Separate error handling for validation errors. This will allow developers to customize the exception handlers. Document better how to handle exceptions and use error handlers. Include RequestValidationError and WebSocketRequestValidationError (this last one will be useful once encode/starlette#527 or equivalent is merged). New documentation about exceptions handlers: Install custom exception handlers . Override the default exception handlers . Re-use FastAPI's exception handlers . PR #273 . Fix support for paths in path parameters without needing explicit Path(...) . PR #256 . Documented in PR #272 by @wshayes . New documentation at: Path Parameters containing paths . Update docs for testing FastAPI. Include using POST , sending JSON, testing headers, etc. New documentation: Testing . PR #271 . Fix type declaration of response_model to allow generic Python types as List[Model] . Mainly to fix mypy for users. PR #266 .","title":"0.26.0"},{"location":"release-notes/#0250","text":"Add support for Pydantic's include , exclude , by_alias . Update documentation: Response Model . Add docs for: Body - updates , using Pydantic's skip_defaults . Add method consistency tests. PR #264 . Add CONTRIBUTING.md file to GitHub, to help new contributors. PR #255 by @wshayes . Add support for Pydantic's skip_defaults : There's a new path operation decorator parameter response_model_skip_defaults . The name of the parameter will most probably change in a future version to response_skip_defaults , model_skip_defaults or something similar. New documentation section about using response_model_skip_defaults . PR #248 by @wshayes .","title":"0.25.0"},{"location":"release-notes/#0240","text":"Add support for WebSockets with dependencies and parameters. Support included for: Depends Security Cookie Header Path Query ...as these are compatible with the WebSockets protocol (e.g. Body is not). Updated documentation for WebSockets . PR #178 by @jekirl . Upgrade the compatible version of Pydantic to 0.26.0 . This includes JSON Schema support for IP address and network objects, bug fixes, and other features. PR #247 by @euri10 .","title":"0.24.0"},{"location":"release-notes/#0230","text":"Upgrade the compatible version of Starlette to 0.12.0 . This includes support for ASGI 3 (the latest version of the standard). It's now possible to use Starlette's StreamingResponse with iterators, like file-like objects (as those returned by open() ). It's now possible to use the low level utility iterate_in_threadpool from starlette.concurrency (for advanced scenarios). PR #243 . Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add {your_origin}/docs/oauth2-redirect to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc). For example, during development, it could be http://localhost:8000/docs/oauth2-redirect . Have in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at https://yourdomain.com/login/callback . This is only to allow delegated authentication in the API docs with Swagger UI. PR #198 by @steinitzu . Make Swagger UI and ReDoc route handlers ( path operations ) be async functions instead of lambdas to improve performance. PR #241 by @Trim21 . Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR #112 by @euri10 .","title":"0.23.0"},{"location":"release-notes/#0220","text":"Add support for dependencies parameter: A parameter in path operation decorators , for dependencies that should be executed but the return value is not important or not used in the path operation function . A parameter in the .include_router() method of FastAPI applications and routers, to include dependencies that should be executed in each path operation in a router. This is useful, for example, to require authentication or permissions in specific group of path operations . Different dependencies can be applied to different routers. These dependencies are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined. Dependencies declared in a router are executed first, then the ones defined in path operation decorators , and then the ones declared in normal parameters. They are all combined and executed. All this also supports using Security with scopes in those dependencies parameters, for more advanced OAuth 2.0 security scenarios with scopes. New documentation about dependencies in path operation decorators . New documentation about dependencies in the include_router() method . PR #235 . Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using path convertors, to take a whole path as a parameter, like /some/url/{p:path} . PR #234 by @euri10 . Make default parameter utilities exported from fastapi be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix mypy errors in FastAPI's users' code. Applies to Path , Query , Header , Cookie , Body , Form , File , Depends , and Security . PR #226 and PR #231 . Separate development scripts test.sh , lint.sh , and format.sh . PR #232 . Re-enable black formatting checks for Python 3.7. PR #229 by @zamiramir .","title":"0.22.0"},{"location":"release-notes/#0210","text":"On body parsing errors, raise from previous exception, to allow better introspection in logging code. PR #192 by @ricardomomm . Use Python logger named \" fastapi \" instead of root logger. PR #222 by @euri10 . Upgrade Pydantic to version 0.25. PR #225 by @euri10 . Fix typo in routing. PR #221 by @djlambert .","title":"0.21.0"},{"location":"release-notes/#0201","text":"Add typing information to package including file py.typed . PR #209 by @meadsteve . Add FastAPI bot for Gitter. To automatically announce new releases. PR #189 .","title":"0.20.1"},{"location":"release-notes/#0200","text":"Upgrade OAuth2: Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401 UNAUTHORIZED , with WWW-Authenticate headers. Update, simplify, and improve all the security docs . Add new scope_str to SecurityScopes and update docs: OAuth2 scopes . Update docs, images, tests. PR #188 . Include Hypercorn as an alternative ASGI server in the docs. PR #187 . Add docs for Static Files and Templates . PR #186 . Add docs for handling Response Cookies and Response Headers . PR #185 . Fix typos in docs. PR #176 by @chdsbd .","title":"0.20.0"},{"location":"release-notes/#0190","text":"Rename path operation decorator parameter content_type to response_class . PR #183 . Add docs: How to use the jsonable_encoder in JSON compatible encoder . How to Return a Response directly . Update how to use a Custom Response Class . PR #184 .","title":"0.19.0"},{"location":"release-notes/#0180","text":"Add docs for HTTP Basic Auth . PR #177 . Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR #175 . Update dependencies for security. PR #174 . Add docs for Middleware . PR #173 .","title":"0.18.0"},{"location":"release-notes/#0170","text":"Make Flit publish from CI. PR #170 . Add documentation about handling CORS (Cross-Origin Resource Sharing) . PR #169 . By default, encode by alias. This allows using Pydantic alias parameters working by default. PR #168 .","title":"0.17.0"},{"location":"release-notes/#0160","text":"Upgrade path operation doctsring parsing to support proper Markdown descriptions. New documentation at Path Operation Configuration . PR #163 . Refactor internal usage of Pydantic to use correct data types. PR #164 . Upgrade Pydantic to version 0.23 . PR #160 by @euri10 . Fix typo in Tutorial about Extra Models. PR #159 by @danielmichaels . Fix Query Parameters URL examples in docs. PR #157 by @hayata-yamamoto .","title":"0.16.0"},{"location":"release-notes/#0150","text":"Add support for multiple file uploads (as a single form field). New docs at: Multiple file uploads . PR #158 . Add docs for: Additional Status Codes . PR #156 .","title":"0.15.0"},{"location":"release-notes/#0140","text":"Improve automatically generated names of path operations in OpenAPI (in API docs). A function read_items instead of having a generated name \"Read Items Get\" will have \"Read Items\". PR #155 . Add docs for: Testing FastAPI . PR #151 . Update /docs Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the path operation documentation in the docs. PR #148 by @wshayes . Update development dependencies, Pipfile.lock . PR #150 . Include Falcon and Hug in: Alternatives, Inspiration and Comparisons .","title":"0.14.0"},{"location":"release-notes/#0130","text":"Improve/upgrade OAuth2 scopes support with SecurityScopes : SecurityScopes can be declared as a parameter like Request , to get the scopes of all super-dependencies/dependants. Improve Security handling, merging scopes when declaring SecurityScopes . Allow using SecurityBase (like OAuth2 ) classes with Depends and still document them. Security now is needed only to declare scopes . Updated docs about: OAuth2 with Password (and hashing), Bearer with JWT tokens . New docs about: OAuth2 scopes . PR #141 .","title":"0.13.0"},{"location":"release-notes/#0121","text":"Fix bug: handling additional responses in APIRouter.include_router() . PR #140 . Fix typo in SQL tutorial. PR #138 by @mostaphaRoudsari . Fix typos in section about nested models and OAuth2 with JWT. PR #127 by @mmcloud .","title":"0.12.1"},{"location":"release-notes/#0120","text":"Add additional responses parameter to path operation decorators to extend responses in OpenAPI (and API docs). It also allows extending existing responses generated from response_model , declare other media types (like images), etc. The new documentation is here: Additional Responses . responses can also be added to .include_router() , the updated docs are here: Bigger Applications . PR #97 originally initiated by @barsi . Update scripts/test-cov-html.sh to allow passing extra parameters like -vv , for development.","title":"0.12.0"},{"location":"release-notes/#0110","text":"Add auto_error parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR #134 . Update SQL Tutorial to close database sessions even when there are exceptions. PR #89 by @alexiri . Fix duplicate dependency in pyproject.toml . PR #128 by @zxalif .","title":"0.11.0"},{"location":"release-notes/#0103","text":"Add Gitter chat, badge, links, etc. https://gitter.im/tiangolo/fastapi . PR #117 . Add docs about Extending OpenAPI . PR #126 . Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR #92 by @blueyed . Fix duplicated param variable creation. PR #123 by @yihuang . Add note in Response Model docs about why using a function parameter instead of a function return type annotation. PR #109 by @JHSaunders . Fix event docs (startup/shutdown) function name. PR #105 by @stratosgear .","title":"0.10.3"},{"location":"release-notes/#0102","text":"Fix OpenAPI (JSON Schema) for declarations of Python Union (JSON Schema additionalProperties ). PR #121 . Update Background Tasks with a note on Celery. Document response models using unions and lists, updated at: Extra Models . PR #108 .","title":"0.10.2"},{"location":"release-notes/#0101","text":"Add docs and tests for encode/databases . New docs at: Async SQL (Relational) Databases . PR #107 .","title":"0.10.1"},{"location":"release-notes/#0100","text":"Add support for Background Tasks in path operation functions and dependencies. New documentation about Background Tasks is here . PR #103 . Add support for .websocket_route() in APIRouter . PR #100 by @euri10 . New docs section about Events: startup - shutdown . PR #99 .","title":"0.10.0"},{"location":"release-notes/#091","text":"Document receiving Multiple values with the same query parameter and Duplicate headers . PR #95 .","title":"0.9.1"},{"location":"release-notes/#090","text":"Upgrade compatible Pydantic version to 0.21.0 . PR #90 . Add documentation for: Application Configuration . Fix typo in docs. PR #76 by @matthewhegarty . Fix link in \"Deployment\" to \"Bigger Applications\".","title":"0.9.0"},{"location":"release-notes/#080","text":"Make development scripts executable. PR #76 by @euri10 . Add support for adding tags in app.include_router() . PR #55 by @euri10 . Documentation updated in the section: Bigger Applications . Update docs related to Uvicorn to use new --reload option from version 0.5.x . PR #74 . Update isort imports and scripts to be compatible with newer versions. PR #75 .","title":"0.8.0"},{"location":"release-notes/#071","text":"Update technical details about async def handling with respect to previous frameworks. PR #64 by @haizaar . Add deployment documentation for Docker in Raspberry Pi and other architectures. Trigger Docker images build on Travis CI automatically. PR #65 .","title":"0.7.1"},{"location":"release-notes/#070","text":"Add support for UploadFile in File parameter annotations. This includes a file-like interface. Here's the updated documentation for declaring File parameters with UploadFile . And here's the updated documentation for using Form parameters mixed with File parameters, supporting bytes and UploadFile at the same time. PR #63 .","title":"0.7.0"},{"location":"release-notes/#064","text":"Add technical details about async def handling to docs . PR #61 . Add docs for Debugging FastAPI applications in editors . Clarify Bigger Applications deployed with Docker . Fix typos in docs. Add section about History, Design and Future . Add docs for using WebSockets with FastAPI . PR #62 .","title":"0.6.4"},{"location":"release-notes/#063","text":"Add Favicons to docs. PR #53 .","title":"0.6.3"},{"location":"release-notes/#062","text":"Introduce new project generator based on FastAPI and PostgreSQL: https://github.com/tiangolo/full-stack-fastapi-postgresql . PR #52 . Update SQL tutorial with SQLAlchemy, using Depends to improve editor support and reduce code repetition . PR #52 . Improve middleware naming in tutorial for SQL with SQLAlchemy https://fastapi.tiangolo.com/tutorial/sql-databases/ .","title":"0.6.2"},{"location":"release-notes/#061","text":"Add docs for GraphQL: https://fastapi.tiangolo.com/tutorial/graphql/ . PR #48 .","title":"0.6.1"},{"location":"release-notes/#060","text":"Update SQL with SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using the new official request.state . PR #45 . Upgrade Starlette to version 0.11.1 and add required compatibility changes. PR #44 .","title":"0.6.0"},{"location":"release-notes/#051","text":"Add section about helping and getting help with FastAPI . Add note about path operations order in docs . Update section about error handling with more information and make relation with Starlette error handling utilities more explicit. PR #41 . Add Development - Contributing section to the docs . PR #42 .","title":"0.5.1"},{"location":"release-notes/#050","text":"Add new HTTPException with support for custom headers. With new documentation for handling errors at: https://fastapi.tiangolo.com/tutorial/handling-errors/ . PR #35 . Add documentation to use Starlette Request object directly. Check #25 by @euri10 . Add issue templates to simplify reporting bugs, getting help, etc: #34 . Update example for the SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using middleware and database session attached to request.","title":"0.5.0"},{"location":"release-notes/#040","text":"Add openapi_prefix , support for reverse proxy and mounting sub-applications. See the docs at https://fastapi.tiangolo.com/tutorial/sub-applications-proxy/ : #26 by @kabirkhan . Update docs/tutorial for SQLAlchemy including note about DB Browser for SQLite .","title":"0.4.0"},{"location":"release-notes/#030","text":"Fix/add SQLAlchemy support, including ORM, and update docs for SQLAlchemy : #30 .","title":"0.3.0"},{"location":"release-notes/#021","text":"Fix jsonable_encoder for Pydantic models with Config but without json_encoders : #29 .","title":"0.2.1"},{"location":"release-notes/#020","text":"Fix typos in Security section: #24 by @kkinder . Add support for Pydantic custom JSON encoders: #21 by @euri10 .","title":"0.2.0"},{"location":"release-notes/#0119","text":"Upgrade Starlette version to the current latest 0.10.1 : #17 by @euri10 .","title":"0.1.19"},{"location":"advanced/","text":"Additional Features \u00b6 The main Tutorial - User Guide should be enough to give you a tour through all the main features of FastAPI . In the next sections you will see other options, configurations, and additional features. Tip The next sections are not necessarily \"advanced\" . And it's possible that for your use case, the solution is in one of them. Read the Tutorial first \u00b6 You could still use most of the features in FastAPI with the knowledge from the main Tutorial - User Guide . And the next sections assume you already read it, and assume that you know those main ideas.","title":"Advanced User Guide - Intro"},{"location":"advanced/#additional-features","text":"The main Tutorial - User Guide should be enough to give you a tour through all the main features of FastAPI . In the next sections you will see other options, configurations, and additional features. Tip The next sections are not necessarily \"advanced\" . And it's possible that for your use case, the solution is in one of them.","title":"Additional Features"},{"location":"advanced/#read-the-tutorial-first","text":"You could still use most of the features in FastAPI with the knowledge from the main Tutorial - User Guide . And the next sections assume you already read it, and assume that you know those main ideas.","title":"Read the Tutorial first"},{"location":"advanced/additional-responses/","text":"Warning This is a rather advanced topic. If you are starting with FastAPI , you might not need this. You can declare additional responses, with additional status codes, media types, descriptions, etc. Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs. But for those additional responses you have to make sure you return a Response like JSONResponse directly, with your status code and content. Additional Response with model \u00b6 You can pass to your path operation decorators a parameter responses . It receives a dict , the keys are status codes for each response, like 200 , and the values are other dict s with the information for each of them. Each of those response dict s can have a key model , containing a Pydantic model, just like response_model . FastAPI will take that model, generate its JSON Schema and include it in the correct place in OpenAPI. For example, to declare another response with a status code 404 and a Pydantic model Message , you can write: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): id : str value : str class Message ( BaseModel ): message : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 404 : { \"model\" : Message }}) async def read_item ( item_id : str ): if item_id == \"foo\" : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } else : return JSONResponse ( status_code = 404 , content = { \"message\" : \"Item not found\" }) Note Have in mind that you have to return the JSONResponse directly. Info The model key is not part of OpenAPI. FastAPI will take the Pydantic model from there, generate the JSON Schema , and put it in the correct place. The correct place is: In the key content , that has as value another JSON object ( dict ) that contains: A key with the media type, e.g. application/json , that contains as value another JSON object, that contains: A key schema , that has as the value the JSON Schema from the model, here's the correct place. FastAPI adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc. The generated responses in the OpenAPI for this path operation will be: { \"responses\" : { \"404\" : { \"description\" : \"Additional Response\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Message\" } } } }, \"200\" : { \"description\" : \"Successful Response\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Item\" } } } }, \"422\" : { \"description\" : \"Validation Error\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/HTTPValidationError\" } } } } } } The schemas are referenced to another place inside the OpenAPI schema: { \"components\" : { \"schemas\" : { \"Message\" : { \"title\" : \"Message\" , \"required\" : [ \"message\" ], \"type\" : \"object\" , \"properties\" : { \"message\" : { \"title\" : \"Message\" , \"type\" : \"string\" } } }, \"Item\" : { \"title\" : \"Item\" , \"required\" : [ \"id\" , \"value\" ], \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"value\" : { \"title\" : \"Value\" , \"type\" : \"string\" } } }, \"ValidationError\" : { \"title\" : \"ValidationError\" , \"required\" : [ \"loc\" , \"msg\" , \"type\" ], \"type\" : \"object\" , \"properties\" : { \"loc\" : { \"title\" : \"Location\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"msg\" : { \"title\" : \"Message\" , \"type\" : \"string\" }, \"type\" : { \"title\" : \"Error Type\" , \"type\" : \"string\" } } }, \"HTTPValidationError\" : { \"title\" : \"HTTPValidationError\" , \"type\" : \"object\" , \"properties\" : { \"detail\" : { \"title\" : \"Detail\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/components/schemas/ValidationError\" } } } } } } } Additional media types for the main response \u00b6 You can use this same responses parameter to add different media types for the same main response. For example, you can add an additional media type of image/png , declaring that your path operation can return a JSON object (with media type application/json ) or a PNG image: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import FileResponse class Item ( BaseModel ): id : str value : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 200 : { \"content\" : { \"image/png\" : {}}, \"description\" : \"Return the JSON item or an image.\" , } }, ) async def read_item ( item_id : str , img : bool = None ): if img : return FileResponse ( \"image.png\" , media_type = \"image/png\" ) else : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } Note Notice that you have to return the image using a FileResponse directly. Info Unless you specify a different media type explicitly in your responses parameter, FastAPI will assume the response has the same media type as the main response class (default application/json ). But if you have specified a custom response class with None as its media type, FastAPI will use application/json for any additional response that has an associated model. Combining information \u00b6 You can also combine response information from multiple places, including the response_model , status_code , and responses parameters. You can declare a response_model , using the default status code 200 (or a custom one if you need), and then declare additional information for that same response in responses , directly in the OpenAPI schema. FastAPI will keep the additional information from responses , and combine it with the JSON Schema from your model. For example, you can declare a response with a status code 404 that uses a Pydantic model and has a custom description . And a response with a status code 200 that uses your response_model , but includes a custom example : from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): id : str value : str class Message ( BaseModel ): message : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 404 : { \"model\" : Message , \"description\" : \"The item was not found\" }, 200 : { \"description\" : \"Item requested by ID\" , \"content\" : { \"application/json\" : { \"example\" : { \"id\" : \"bar\" , \"value\" : \"The bar tenders\" } } }, }, }, ) async def read_item ( item_id : str ): if item_id == \"foo\" : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } else : return JSONResponse ( status_code = 404 , content = { \"message\" : \"Item not found\" }) It will all be combined and included in your OpenAPI, and shown in the API docs: Combine predefined responses and custom ones \u00b6 You might want to have some predefined responses that apply to many path operations , but you want to combine them with custom responses needed by each path operation . For those cases, you can use the Python technique of \"unpacking\" a dict with **dict_to_unpack : old_dict = { \"old key\" : \"old value\" , \"second old key\" : \"second old value\" , } new_dict = { ** old_dict , \"new key\" : \"new value\" } Here, new_dict will contain all the key-value pairs from old_dict plus the new key-value pair: { \"old key\" : \"old value\" , \"second old key\" : \"second old value\" , \"new key\" : \"new value\" , } You can use that technique to re-use some predefined responses in your path operations and combine them with additional custom ones. For example: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import FileResponse class Item ( BaseModel ): id : str value : str responses = { 404 : { \"description\" : \"Item not found\" }, 302 : { \"description\" : \"The item was moved\" }, 403 : { \"description\" : \"Not enough privileges\" }, } app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { ** responses , 200 : { \"content\" : { \"image/png\" : {}}}}, ) async def read_item ( item_id : str , img : bool = None ): if img : return FileResponse ( \"image.png\" , media_type = \"image/png\" ) else : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } More information about OpenAPI responses \u00b6 To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification: OpenAPI Responses Object , it includes the Response Object . OpenAPI Response Object , you can include anything from this directly in each response inside your responses parameter. Including description , headers , content (inside of this is that you declare different media types and JSON Schemas), and links .","title":"Additional Responses in OpenAPI"},{"location":"advanced/additional-responses/#additional-response-with-model","text":"You can pass to your path operation decorators a parameter responses . It receives a dict , the keys are status codes for each response, like 200 , and the values are other dict s with the information for each of them. Each of those response dict s can have a key model , containing a Pydantic model, just like response_model . FastAPI will take that model, generate its JSON Schema and include it in the correct place in OpenAPI. For example, to declare another response with a status code 404 and a Pydantic model Message , you can write: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): id : str value : str class Message ( BaseModel ): message : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 404 : { \"model\" : Message }}) async def read_item ( item_id : str ): if item_id == \"foo\" : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } else : return JSONResponse ( status_code = 404 , content = { \"message\" : \"Item not found\" }) Note Have in mind that you have to return the JSONResponse directly. Info The model key is not part of OpenAPI. FastAPI will take the Pydantic model from there, generate the JSON Schema , and put it in the correct place. The correct place is: In the key content , that has as value another JSON object ( dict ) that contains: A key with the media type, e.g. application/json , that contains as value another JSON object, that contains: A key schema , that has as the value the JSON Schema from the model, here's the correct place. FastAPI adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc. The generated responses in the OpenAPI for this path operation will be: { \"responses\" : { \"404\" : { \"description\" : \"Additional Response\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Message\" } } } }, \"200\" : { \"description\" : \"Successful Response\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/Item\" } } } }, \"422\" : { \"description\" : \"Validation Error\" , \"content\" : { \"application/json\" : { \"schema\" : { \"$ref\" : \"#/components/schemas/HTTPValidationError\" } } } } } } The schemas are referenced to another place inside the OpenAPI schema: { \"components\" : { \"schemas\" : { \"Message\" : { \"title\" : \"Message\" , \"required\" : [ \"message\" ], \"type\" : \"object\" , \"properties\" : { \"message\" : { \"title\" : \"Message\" , \"type\" : \"string\" } } }, \"Item\" : { \"title\" : \"Item\" , \"required\" : [ \"id\" , \"value\" ], \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"Id\" , \"type\" : \"string\" }, \"value\" : { \"title\" : \"Value\" , \"type\" : \"string\" } } }, \"ValidationError\" : { \"title\" : \"ValidationError\" , \"required\" : [ \"loc\" , \"msg\" , \"type\" ], \"type\" : \"object\" , \"properties\" : { \"loc\" : { \"title\" : \"Location\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } }, \"msg\" : { \"title\" : \"Message\" , \"type\" : \"string\" }, \"type\" : { \"title\" : \"Error Type\" , \"type\" : \"string\" } } }, \"HTTPValidationError\" : { \"title\" : \"HTTPValidationError\" , \"type\" : \"object\" , \"properties\" : { \"detail\" : { \"title\" : \"Detail\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/components/schemas/ValidationError\" } } } } } } }","title":"Additional Response with model"},{"location":"advanced/additional-responses/#additional-media-types-for-the-main-response","text":"You can use this same responses parameter to add different media types for the same main response. For example, you can add an additional media type of image/png , declaring that your path operation can return a JSON object (with media type application/json ) or a PNG image: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import FileResponse class Item ( BaseModel ): id : str value : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 200 : { \"content\" : { \"image/png\" : {}}, \"description\" : \"Return the JSON item or an image.\" , } }, ) async def read_item ( item_id : str , img : bool = None ): if img : return FileResponse ( \"image.png\" , media_type = \"image/png\" ) else : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } Note Notice that you have to return the image using a FileResponse directly. Info Unless you specify a different media type explicitly in your responses parameter, FastAPI will assume the response has the same media type as the main response class (default application/json ). But if you have specified a custom response class with None as its media type, FastAPI will use application/json for any additional response that has an associated model.","title":"Additional media types for the main response"},{"location":"advanced/additional-responses/#combining-information","text":"You can also combine response information from multiple places, including the response_model , status_code , and responses parameters. You can declare a response_model , using the default status code 200 (or a custom one if you need), and then declare additional information for that same response in responses , directly in the OpenAPI schema. FastAPI will keep the additional information from responses , and combine it with the JSON Schema from your model. For example, you can declare a response with a status code 404 that uses a Pydantic model and has a custom description . And a response with a status code 200 that uses your response_model , but includes a custom example : from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): id : str value : str class Message ( BaseModel ): message : str app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { 404 : { \"model\" : Message , \"description\" : \"The item was not found\" }, 200 : { \"description\" : \"Item requested by ID\" , \"content\" : { \"application/json\" : { \"example\" : { \"id\" : \"bar\" , \"value\" : \"The bar tenders\" } } }, }, }, ) async def read_item ( item_id : str ): if item_id == \"foo\" : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" } else : return JSONResponse ( status_code = 404 , content = { \"message\" : \"Item not found\" }) It will all be combined and included in your OpenAPI, and shown in the API docs:","title":"Combining information"},{"location":"advanced/additional-responses/#combine-predefined-responses-and-custom-ones","text":"You might want to have some predefined responses that apply to many path operations , but you want to combine them with custom responses needed by each path operation . For those cases, you can use the Python technique of \"unpacking\" a dict with **dict_to_unpack : old_dict = { \"old key\" : \"old value\" , \"second old key\" : \"second old value\" , } new_dict = { ** old_dict , \"new key\" : \"new value\" } Here, new_dict will contain all the key-value pairs from old_dict plus the new key-value pair: { \"old key\" : \"old value\" , \"second old key\" : \"second old value\" , \"new key\" : \"new value\" , } You can use that technique to re-use some predefined responses in your path operations and combine them with additional custom ones. For example: from fastapi import FastAPI from pydantic import BaseModel from starlette.responses import FileResponse class Item ( BaseModel ): id : str value : str responses = { 404 : { \"description\" : \"Item not found\" }, 302 : { \"description\" : \"The item was moved\" }, 403 : { \"description\" : \"Not enough privileges\" }, } app = FastAPI () @app . get ( \"/items/ {item_id} \" , response_model = Item , responses = { ** responses , 200 : { \"content\" : { \"image/png\" : {}}}}, ) async def read_item ( item_id : str , img : bool = None ): if img : return FileResponse ( \"image.png\" , media_type = \"image/png\" ) else : return { \"id\" : \"foo\" , \"value\" : \"there goes my hero\" }","title":"Combine predefined responses and custom ones"},{"location":"advanced/additional-responses/#more-information-about-openapi-responses","text":"To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification: OpenAPI Responses Object , it includes the Response Object . OpenAPI Response Object , you can include anything from this directly in each response inside your responses parameter. Including description , headers , content (inside of this is that you declare different media types and JSON Schemas), and links .","title":"More information about OpenAPI responses"},{"location":"advanced/additional-status-codes/","text":"By default, FastAPI will return the responses using Starlette's JSONResponse , putting the content you return from your path operation inside of that JSONResponse . It will use the default status code or the one you set in your path operation . Additional status codes \u00b6 If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse , and set the additional status code directly. For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 \"OK\" when successful. But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 \"Created\". To achieve that, import JSONResponse , and return your content there directly, setting the status_code that you want: from fastapi import Body , FastAPI from starlette.responses import JSONResponse from starlette.status import HTTP_201_CREATED app = FastAPI () items = { \"foo\" : { \"name\" : \"Fighters\" , \"size\" : 6 }, \"bar\" : { \"name\" : \"Tenders\" , \"size\" : 3 }} @app . put ( \"/items/ {item_id} \" ) async def upsert_item ( item_id : str , name : str = Body ( None ), size : int = Body ( None )): if item_id in items : item = items [ item_id ] item [ \"name\" ] = name item [ \"size\" ] = size return item else : item = { \"name\" : name , \"size\" : size } items [ item_id ] = item return JSONResponse ( status_code = HTTP_201_CREATED , content = item ) Warning When you return a Response directly, like in the example above, it will be returned directly. It won't be serialized with a model, etc. Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse ). OpenAPI and API docs \u00b6 If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know before hand what you are going to return. But you can document that in your code, using: Additional Responses .","title":"Additional Status Codes"},{"location":"advanced/additional-status-codes/#additional-status-codes","text":"If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse , and set the additional status code directly. For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 \"OK\" when successful. But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 \"Created\". To achieve that, import JSONResponse , and return your content there directly, setting the status_code that you want: from fastapi import Body , FastAPI from starlette.responses import JSONResponse from starlette.status import HTTP_201_CREATED app = FastAPI () items = { \"foo\" : { \"name\" : \"Fighters\" , \"size\" : 6 }, \"bar\" : { \"name\" : \"Tenders\" , \"size\" : 3 }} @app . put ( \"/items/ {item_id} \" ) async def upsert_item ( item_id : str , name : str = Body ( None ), size : int = Body ( None )): if item_id in items : item = items [ item_id ] item [ \"name\" ] = name item [ \"size\" ] = size return item else : item = { \"name\" : name , \"size\" : size } items [ item_id ] = item return JSONResponse ( status_code = HTTP_201_CREATED , content = item ) Warning When you return a Response directly, like in the example above, it will be returned directly. It won't be serialized with a model, etc. Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse ).","title":"Additional status codes"},{"location":"advanced/additional-status-codes/#openapi-and-api-docs","text":"If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know before hand what you are going to return. But you can document that in your code, using: Additional Responses .","title":"OpenAPI and API docs"},{"location":"advanced/advanced-dependencies/","text":"Warning This is, more or less, an \"advanced\" chapter. If you are just starting with FastAPI you might want to skip this chapter and come back to it later. Parameterized dependencies \u00b6 All the dependencies we have seen are a fixed function or class. But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes. Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content. But we want to be able to parameterize that fixed content. A \"callable\" instance \u00b6 In Python there's a way to make an instance of a class a \"callable\". Not the class itself (which is already a callable), but an instance of that class. To do that, we declare a method __call__ : from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } In this case, this __call__ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later. Parameterize the instance \u00b6 And now, we can use __init__ to declare the parameters of the instance that we can use to \"parameterize\" the dependency: from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } In this case, FastAPI won't ever touch or care about __init__ , we will use it directly in our code. Create an instance \u00b6 We could create an instance of this class with: from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } And that way we are able to \"parameterize\" our dependency, that now has \"bar\" inside of it, as the attribute checker.fixed_content . Use the instance as a dependency \u00b6 Then, we could use this checker in a Depends(checker) , instead of Depends(FixedContentQueryChecker) , because the dependency is the instance, checker , not the class itself. And when solving the dependency, FastAPI will call this checker like: checker ( q = \"somequery\" ) ...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed_content_included : from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } Tip All this might seem contrived. And it might not be very clear how is it useful yet. These examples are intentionally simple, but show how it all works. In the chapters about security, there are utility functions that are implemented in this same way. If you understood all this, you already know how those utility tools for security work underneath.","title":"Advanced Dependencies"},{"location":"advanced/advanced-dependencies/#parameterized-dependencies","text":"All the dependencies we have seen are a fixed function or class. But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes. Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content. But we want to be able to parameterize that fixed content.","title":"Parameterized dependencies"},{"location":"advanced/advanced-dependencies/#a-callable-instance","text":"In Python there's a way to make an instance of a class a \"callable\". Not the class itself (which is already a callable), but an instance of that class. To do that, we declare a method __call__ : from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } In this case, this __call__ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later.","title":"A \"callable\" instance"},{"location":"advanced/advanced-dependencies/#parameterize-the-instance","text":"And now, we can use __init__ to declare the parameters of the instance that we can use to \"parameterize\" the dependency: from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } In this case, FastAPI won't ever touch or care about __init__ , we will use it directly in our code.","title":"Parameterize the instance"},{"location":"advanced/advanced-dependencies/#create-an-instance","text":"We could create an instance of this class with: from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } And that way we are able to \"parameterize\" our dependency, that now has \"bar\" inside of it, as the attribute checker.fixed_content .","title":"Create an instance"},{"location":"advanced/advanced-dependencies/#use-the-instance-as-a-dependency","text":"Then, we could use this checker in a Depends(checker) , instead of Depends(FixedContentQueryChecker) , because the dependency is the instance, checker , not the class itself. And when solving the dependency, FastAPI will call this checker like: checker ( q = \"somequery\" ) ...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed_content_included : from fastapi import Depends , FastAPI app = FastAPI () class FixedContentQueryChecker : def __init__ ( self , fixed_content : str ): self . fixed_content = fixed_content def __call__ ( self , q : str = \"\" ): if q : return self . fixed_content in q return False checker = FixedContentQueryChecker ( \"bar\" ) @app . get ( \"/query-checker/\" ) async def read_query_check ( fixed_content_included : bool = Depends ( checker )): return { \"fixed_content_in_query\" : fixed_content_included } Tip All this might seem contrived. And it might not be very clear how is it useful yet. These examples are intentionally simple, but show how it all works. In the chapters about security, there are utility functions that are implemented in this same way. If you understood all this, you already know how those utility tools for security work underneath.","title":"Use the instance as a dependency"},{"location":"advanced/async-sql-databases/","text":"You can also use encode/databases with FastAPI to connect to databases using async and await . It is compatible with: PostgreSQL MySQL SQLite In this example, we'll use SQLite , because it uses a single file and Python has integrated support. So, you can copy this example and run it as is. Later, for your production application, you might want to use a database server like PostgreSQL . Tip You could adopt ideas from the section about SQLAlchemy ORM ( SQL (Relational) Databases ), like using utility functions to perform operations in the database, independent of your FastAPI code. This section doesn't apply those ideas, to be equivalent to the counterpart in Starlette . Import and set up SQLAlchemy \u00b6 Import SQLAlchemy . Create a metadata object. Create a table notes using the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Tip Notice that all this code is pure SQLAlchemy Core. databases is not doing anything here yet. Import and set up databases \u00b6 Import databases . Create a DATABASE_URL . Create a database object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Tip If you were connecting to a different database (e.g. PostgreSQL), you would need to change the DATABASE_URL . Create the tables \u00b6 In this case, we are creating the tables in the same Python file, but in production, you would probably want to create them with Alembic, integrated with migrations, etc. Here, this section would run directly, right before starting your FastAPI application. Create an engine . Create all the tables from the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Create models \u00b6 Create Pydantic models for: Notes to be created ( NoteIn ). Notes to be returned ( Note ). from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } By creating these Pydantic models, the input data will be validated, serialized (converted), and annotated (documented). So, you will be able to see it all in the interactive API docs. Connect and disconnect \u00b6 Create your FastAPI application. Create event handlers to connect and disconnect from the database. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Read notes \u00b6 Create the path operation function to read notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Note Notice that as we communicate with the database using await , the path operation function is declared with async . Notice the response_model=List[Note] \u00b6 It uses typing.List . That documents (and validates, serializes, filters) the output data, as a list of Note s. Create notes \u00b6 Create the path operation function to create notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Note Notice that as we communicate with the database using await , the path operation function is declared with async . About {**note.dict(), \"id\": last_record_id} \u00b6 note is a Pydantic Note object. note.dict() returns a dict with its data, something like: { \"text\" : \"Some note\" , \"completed\" : False , } but it doesn't have the id field. So we create a new dict , that contains the key-value pairs from note.dict() with: { ** note . dict ()} **note.dict() \"unpacks\" the key value pairs directly, so, {**note.dict()} would be, more or less, a copy of note.dict() . And then, we extend that copy dict , adding another key-value pair: \"id\": last_record_id : { ** note . dict (), \"id\" : last_record_id } So, the final result returned would be something like: { \"id\" : 1 , \"text\" : \"Some note\" , \"completed\" : False , } Check it \u00b6 You can copy this code as is, and see the docs at http://127.0.0.1:8000/docs . There you can see all your API documented and interact with it: More info \u00b6 You can read more about encode/databases at its GitHub page .","title":"Async SQL (Relational) Databases"},{"location":"advanced/async-sql-databases/#import-and-set-up-sqlalchemy","text":"Import SQLAlchemy . Create a metadata object. Create a table notes using the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Tip Notice that all this code is pure SQLAlchemy Core. databases is not doing anything here yet.","title":"Import and set up SQLAlchemy"},{"location":"advanced/async-sql-databases/#import-and-set-up-databases","text":"Import databases . Create a DATABASE_URL . Create a database object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Tip If you were connecting to a different database (e.g. PostgreSQL), you would need to change the DATABASE_URL .","title":"Import and set up databases"},{"location":"advanced/async-sql-databases/#create-the-tables","text":"In this case, we are creating the tables in the same Python file, but in production, you would probably want to create them with Alembic, integrated with migrations, etc. Here, this section would run directly, right before starting your FastAPI application. Create an engine . Create all the tables from the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id }","title":"Create the tables"},{"location":"advanced/async-sql-databases/#create-models","text":"Create Pydantic models for: Notes to be created ( NoteIn ). Notes to be returned ( Note ). from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } By creating these Pydantic models, the input data will be validated, serialized (converted), and annotated (documented). So, you will be able to see it all in the interactive API docs.","title":"Create models"},{"location":"advanced/async-sql-databases/#connect-and-disconnect","text":"Create your FastAPI application. Create event handlers to connect and disconnect from the database. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id }","title":"Connect and disconnect"},{"location":"advanced/async-sql-databases/#read-notes","text":"Create the path operation function to read notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Note Notice that as we communicate with the database using await , the path operation function is declared with async .","title":"Read notes"},{"location":"advanced/async-sql-databases/#notice-the-response_modellistnote","text":"It uses typing.List . That documents (and validates, serializes, filters) the output data, as a list of Note s.","title":"Notice the response_model=List[Note]"},{"location":"advanced/async-sql-databases/#create-notes","text":"Create the path operation function to create notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () notes = sqlalchemy . Table ( \"notes\" , metadata , sqlalchemy . Column ( \"id\" , sqlalchemy . Integer , primary_key = True ), sqlalchemy . Column ( \"text\" , sqlalchemy . String ), sqlalchemy . Column ( \"completed\" , sqlalchemy . Boolean ), ) engine = sqlalchemy . create_engine ( DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) metadata . create_all ( engine ) class NoteIn ( BaseModel ): text : str completed : bool class Note ( BaseModel ): id : int text : str completed : bool app = FastAPI () @app . on_event ( \"startup\" ) async def startup (): await database . connect () @app . on_event ( \"shutdown\" ) async def shutdown (): await database . disconnect () @app . get ( \"/notes/\" , response_model = List [ Note ]) async def read_notes (): query = notes . select () return await database . fetch_all ( query ) @app . post ( \"/notes/\" , response_model = Note ) async def create_note ( note : NoteIn ): query = notes . insert () . values ( text = note . text , completed = note . completed ) last_record_id = await database . execute ( query ) return { ** note . dict (), \"id\" : last_record_id } Note Notice that as we communicate with the database using await , the path operation function is declared with async .","title":"Create notes"},{"location":"advanced/async-sql-databases/#about-notedict-id-last_record_id","text":"note is a Pydantic Note object. note.dict() returns a dict with its data, something like: { \"text\" : \"Some note\" , \"completed\" : False , } but it doesn't have the id field. So we create a new dict , that contains the key-value pairs from note.dict() with: { ** note . dict ()} **note.dict() \"unpacks\" the key value pairs directly, so, {**note.dict()} would be, more or less, a copy of note.dict() . And then, we extend that copy dict , adding another key-value pair: \"id\": last_record_id : { ** note . dict (), \"id\" : last_record_id } So, the final result returned would be something like: { \"id\" : 1 , \"text\" : \"Some note\" , \"completed\" : False , }","title":"About {**note.dict(), \"id\": last_record_id}"},{"location":"advanced/async-sql-databases/#check-it","text":"You can copy this code as is, and see the docs at http://127.0.0.1:8000/docs . There you can see all your API documented and interact with it:","title":"Check it"},{"location":"advanced/async-sql-databases/#more-info","text":"You can read more about encode/databases at its GitHub page .","title":"More info"},{"location":"advanced/custom-request-and-route/","text":"In some cases, you may want to override the logic used by the Request and APIRoute classes. In particular, this may be a good alternative to logic in a middleware. For example, if you want to read or manipulate the request body before it is processed by your application. Danger This is an \"advanced\" feature. If you are just starting with FastAPI you might want to skip this section. Use cases \u00b6 Some use cases include: Converting non-JSON request bodies to JSON (e.g. msgpack ). Decompressing gzip-compressed request bodies. Automatically logging all request bodies. Handling custom request body encodings \u00b6 Let's see how to make use of a custom Request subclass to decompress gzip requests. And an APIRoute subclass to use that custom request class. Create a custom GzipRequest class \u00b6 First, we create a GzipRequest class, which will overwrite the Request.body() method to decompress the body in the presence of an appropriate header. If there's no gzip in the header, it will not try to decompress the body. That way, the same route class can handle gzip compressed or uncompressed requests. import gzip from typing import Callable , List from fastapi import Body , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class GzipRequest ( Request ): async def body ( self ) -> bytes : if not hasattr ( self , \"_body\" ): body = await super () . body () if \"gzip\" in self . headers . getlist ( \"Content-Encoding\" ): body = gzip . decompress ( body ) self . _body = body return self . _body class GzipRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : request = GzipRequest ( request . scope , request . receive ) return await original_route_handler ( request ) return custom_route_handler app = FastAPI () app . router . route_class = GzipRoute @app . post ( \"/sum\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return { \"sum\" : sum ( numbers )} Create a custom GzipRoute class \u00b6 Next, we create a custom subclass of fastapi.routing.APIRoute that will make use of the GzipRequest . This time, it will overwrite the method APIRoute.get_route_handler() . This method returns a function. And that function is what will receive a request and return a response. Here we use it to create a GzipRequest from the original request. import gzip from typing import Callable , List from fastapi import Body , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class GzipRequest ( Request ): async def body ( self ) -> bytes : if not hasattr ( self , \"_body\" ): body = await super () . body () if \"gzip\" in self . headers . getlist ( \"Content-Encoding\" ): body = gzip . decompress ( body ) self . _body = body return self . _body class GzipRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : request = GzipRequest ( request . scope , request . receive ) return await original_route_handler ( request ) return custom_route_handler app = FastAPI () app . router . route_class = GzipRoute @app . post ( \"/sum\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return { \"sum\" : sum ( numbers )} Technical Details A Request has a request.scope attribute, that's just a Python dict containing the metadata related to the request. A Request also has a request.receive , that's a function to \"receive\" the body of the request. The scope dict and receive function are both part of the ASGI specification. And those two things, scope and receive , are what is needed to create a new Request instance. To learn more about the Request check Starlette's docs about Requests . The only thing the function returned by GzipRequest.get_route_handler does differently is convert the Request to a GzipRequest . Doing this, our GzipRequest will take care of decompressing the data (if necessary) before passing it to our path operations . After that, all of the processing logic is the same. But because of our changes in GzipRequest.body , the request body will be automatically decompressed when it is loaded by FastAPI when needed. Accessing the request body in an exception handler \u00b6 Tip To solve this same problem, it's probably a lot easier to use the body in a custom handler for RequestValidationError ( Handling Errors ). But this example is still valid and it shows how to interact with the internal components. We can also use this same approach to access the request body in an exception handler. All we need to do is handle the request inside a try / except block: from typing import Callable , List from fastapi import Body , FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class ValidationErrorLoggingRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : try : return await original_route_handler ( request ) except RequestValidationError as exc : body = await request . body () detail = { \"errors\" : exc . errors (), \"body\" : body . decode ()} raise HTTPException ( status_code = 422 , detail = detail ) return custom_route_handler app = FastAPI () app . router . route_class = ValidationErrorLoggingRoute @app . post ( \"/\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return sum ( numbers ) If an exception occurs, the Request instance will still be in scope, so we can read and make use of the request body when handling the error: from typing import Callable , List from fastapi import Body , FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class ValidationErrorLoggingRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : try : return await original_route_handler ( request ) except RequestValidationError as exc : body = await request . body () detail = { \"errors\" : exc . errors (), \"body\" : body . decode ()} raise HTTPException ( status_code = 422 , detail = detail ) return custom_route_handler app = FastAPI () app . router . route_class = ValidationErrorLoggingRoute @app . post ( \"/\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return sum ( numbers ) Custom APIRoute class in a router \u00b6 You can also set the route_class parameter of an APIRouter : import time from typing import Callable from fastapi import APIRouter , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class TimedRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : before = time . time () response : Response = await original_route_handler ( request ) duration = time . time () - before response . headers [ \"X-Response-Time\" ] = str ( duration ) print ( f \"route duration: {duration} \" ) print ( f \"route response: {response} \" ) print ( f \"route response headers: {response.headers} \" ) return response return custom_route_handler app = FastAPI () router = APIRouter ( route_class = TimedRoute ) @app . get ( \"/\" ) async def not_timed (): return { \"message\" : \"Not timed\" } @router . get ( \"/timed\" ) async def timed (): return { \"message\" : \"It's the time of my life\" } app . include_router ( router ) In this example, the path operations under the router will use the custom TimedRoute class, and will have an extra X-Response-Time header in the response with the time it took to generate the response: import time from typing import Callable from fastapi import APIRouter , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class TimedRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : before = time . time () response : Response = await original_route_handler ( request ) duration = time . time () - before response . headers [ \"X-Response-Time\" ] = str ( duration ) print ( f \"route duration: {duration} \" ) print ( f \"route response: {response} \" ) print ( f \"route response headers: {response.headers} \" ) return response return custom_route_handler app = FastAPI () router = APIRouter ( route_class = TimedRoute ) @app . get ( \"/\" ) async def not_timed (): return { \"message\" : \"Not timed\" } @router . get ( \"/timed\" ) async def timed (): return { \"message\" : \"It's the time of my life\" } app . include_router ( router )","title":"Custom Request and APIRoute class"},{"location":"advanced/custom-request-and-route/#use-cases","text":"Some use cases include: Converting non-JSON request bodies to JSON (e.g. msgpack ). Decompressing gzip-compressed request bodies. Automatically logging all request bodies.","title":"Use cases"},{"location":"advanced/custom-request-and-route/#handling-custom-request-body-encodings","text":"Let's see how to make use of a custom Request subclass to decompress gzip requests. And an APIRoute subclass to use that custom request class.","title":"Handling custom request body encodings"},{"location":"advanced/custom-request-and-route/#create-a-custom-gziprequest-class","text":"First, we create a GzipRequest class, which will overwrite the Request.body() method to decompress the body in the presence of an appropriate header. If there's no gzip in the header, it will not try to decompress the body. That way, the same route class can handle gzip compressed or uncompressed requests. import gzip from typing import Callable , List from fastapi import Body , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class GzipRequest ( Request ): async def body ( self ) -> bytes : if not hasattr ( self , \"_body\" ): body = await super () . body () if \"gzip\" in self . headers . getlist ( \"Content-Encoding\" ): body = gzip . decompress ( body ) self . _body = body return self . _body class GzipRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : request = GzipRequest ( request . scope , request . receive ) return await original_route_handler ( request ) return custom_route_handler app = FastAPI () app . router . route_class = GzipRoute @app . post ( \"/sum\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return { \"sum\" : sum ( numbers )}","title":"Create a custom GzipRequest class"},{"location":"advanced/custom-request-and-route/#create-a-custom-gziproute-class","text":"Next, we create a custom subclass of fastapi.routing.APIRoute that will make use of the GzipRequest . This time, it will overwrite the method APIRoute.get_route_handler() . This method returns a function. And that function is what will receive a request and return a response. Here we use it to create a GzipRequest from the original request. import gzip from typing import Callable , List from fastapi import Body , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class GzipRequest ( Request ): async def body ( self ) -> bytes : if not hasattr ( self , \"_body\" ): body = await super () . body () if \"gzip\" in self . headers . getlist ( \"Content-Encoding\" ): body = gzip . decompress ( body ) self . _body = body return self . _body class GzipRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : request = GzipRequest ( request . scope , request . receive ) return await original_route_handler ( request ) return custom_route_handler app = FastAPI () app . router . route_class = GzipRoute @app . post ( \"/sum\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return { \"sum\" : sum ( numbers )} Technical Details A Request has a request.scope attribute, that's just a Python dict containing the metadata related to the request. A Request also has a request.receive , that's a function to \"receive\" the body of the request. The scope dict and receive function are both part of the ASGI specification. And those two things, scope and receive , are what is needed to create a new Request instance. To learn more about the Request check Starlette's docs about Requests . The only thing the function returned by GzipRequest.get_route_handler does differently is convert the Request to a GzipRequest . Doing this, our GzipRequest will take care of decompressing the data (if necessary) before passing it to our path operations . After that, all of the processing logic is the same. But because of our changes in GzipRequest.body , the request body will be automatically decompressed when it is loaded by FastAPI when needed.","title":"Create a custom GzipRoute class"},{"location":"advanced/custom-request-and-route/#accessing-the-request-body-in-an-exception-handler","text":"Tip To solve this same problem, it's probably a lot easier to use the body in a custom handler for RequestValidationError ( Handling Errors ). But this example is still valid and it shows how to interact with the internal components. We can also use this same approach to access the request body in an exception handler. All we need to do is handle the request inside a try / except block: from typing import Callable , List from fastapi import Body , FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class ValidationErrorLoggingRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : try : return await original_route_handler ( request ) except RequestValidationError as exc : body = await request . body () detail = { \"errors\" : exc . errors (), \"body\" : body . decode ()} raise HTTPException ( status_code = 422 , detail = detail ) return custom_route_handler app = FastAPI () app . router . route_class = ValidationErrorLoggingRoute @app . post ( \"/\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return sum ( numbers ) If an exception occurs, the Request instance will still be in scope, so we can read and make use of the request body when handling the error: from typing import Callable , List from fastapi import Body , FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class ValidationErrorLoggingRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : try : return await original_route_handler ( request ) except RequestValidationError as exc : body = await request . body () detail = { \"errors\" : exc . errors (), \"body\" : body . decode ()} raise HTTPException ( status_code = 422 , detail = detail ) return custom_route_handler app = FastAPI () app . router . route_class = ValidationErrorLoggingRoute @app . post ( \"/\" ) async def sum_numbers ( numbers : List [ int ] = Body ( ... )): return sum ( numbers )","title":"Accessing the request body in an exception handler"},{"location":"advanced/custom-request-and-route/#custom-apiroute-class-in-a-router","text":"You can also set the route_class parameter of an APIRouter : import time from typing import Callable from fastapi import APIRouter , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class TimedRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : before = time . time () response : Response = await original_route_handler ( request ) duration = time . time () - before response . headers [ \"X-Response-Time\" ] = str ( duration ) print ( f \"route duration: {duration} \" ) print ( f \"route response: {response} \" ) print ( f \"route response headers: {response.headers} \" ) return response return custom_route_handler app = FastAPI () router = APIRouter ( route_class = TimedRoute ) @app . get ( \"/\" ) async def not_timed (): return { \"message\" : \"Not timed\" } @router . get ( \"/timed\" ) async def timed (): return { \"message\" : \"It's the time of my life\" } app . include_router ( router ) In this example, the path operations under the router will use the custom TimedRoute class, and will have an extra X-Response-Time header in the response with the time it took to generate the response: import time from typing import Callable from fastapi import APIRouter , FastAPI from fastapi.routing import APIRoute from starlette.requests import Request from starlette.responses import Response class TimedRoute ( APIRoute ): def get_route_handler ( self ) -> Callable : original_route_handler = super () . get_route_handler () async def custom_route_handler ( request : Request ) -> Response : before = time . time () response : Response = await original_route_handler ( request ) duration = time . time () - before response . headers [ \"X-Response-Time\" ] = str ( duration ) print ( f \"route duration: {duration} \" ) print ( f \"route response: {response} \" ) print ( f \"route response headers: {response.headers} \" ) return response return custom_route_handler app = FastAPI () router = APIRouter ( route_class = TimedRoute ) @app . get ( \"/\" ) async def not_timed (): return { \"message\" : \"Not timed\" } @router . get ( \"/timed\" ) async def timed (): return { \"message\" : \"It's the time of my life\" } app . include_router ( router )","title":"Custom APIRoute class in a router"},{"location":"advanced/custom-response/","text":"Warning This is a rather advanced topic. If you are starting with FastAPI , you might not need this. By default, FastAPI will return the responses using Starlette's JSONResponse . You can override it by returning a Response directly as seen in Return a Response directly . But if you return a Response directly, the data won't be automatically converted, and the documentation won't be automatically generated (for example, including the specific \"media type\", in the HTTP header Content-Type ). But you can also declare the Response that you want to be used, in the path operation decorator . The contents that you return from your path operation function will be put inside of that Response . And if that Response has a JSON media type ( application/json ), like is the case with the JSONResponse and UJSONResponse , the data you return will be automatically converted (and filtered) with any Pydantic response_model that you declared in the path operation decorator . Note If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs. Use UJSONResponse \u00b6 For example, if you are squeezing performance, you can install and use ujson and set the response to be Starlette's UJSONResponse . Import the Response class (sub-class) you want to use and declare it in the path operation decorator . from fastapi import FastAPI from starlette.responses import UJSONResponse app = FastAPI () @app . get ( \"/items/\" , response_class = UJSONResponse ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] Note Notice that you import it directly from starlette.responses , not from fastapi . Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to application/json . And it will be documented as such in OpenAPI. HTML Response \u00b6 To return a response with HTML directly from FastAPI , use HTMLResponse . Import HTMLResponse . Pass HTMLResponse as the parameter content_type of your path operation . from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () @app . get ( \"/items/\" , response_class = HTMLResponse ) async def read_items (): return \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" Note Notice that you import it directly from starlette.responses , not from fastapi . Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to text/html . And it will be documented as such in OpenAPI. Return a Starlette Response \u00b6 As seen in Return a Response directly , you can also override the response directly in your path operation , by returning it. The same example from above, returning an HTMLResponse , could look like: from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): html_content = \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" return HTMLResponse ( content = html_content , status_code = 200 ) Warning A Response returned directly by your path operation function won't be documented in OpenAPI (for example, the Content-Type won't be documented) and won't be visible in the automatic interactive docs. Info Of course, the actual Content-Type header, status code, etc, will come from the Response object your returned. Document in OpenAPI and override Response \u00b6 If you want to override the response from inside of the function but at the same time document the \"media type\" in OpenAPI, you can use the response_class parameter AND return a Response object. The response_class will then be used only to document the OpenAPI path operation , but your Response will be used as is. Return an HTMLResponse directly \u00b6 For example, it could be something like: from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () def generate_html_response (): html_content = \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" return HTMLResponse ( content = html_content , status_code = 200 ) @app . get ( \"/items/\" , response_class = HTMLResponse ) async def read_items (): return generate_html_response () In this example, the function generate_html_response() already generates a Starlette Response instead of the HTML in a str . By returning the result of calling generate_html_response() , you are already returning a Response that will override the default FastAPI behavior. But as you passed the HTMLResponse in the response_class , FastAPI will know how to document it in OpenAPI and the interactive docs as HTML with text/html : Additional documentation \u00b6 You can also declare the media type and many other details in OpenAPI using responses : Additional Responses in OpenAPI .","title":"Custom Response Class"},{"location":"advanced/custom-response/#use-ujsonresponse","text":"For example, if you are squeezing performance, you can install and use ujson and set the response to be Starlette's UJSONResponse . Import the Response class (sub-class) you want to use and declare it in the path operation decorator . from fastapi import FastAPI from starlette.responses import UJSONResponse app = FastAPI () @app . get ( \"/items/\" , response_class = UJSONResponse ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] Note Notice that you import it directly from starlette.responses , not from fastapi . Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to application/json . And it will be documented as such in OpenAPI.","title":"Use UJSONResponse"},{"location":"advanced/custom-response/#html-response","text":"To return a response with HTML directly from FastAPI , use HTMLResponse . Import HTMLResponse . Pass HTMLResponse as the parameter content_type of your path operation . from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () @app . get ( \"/items/\" , response_class = HTMLResponse ) async def read_items (): return \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" Note Notice that you import it directly from starlette.responses , not from fastapi . Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to text/html . And it will be documented as such in OpenAPI.","title":"HTML Response"},{"location":"advanced/custom-response/#return-a-starlette-response","text":"As seen in Return a Response directly , you can also override the response directly in your path operation , by returning it. The same example from above, returning an HTMLResponse , could look like: from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): html_content = \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" return HTMLResponse ( content = html_content , status_code = 200 ) Warning A Response returned directly by your path operation function won't be documented in OpenAPI (for example, the Content-Type won't be documented) and won't be visible in the automatic interactive docs. Info Of course, the actual Content-Type header, status code, etc, will come from the Response object your returned.","title":"Return a Starlette Response"},{"location":"advanced/custom-response/#document-in-openapi-and-override-response","text":"If you want to override the response from inside of the function but at the same time document the \"media type\" in OpenAPI, you can use the response_class parameter AND return a Response object. The response_class will then be used only to document the OpenAPI path operation , but your Response will be used as is.","title":"Document in OpenAPI and override Response"},{"location":"advanced/custom-response/#return-an-htmlresponse-directly","text":"For example, it could be something like: from fastapi import FastAPI from starlette.responses import HTMLResponse app = FastAPI () def generate_html_response (): html_content = \"\"\" <html> <head> <title>Some HTML in here</title> </head> <body> <h1>Look ma! HTML!</h1> </body> </html> \"\"\" return HTMLResponse ( content = html_content , status_code = 200 ) @app . get ( \"/items/\" , response_class = HTMLResponse ) async def read_items (): return generate_html_response () In this example, the function generate_html_response() already generates a Starlette Response instead of the HTML in a str . By returning the result of calling generate_html_response() , you are already returning a Response that will override the default FastAPI behavior. But as you passed the HTMLResponse in the response_class , FastAPI will know how to document it in OpenAPI and the interactive docs as HTML with text/html :","title":"Return an HTMLResponse directly"},{"location":"advanced/custom-response/#additional-documentation","text":"You can also declare the media type and many other details in OpenAPI using responses : Additional Responses in OpenAPI .","title":"Additional documentation"},{"location":"advanced/events/","text":"You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down. These functions can be declared with async def or normal def . startup event \u00b6 To add a function that should be run before the application starts, declare it with the event \"startup\" : from fastapi import FastAPI app = FastAPI () items = {} @app . on_event ( \"startup\" ) async def startup_event (): items [ \"foo\" ] = { \"name\" : \"Fighters\" } items [ \"bar\" ] = { \"name\" : \"Tenders\" } @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : str ): return items [ item_id ] In this case, the startup event handler function will initialize the items \"database\" (just a dict ) with some values. You can add more than one event handler function. And your application won't start receiving requests until all the startup event handlers have completed. shutdown event \u00b6 To add a function that should be run when the application is shutting down, declare it with the event \"shutdown\" : from fastapi import FastAPI app = FastAPI () @app . on_event ( \"shutdown\" ) def shutdown_event (): with open ( \"log.txt\" , mode = \"a\" ) as log : log . write ( \"Application shutdown\" ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] Here, the shutdown event handler function will write a text line \"Application shutdown\" to a file log.txt . Info In the open() function, the mode=\"a\" means \"append\", so, the line will be added after whatever is on that file, without overwriting the previous contents. Tip Notice that in this case we are using a standard Python open() function that interacts with a file. So, it involves I/O (input/output), that requires \"waiting\" for things to be written to disk. But open() doesn't use async and await . So, we declare the event handler function with standard def instead of async def . Info You can read more about these event handlers in Starlette's Events' docs .","title":"Events: startup - shutdown"},{"location":"advanced/events/#startup-event","text":"To add a function that should be run before the application starts, declare it with the event \"startup\" : from fastapi import FastAPI app = FastAPI () items = {} @app . on_event ( \"startup\" ) async def startup_event (): items [ \"foo\" ] = { \"name\" : \"Fighters\" } items [ \"bar\" ] = { \"name\" : \"Tenders\" } @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : str ): return items [ item_id ] In this case, the startup event handler function will initialize the items \"database\" (just a dict ) with some values. You can add more than one event handler function. And your application won't start receiving requests until all the startup event handlers have completed.","title":"startup event"},{"location":"advanced/events/#shutdown-event","text":"To add a function that should be run when the application is shutting down, declare it with the event \"shutdown\" : from fastapi import FastAPI app = FastAPI () @app . on_event ( \"shutdown\" ) def shutdown_event (): with open ( \"log.txt\" , mode = \"a\" ) as log : log . write ( \"Application shutdown\" ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] Here, the shutdown event handler function will write a text line \"Application shutdown\" to a file log.txt . Info In the open() function, the mode=\"a\" means \"append\", so, the line will be added after whatever is on that file, without overwriting the previous contents. Tip Notice that in this case we are using a standard Python open() function that interacts with a file. So, it involves I/O (input/output), that requires \"waiting\" for things to be written to disk. But open() doesn't use async and await . So, we declare the event handler function with standard def instead of async def . Info You can read more about these event handlers in Starlette's Events' docs .","title":"shutdown event"},{"location":"advanced/extending-openapi/","text":"Warning This is a rather advanced feature. You probably can skip it. If you are just following the tutorial - user guide, you can probably skip this section. If you already know that you need to modify the generated OpenAPI schema, continue reading. There are some cases where you might need to modify the generated OpenAPI schema. In this section you will see how. The normal process \u00b6 The normal (default) process, is as follows. A FastAPI application (instance) has an .openapi() method that is expected to return the OpenAPI schema. As part of the application object creation, a path operation for /openapi.json (or for whatever you set your openapi_url ) is registered. It just returns a JSON response with the result of the application's .openapi() method. By default, what the method .openapi() does is check the property .openapi_schema to see if it has contents and return them. If it doesn't, it generates them using the utility function at fastapi.openapi.utils.get_openapi . And that function get_openapi() receives as parameters: title : The OpenAPI title, shown in the docs. version : The version of your API, e.g. 2.5.0 . openapi_version : The version of the OpenAPI specification used. By default, the latest: 3.0.2 . description : The description of your API. routes : A list of routes, these are each of the registered path operations . They are taken from app.routes . openapi_prefix : The URL prefix to be used in your OpenAPI. Overriding the defaults \u00b6 Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need. For example, let's add ReDoc's OpenAPI extension to include a custom logo . Normal FastAPI \u00b6 First, write all your FastAPI application as normally: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi Generate the OpenAPI schema \u00b6 Then, use the same utility function to generate the OpenAPI schema, inside a custom_openapi() function: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi Modify the OpenAPI schema \u00b6 Now you can add the ReDoc extension, adding a custom x-logo to the info \"object\" in the OpenAPI schema: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi Cache the OpenAPI schema \u00b6 You can use the property .openapi_schema as a \"cache\", to store your generated schema. That way, your application won't have to generate the schema every time a user opens your API docs. It will be generated only once, and then the same cached schema will be used for the next requests. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi Override the method \u00b6 Now you can replace the .openapi() method with your new function. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi Check it \u00b6 Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, FastAPI 's logo): Self-hosting JavaScript and CSS for docs \u00b6 The API docs use Swagger UI and ReDoc , and each of those need some JavaScript and CSS files. By default, those files are served from a CDN . But it's possible to customize it, you can set a specific CDN, or serve the files yourself. That's useful, for example, if you need your app to keep working even while offline, without open Internet access, or in a local network. Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them. Project file structure \u00b6 Let's say your project file structure looks like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py Now create a directory to store those static files. Your new file structure could look like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 static/ Download the files \u00b6 Download the static files needed for the docs and put them on that static/ directory. You can probably right-click each link and select an option similar to Save link as... . Swagger UI uses the files: swagger-ui-bundle.js swagger-ui.css And ReDoc uses the file: redoc.standalone.js After that, your file structure could look like: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 static \u251c\u2500\u2500 redoc.standalone.js \u251c\u2500\u2500 swagger-ui-bundle.js \u2514\u2500\u2500 swagger-ui.css Install aiofiles \u00b6 Now you need to install aiofiles : pip install aiofiles Serve the static files \u00b6 Import StaticFiles from Starlette. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" } Test the static files \u00b6 Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js . You should see a very long JavaScript file for ReDoc . It could start with something like: /*! * ReDoc - OpenAPI/Swagger-generated API Reference Documentation * ------------------------------------------------------------- * Version: \"2.0.0-rc.18\" * Repo: https://github.com/Redocly/redoc */ ! function ( e , t ){ \"object\" == typeof exports && \"object\" == typeof m ... That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place. Now we can configure the app to use those static files for the docs. Disable the automatic docs \u00b6 The first step is to disable the automatic docs, as those use the CDN by default. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" } Include the custom docs \u00b6 Now you can create the path operations for the custom docs. You can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi_url : the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url . title : the title of your API. oauth2_redirect_url : you can use app.swagger_ui_oauth2_redirect_url here to use the default. swagger_js_url : the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the one that your own app is now serving. swagger_css_url : the URL where the HTML for your Swagger UI docs can get the CSS file. This is the one that your own app is now serving. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" } Tip The path operation for swagger_ui_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper. Create a path operation to test it \u00b6 Now, to be able to test that everything works, create a path operation : from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" } Test it \u00b6 Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs , and reload the page. And even without Internet, you would be able to see the docs for your API and interact with it.","title":"Extending OpenAPI"},{"location":"advanced/extending-openapi/#the-normal-process","text":"The normal (default) process, is as follows. A FastAPI application (instance) has an .openapi() method that is expected to return the OpenAPI schema. As part of the application object creation, a path operation for /openapi.json (or for whatever you set your openapi_url ) is registered. It just returns a JSON response with the result of the application's .openapi() method. By default, what the method .openapi() does is check the property .openapi_schema to see if it has contents and return them. If it doesn't, it generates them using the utility function at fastapi.openapi.utils.get_openapi . And that function get_openapi() receives as parameters: title : The OpenAPI title, shown in the docs. version : The version of your API, e.g. 2.5.0 . openapi_version : The version of the OpenAPI specification used. By default, the latest: 3.0.2 . description : The description of your API. routes : A list of routes, these are each of the registered path operations . They are taken from app.routes . openapi_prefix : The URL prefix to be used in your OpenAPI.","title":"The normal process"},{"location":"advanced/extending-openapi/#overriding-the-defaults","text":"Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need. For example, let's add ReDoc's OpenAPI extension to include a custom logo .","title":"Overriding the defaults"},{"location":"advanced/extending-openapi/#normal-fastapi","text":"First, write all your FastAPI application as normally: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Normal FastAPI"},{"location":"advanced/extending-openapi/#generate-the-openapi-schema","text":"Then, use the same utility function to generate the OpenAPI schema, inside a custom_openapi() function: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Generate the OpenAPI schema"},{"location":"advanced/extending-openapi/#modify-the-openapi-schema","text":"Now you can add the ReDoc extension, adding a custom x-logo to the info \"object\" in the OpenAPI schema: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Modify the OpenAPI schema"},{"location":"advanced/extending-openapi/#cache-the-openapi-schema","text":"You can use the property .openapi_schema as a \"cache\", to store your generated schema. That way, your application won't have to generate the schema every time a user opens your API docs. It will be generated only once, and then the same cached schema will be used for the next requests. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Cache the OpenAPI schema"},{"location":"advanced/extending-openapi/#override-the-method","text":"Now you can replace the .openapi() method with your new function. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) openapi_schema [ \"info\" ][ \"x-logo\" ] = { \"url\" : \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Override the method"},{"location":"advanced/extending-openapi/#check-it","text":"Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, FastAPI 's logo):","title":"Check it"},{"location":"advanced/extending-openapi/#self-hosting-javascript-and-css-for-docs","text":"The API docs use Swagger UI and ReDoc , and each of those need some JavaScript and CSS files. By default, those files are served from a CDN . But it's possible to customize it, you can set a specific CDN, or serve the files yourself. That's useful, for example, if you need your app to keep working even while offline, without open Internet access, or in a local network. Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.","title":"Self-hosting JavaScript and CSS for docs"},{"location":"advanced/extending-openapi/#project-file-structure","text":"Let's say your project file structure looks like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py Now create a directory to store those static files. Your new file structure could look like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 static/","title":"Project file structure"},{"location":"advanced/extending-openapi/#download-the-files","text":"Download the static files needed for the docs and put them on that static/ directory. You can probably right-click each link and select an option similar to Save link as... . Swagger UI uses the files: swagger-ui-bundle.js swagger-ui.css And ReDoc uses the file: redoc.standalone.js After that, your file structure could look like: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 static \u251c\u2500\u2500 redoc.standalone.js \u251c\u2500\u2500 swagger-ui-bundle.js \u2514\u2500\u2500 swagger-ui.css","title":"Download the files"},{"location":"advanced/extending-openapi/#install-aiofiles","text":"Now you need to install aiofiles : pip install aiofiles","title":"Install aiofiles"},{"location":"advanced/extending-openapi/#serve-the-static-files","text":"Import StaticFiles from Starlette. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" }","title":"Serve the static files"},{"location":"advanced/extending-openapi/#test-the-static-files","text":"Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js . You should see a very long JavaScript file for ReDoc . It could start with something like: /*! * ReDoc - OpenAPI/Swagger-generated API Reference Documentation * ------------------------------------------------------------- * Version: \"2.0.0-rc.18\" * Repo: https://github.com/Redocly/redoc */ ! function ( e , t ){ \"object\" == typeof exports && \"object\" == typeof m ... That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place. Now we can configure the app to use those static files for the docs.","title":"Test the static files"},{"location":"advanced/extending-openapi/#disable-the-automatic-docs","text":"The first step is to disable the automatic docs, as those use the CDN by default. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" }","title":"Disable the automatic docs"},{"location":"advanced/extending-openapi/#include-the-custom-docs","text":"Now you can create the path operations for the custom docs. You can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi_url : the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url . title : the title of your API. oauth2_redirect_url : you can use app.swagger_ui_oauth2_redirect_url here to use the default. swagger_js_url : the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the one that your own app is now serving. swagger_css_url : the URL where the HTML for your Swagger UI docs can get the CSS file. This is the one that your own app is now serving. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" } Tip The path operation for swagger_ui_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper.","title":"Include the custom docs"},{"location":"advanced/extending-openapi/#create-a-path-operation-to-test-it","text":"Now, to be able to test that everything works, create a path operation : from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html , get_swagger_ui_html , get_swagger_ui_oauth2_redirect_html , ) from starlette.staticfiles import StaticFiles app = FastAPI ( docs_url = None , redoc_url = None ) app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) @app . get ( \"/docs\" , include_in_schema = False ) async def custom_swagger_ui_html (): return get_swagger_ui_html ( openapi_url = app . openapi_url , title = app . title + \" - Swagger UI\" , oauth2_redirect_url = app . swagger_ui_oauth2_redirect_url , swagger_js_url = \"/static/swagger-ui-bundle.js\" , swagger_css_url = \"/static/swagger-ui.css\" , ) @app . get ( app . swagger_ui_oauth2_redirect_url , include_in_schema = False ) async def swagger_ui_redirect (): return get_swagger_ui_oauth2_redirect_html () @app . get ( \"/redoc\" , include_in_schema = False ) async def redoc_html (): return get_redoc_html ( openapi_url = app . openapi_url , title = app . title + \" - ReDoc\" , redoc_js_url = \"/static/redoc.standalone.js\" , ) @app . get ( \"/users/ {username} \" ) async def read_user ( username : str ): return { \"message\" : f \"Hello {username} \" }","title":"Create a path operation to test it"},{"location":"advanced/extending-openapi/#test-it","text":"Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs , and reload the page. And even without Internet, you would be able to see the docs for your API and interact with it.","title":"Test it"},{"location":"advanced/graphql/","text":"FastAPI has optional support for GraphQL (provided by Starlette directly), using the graphene library. You can combine normal FastAPI path operations with GraphQL on the same application. Import and use graphene \u00b6 GraphQL is implemented with Graphene, you can check Graphene's docs for more details. Import graphene and define your GraphQL data: import graphene from fastapi import FastAPI from starlette.graphql import GraphQLApp class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = FastAPI () app . add_route ( \"/\" , GraphQLApp ( schema = graphene . Schema ( query = Query ))) Add Starlette's GraphQLApp \u00b6 Then import and add Starlette's GraphQLApp : import graphene from fastapi import FastAPI from starlette.graphql import GraphQLApp class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = FastAPI () app . add_route ( \"/\" , GraphQLApp ( schema = graphene . Schema ( query = Query ))) Info Here we are using .add_route , that is the way to add a route in Starlette (inherited by FastAPI) without declaring the specific operation (as would be with .get() , .post() , etc). Check it \u00b6 Run it with Uvicorn and open your browser at http://127.0.0.1:8000 . You will see GraphiQL web user interface: More details \u00b6 For more details, including: Accessing request information Adding background tasks Using normal or async functions check the official Starlette GraphQL docs .","title":"GraphQL"},{"location":"advanced/graphql/#import-and-use-graphene","text":"GraphQL is implemented with Graphene, you can check Graphene's docs for more details. Import graphene and define your GraphQL data: import graphene from fastapi import FastAPI from starlette.graphql import GraphQLApp class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = FastAPI () app . add_route ( \"/\" , GraphQLApp ( schema = graphene . Schema ( query = Query )))","title":"Import and use graphene"},{"location":"advanced/graphql/#add-starlettes-graphqlapp","text":"Then import and add Starlette's GraphQLApp : import graphene from fastapi import FastAPI from starlette.graphql import GraphQLApp class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = FastAPI () app . add_route ( \"/\" , GraphQLApp ( schema = graphene . Schema ( query = Query ))) Info Here we are using .add_route , that is the way to add a route in Starlette (inherited by FastAPI) without declaring the specific operation (as would be with .get() , .post() , etc).","title":"Add Starlette's GraphQLApp"},{"location":"advanced/graphql/#check-it","text":"Run it with Uvicorn and open your browser at http://127.0.0.1:8000 . You will see GraphiQL web user interface:","title":"Check it"},{"location":"advanced/graphql/#more-details","text":"For more details, including: Accessing request information Adding background tasks Using normal or async functions check the official Starlette GraphQL docs .","title":"More details"},{"location":"advanced/nosql-databases/","text":"FastAPI can also be integrated with any NoSQL . Here we'll see an example using Couchbase , a document based NoSQL database. You can adapt it to any other NoSQL database like: MongoDB Cassandra CouchDB ArangoDB ElasticSearch , etc. Tip There is an official project generator with FastAPI and Couchbase , all based on Docker , including a frontend and more tools: https://github.com/tiangolo/full-stack-fastapi-couchbase Import Couchbase components \u00b6 For now, don't pay attention to the rest, only the imports: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Define a constant to use as a \"document type\" \u00b6 We will use it later as a fixed field type in our documents. This is not required by Couchbase, but is a good practice that will help you afterwards. from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Add a function to get a Bucket \u00b6 In Couchbase , a bucket is a set of documents, that can be of different types. They are generally all related to the same application. The analogy in the relational database world would be a \"database\" (a specific database, not the database server). The analogy in MongoDB would be a \"collection\". In the code, a Bucket represents the main entrypoint of communication with the database. This utility function will: Connect to a Couchbase cluster (that might be a single machine). Set defaults for timeouts. Authenticate in the cluster. Get a Bucket instance. Set defaults for timeouts. Return it. from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Create Pydantic models \u00b6 As Couchbase \"documents\" are actually just \"JSON objects\", we can model them with Pydantic. User model \u00b6 First, let's create a User model: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user We will use this model in our path operation function , so, we don't include in it the hashed_password . UserInDB model \u00b6 Now, let's create a UserInDB model. This will have the data that is actually stored in the database. We don't create it as a subclass of Pydantic's BaseModel but as a subclass of our own User , because it will have all the attributes in User plus a couple more: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Note Notice that we have a hashed_password and a type field that will be stored in the database. But it is not part of the general User model (the one we will return in the path operation ). Get the user \u00b6 Now create a function that will: Take a username. Generate a document ID from it. Get the document with that ID. Put the contents of the document in a UserInDB model. By creating a function that is only dedicated to getting your user from a username (or any other parameter) independent of your path operation function , you can more easily re-use it in multiple parts and also add unit tests for it: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user f-strings \u00b6 If you are not familiar with the f\"userprofile::{username}\" , it is a Python \" f-string \". Any variable that is put inside of {} in an f-string will be expanded / injected in the string. dict unpacking \u00b6 If you are not familiar with the UserInDB(**result.value) , it is using dict \"unpacking\" . It will take the dict at result.value , and take each of its keys and values and pass them as key-values to UserInDB as keyword arguments. So, if the dict contains: { \"username\" : \"johndoe\" , \"hashed_password\" : \"some_hash\" , } It will be passed to UserInDB as: UserInDB ( username = \"johndoe\" , hashed_password = \"some_hash\" ) Create your FastAPI code \u00b6 Create the FastAPI app \u00b6 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Create the path operation function \u00b6 As our code is calling Couchbase and we are not using the experimental Python await support , we should declare our function with normal def instead of async def . Also, Couchbase recommends not using a single Bucket object in multiple \" thread s\", so, we can get just get the bucket directly and pass it to our utility functions: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Recap \u00b6 You can integrate any third party NoSQL database, just using their standard packages. The same applies to any other external tool, system or API.","title":"NoSQL (Distributed / Big Data) Databases"},{"location":"advanced/nosql-databases/#import-couchbase-components","text":"For now, don't pay attention to the rest, only the imports: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Import Couchbase components"},{"location":"advanced/nosql-databases/#define-a-constant-to-use-as-a-document-type","text":"We will use it later as a fixed field type in our documents. This is not required by Couchbase, but is a good practice that will help you afterwards. from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Define a constant to use as a \"document type\""},{"location":"advanced/nosql-databases/#add-a-function-to-get-a-bucket","text":"In Couchbase , a bucket is a set of documents, that can be of different types. They are generally all related to the same application. The analogy in the relational database world would be a \"database\" (a specific database, not the database server). The analogy in MongoDB would be a \"collection\". In the code, a Bucket represents the main entrypoint of communication with the database. This utility function will: Connect to a Couchbase cluster (that might be a single machine). Set defaults for timeouts. Authenticate in the cluster. Get a Bucket instance. Set defaults for timeouts. Return it. from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Add a function to get a Bucket"},{"location":"advanced/nosql-databases/#create-pydantic-models","text":"As Couchbase \"documents\" are actually just \"JSON objects\", we can model them with Pydantic.","title":"Create Pydantic models"},{"location":"advanced/nosql-databases/#user-model","text":"First, let's create a User model: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user We will use this model in our path operation function , so, we don't include in it the hashed_password .","title":"User model"},{"location":"advanced/nosql-databases/#userindb-model","text":"Now, let's create a UserInDB model. This will have the data that is actually stored in the database. We don't create it as a subclass of Pydantic's BaseModel but as a subclass of our own User , because it will have all the attributes in User plus a couple more: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user Note Notice that we have a hashed_password and a type field that will be stored in the database. But it is not part of the general User model (the one we will return in the path operation ).","title":"UserInDB model"},{"location":"advanced/nosql-databases/#get-the-user","text":"Now create a function that will: Take a username. Generate a document ID from it. Get the document with that ID. Put the contents of the document in a UserInDB model. By creating a function that is only dedicated to getting your user from a username (or any other parameter) independent of your path operation function , you can more easily re-use it in multiple parts and also add unit tests for it: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Get the user"},{"location":"advanced/nosql-databases/#f-strings","text":"If you are not familiar with the f\"userprofile::{username}\" , it is a Python \" f-string \". Any variable that is put inside of {} in an f-string will be expanded / injected in the string.","title":"f-strings"},{"location":"advanced/nosql-databases/#dict-unpacking","text":"If you are not familiar with the UserInDB(**result.value) , it is using dict \"unpacking\" . It will take the dict at result.value , and take each of its keys and values and pass them as key-values to UserInDB as keyword arguments. So, if the dict contains: { \"username\" : \"johndoe\" , \"hashed_password\" : \"some_hash\" , } It will be passed to UserInDB as: UserInDB ( username = \"johndoe\" , hashed_password = \"some_hash\" )","title":"dict unpacking"},{"location":"advanced/nosql-databases/#create-your-fastapi-code","text":"","title":"Create your FastAPI code"},{"location":"advanced/nosql-databases/#create-the-fastapi-app","text":"from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Create the FastAPI app"},{"location":"advanced/nosql-databases/#create-the-path-operation-function","text":"As our code is calling Couchbase and we are not using the experimental Python await support , we should declare our function with normal def instead of async def . Also, Couchbase recommends not using a single Bucket object in multiple \" thread s\", so, we can get just get the bucket directly and pass it to our utility functions: from typing import Optional from fastapi import FastAPI from pydantic import BaseModel from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster , PasswordAuthenticator USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket (): cluster = Cluster ( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator ( \"username\" , \"password\" ) cluster . authenticate ( authenticator ) bucket : Bucket = cluster . open_bucket ( \"bucket_name\" , lockmode = LOCKMODE_WAIT ) bucket . timeout = 30 bucket . n1ql_timeout = 300 return bucket class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None class UserInDB ( User ): type : str = USERPROFILE_DOC_TYPE hashed_password : str def get_user ( bucket : Bucket , username : str ): doc_id = f \"userprofile:: {username} \" result = bucket . get ( doc_id , quiet = True ) if not result . value : return None user = UserInDB ( ** result . value ) return user # FastAPI specific code app = FastAPI () @app . get ( \"/users/ {username} \" , response_model = User ) def read_user ( username : str ): bucket = get_bucket () user = get_user ( bucket = bucket , username = username ) return user","title":"Create the path operation function"},{"location":"advanced/nosql-databases/#recap","text":"You can integrate any third party NoSQL database, just using their standard packages. The same applies to any other external tool, system or API.","title":"Recap"},{"location":"advanced/openapi-callbacks/","text":"You could create an API with a path operation that could trigger a request to an external API created by someone else (probably the same developer that would be using your API). The process that happens when your API app calls the external API is named a \"callback\". Because the software that the external developer wrote sends a request to your API and then your API calls back , sending a request to an external API (that was probably created by the same developer). In this case, you could want to document how that external API should look like. What path operation it should have, what body it should expect, what response it should return, etc. An app with callbacks \u00b6 Let's see all this with an example. Imagine you develop an app that allows creating invoices. These invoices will have an id , title (optional), customer , and total . The user of your API (an external developer) will create an invoice in your API with a POST request. Then your API will (let's imagine): Send the invoice to some customer of the external developer. Collect the money. Send a notification back to the API user (the external developer). This will be done by sending a POST request (from your API ) to some external API provided by that external developer (this is the \"callback\"). The normal FastAPI app \u00b6 Let's first see how the normal API app would look like before adding the callback. It will have a path operation that will receive an Invoice body, and a query parameter callback_url that will contain the URL for the callback. This part is pretty normal, most of the code is probably already familiar to you: from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } Tip The callback_url query parameter uses a Pydantic URL type. The only new thing is the callbacks=messages_callback_router.routes as an argument to the path operation decorator . We'll see what that is next. Documenting the callback \u00b6 The actual callback code will depend heavily on your own API app. And it will probably vary a lot from one app to the next. It could be just one or two lines of code, like: callback_url = \"https://example.com/api/v1/invoices/events/\" requests . post ( callback_url , json = { \"description\" : \"Invoice paid\" , \"paid\" : True }) But possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc. So, what we will do next is add the code to document how that external API should look like to receive the callback from your API . That documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API . This example doesn't implement the callback itself (that could be just a line of code), only the documentation part. Tip The actual callback is just an HTTP request. When implementing the callback yourself, you could use something like HTTPX or Requests . Write the callback documentation code \u00b6 This code won't be executed in your app, we only need it to document how that external API should look like. But, you already know how to easily create automatic documentation for an API with FastAPI . So we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call). Tip When writing the code to document a callback, it might be useful to imagine that you are that external developer . And that you are currently implementing the external API , not your API . Temporarily adopting this point of view (of the external developer ) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API . Create a callback APIRouter \u00b6 First create a new APIRouter that will contain one or more callbacks. This router will never be added to an actual FastAPI app (i.e. it will never be passed to app.include_router(...) ). Because of that, you need to declare what will be the default_response_class , and set it to JSONResponse . Technical Details The response_class is normally set by the FastAPI app during the call to app.include_router(some_router) . But as we are never calling app.include_router(some_router) , we need to set the default_response_class during creation of the APIRouter . from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } Create the callback path operation \u00b6 To create the callback path operation use the same APIRouter you created above. It should look just like a normal FastAPI path operation : It should probably have a declaration of the body it should receive, e.g. body: InvoiceEvent . And it could also have a declaration of the response it should return, e.g. response_model=InvoiceEventReceived . from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } There are 2 main differences from a normal path operation : It doesn't need to have any actual code, because your app will never call this code. It's only used to document the external API . So, the function could just have pass . The path can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to your API . The callback path expression \u00b6 The callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API . In this case, it's the str : \"{$callback_url}/invoices/{$request.body.id}\" So, if your API user (the external developer) sends a request to your API to: https://yourapi.com/invoices/?callback_url=https://www.external.org/events with a JSON body of: { \"id\" : \"2expen51ve\" , \"customer\" : \"Mr. Richie Rich\" , \"total\" : \"9999\" } Then your API will process the invoice, and at some point later, send a callback request to the callback_url (the external API ): https://www.external.org/events/invoices/2expen51ve with a JSON body containing something like: { \"description\" : \"Payment celebration\" , \"paid\" : true } and it would expect a response from that external API with a JSON body like: { \"ok\" : true } Tip Notice how the callback URL used contains the URL received as a query parameter in callback_url ( https://www.external.org/events ) and also the invoice id from inside of the JSON body ( 2expen51ve ). Add the callback router \u00b6 At this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API ) in the callback router you created above. Now use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/ path operations ) from that callback router: from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } Tip Notice that you are not passing the router itself ( invoices_callback_router ) to callback= , but the attribute .routes , as in invoices_callback_router.routes . Check the docs \u00b6 Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs . You will see your docs including a \"Callback\" section for your path operation that shows how the external API should look like:","title":"OpenAPI Callbacks"},{"location":"advanced/openapi-callbacks/#an-app-with-callbacks","text":"Let's see all this with an example. Imagine you develop an app that allows creating invoices. These invoices will have an id , title (optional), customer , and total . The user of your API (an external developer) will create an invoice in your API with a POST request. Then your API will (let's imagine): Send the invoice to some customer of the external developer. Collect the money. Send a notification back to the API user (the external developer). This will be done by sending a POST request (from your API ) to some external API provided by that external developer (this is the \"callback\").","title":"An app with callbacks"},{"location":"advanced/openapi-callbacks/#the-normal-fastapi-app","text":"Let's first see how the normal API app would look like before adding the callback. It will have a path operation that will receive an Invoice body, and a query parameter callback_url that will contain the URL for the callback. This part is pretty normal, most of the code is probably already familiar to you: from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } Tip The callback_url query parameter uses a Pydantic URL type. The only new thing is the callbacks=messages_callback_router.routes as an argument to the path operation decorator . We'll see what that is next.","title":"The normal FastAPI app"},{"location":"advanced/openapi-callbacks/#documenting-the-callback","text":"The actual callback code will depend heavily on your own API app. And it will probably vary a lot from one app to the next. It could be just one or two lines of code, like: callback_url = \"https://example.com/api/v1/invoices/events/\" requests . post ( callback_url , json = { \"description\" : \"Invoice paid\" , \"paid\" : True }) But possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc. So, what we will do next is add the code to document how that external API should look like to receive the callback from your API . That documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API . This example doesn't implement the callback itself (that could be just a line of code), only the documentation part. Tip The actual callback is just an HTTP request. When implementing the callback yourself, you could use something like HTTPX or Requests .","title":"Documenting the callback"},{"location":"advanced/openapi-callbacks/#write-the-callback-documentation-code","text":"This code won't be executed in your app, we only need it to document how that external API should look like. But, you already know how to easily create automatic documentation for an API with FastAPI . So we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call). Tip When writing the code to document a callback, it might be useful to imagine that you are that external developer . And that you are currently implementing the external API , not your API . Temporarily adopting this point of view (of the external developer ) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API .","title":"Write the callback documentation code"},{"location":"advanced/openapi-callbacks/#create-a-callback-apirouter","text":"First create a new APIRouter that will contain one or more callbacks. This router will never be added to an actual FastAPI app (i.e. it will never be passed to app.include_router(...) ). Because of that, you need to declare what will be the default_response_class , and set it to JSONResponse . Technical Details The response_class is normally set by the FastAPI app during the call to app.include_router(some_router) . But as we are never calling app.include_router(some_router) , we need to set the default_response_class during creation of the APIRouter . from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" }","title":"Create a callback APIRouter"},{"location":"advanced/openapi-callbacks/#create-the-callback-path-operation","text":"To create the callback path operation use the same APIRouter you created above. It should look just like a normal FastAPI path operation : It should probably have a declaration of the body it should receive, e.g. body: InvoiceEvent . And it could also have a declaration of the response it should return, e.g. response_model=InvoiceEventReceived . from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } There are 2 main differences from a normal path operation : It doesn't need to have any actual code, because your app will never call this code. It's only used to document the external API . So, the function could just have pass . The path can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to your API .","title":"Create the callback path operation"},{"location":"advanced/openapi-callbacks/#the-callback-path-expression","text":"The callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API . In this case, it's the str : \"{$callback_url}/invoices/{$request.body.id}\" So, if your API user (the external developer) sends a request to your API to: https://yourapi.com/invoices/?callback_url=https://www.external.org/events with a JSON body of: { \"id\" : \"2expen51ve\" , \"customer\" : \"Mr. Richie Rich\" , \"total\" : \"9999\" } Then your API will process the invoice, and at some point later, send a callback request to the callback_url (the external API ): https://www.external.org/events/invoices/2expen51ve with a JSON body containing something like: { \"description\" : \"Payment celebration\" , \"paid\" : true } and it would expect a response from that external API with a JSON body like: { \"ok\" : true } Tip Notice how the callback URL used contains the URL received as a query parameter in callback_url ( https://www.external.org/events ) and also the invoice id from inside of the JSON body ( 2expen51ve ).","title":"The callback path expression"},{"location":"advanced/openapi-callbacks/#add-the-callback-router","text":"At this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API ) in the callback router you created above. Now use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/ path operations ) from that callback router: from fastapi import APIRouter , FastAPI from pydantic import BaseModel , HttpUrl from starlette.responses import JSONResponse app = FastAPI () class Invoice ( BaseModel ): id : str title : str = None customer : str total : float class InvoiceEvent ( BaseModel ): description : str paid : bool class InvoiceEventReceived ( BaseModel ): ok : bool invoices_callback_router = APIRouter ( default_response_class = JSONResponse ) @invoices_callback_router . post ( \"{$callback_url}/invoices/{$request.body.id}\" , response_model = InvoiceEventReceived , ) def invoice_notification ( body : InvoiceEvent ): pass @app . post ( \"/invoices/\" , callbacks = invoices_callback_router . routes ) def create_invoice ( invoice : Invoice , callback_url : HttpUrl = None ): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return { \"msg\" : \"Invoice received\" } Tip Notice that you are not passing the router itself ( invoices_callback_router ) to callback= , but the attribute .routes , as in invoices_callback_router.routes .","title":"Add the callback router"},{"location":"advanced/openapi-callbacks/#check-the-docs","text":"Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs . You will see your docs including a \"Callback\" section for your path operation that shows how the external API should look like:","title":"Check the docs"},{"location":"advanced/path-operation-advanced-configuration/","text":"OpenAPI operationId \u00b6 Warning If you are not an \"expert\" in OpenAPI, you probably don't need this. You can set the OpenAPI operationId to be used in your path operation with the parameter operation_id . You would have to make sure that it is unique for each operation. from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , operation_id = \"some_specific_id_you_define\" ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] Using the path operation function name as the operationId \u00b6 If you want to use your APIs' function names as operationId s, you can iterate over all of them and override each path operation's operation_id using their APIRoute.name . You should do it after adding all your path operations . from fastapi import FastAPI from fastapi.routing import APIRoute app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] def use_route_names_as_operation_ids ( app : FastAPI ) -> None : \"\"\" Simplify operation IDs so that generated API clients have simpler function names. Should be called only after all routes have been added. \"\"\" for route in app . routes : if isinstance ( route , APIRoute ): route . operation_id = route . name # in this case, 'read_items' use_route_names_as_operation_ids ( app ) Tip If you manually call app.openapi() , you should update the operationId s before that. Warning If you do this, you have to make sure each one of your path operation functions has a unique name. Even if they are in different modules (Python files). Exclude from OpenAPI \u00b6 To exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include_in_schema and set it to False ; from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , include_in_schema = False ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] Advanced description from docstring \u00b6 You can limit the lines used from the docstring of a path operation function for OpenAPI. Adding an \\f (an escaped \"form feed\" character) causes FastAPI to truncate the output used for OpenAPI at this point. It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest. from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \\f :param item: User input. \"\"\" return item","title":"Path Operation Advanced Configuration"},{"location":"advanced/path-operation-advanced-configuration/#openapi-operationid","text":"Warning If you are not an \"expert\" in OpenAPI, you probably don't need this. You can set the OpenAPI operationId to be used in your path operation with the parameter operation_id . You would have to make sure that it is unique for each operation. from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , operation_id = \"some_specific_id_you_define\" ) async def read_items (): return [{ \"item_id\" : \"Foo\" }]","title":"OpenAPI operationId"},{"location":"advanced/path-operation-advanced-configuration/#using-the-path-operation-function-name-as-the-operationid","text":"If you want to use your APIs' function names as operationId s, you can iterate over all of them and override each path operation's operation_id using their APIRoute.name . You should do it after adding all your path operations . from fastapi import FastAPI from fastapi.routing import APIRoute app = FastAPI () @app . get ( \"/items/\" ) async def read_items (): return [{ \"item_id\" : \"Foo\" }] def use_route_names_as_operation_ids ( app : FastAPI ) -> None : \"\"\" Simplify operation IDs so that generated API clients have simpler function names. Should be called only after all routes have been added. \"\"\" for route in app . routes : if isinstance ( route , APIRoute ): route . operation_id = route . name # in this case, 'read_items' use_route_names_as_operation_ids ( app ) Tip If you manually call app.openapi() , you should update the operationId s before that. Warning If you do this, you have to make sure each one of your path operation functions has a unique name. Even if they are in different modules (Python files).","title":"Using the path operation function name as the operationId"},{"location":"advanced/path-operation-advanced-configuration/#exclude-from-openapi","text":"To exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include_in_schema and set it to False ; from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , include_in_schema = False ) async def read_items (): return [{ \"item_id\" : \"Foo\" }]","title":"Exclude from OpenAPI"},{"location":"advanced/path-operation-advanced-configuration/#advanced-description-from-docstring","text":"You can limit the lines used from the docstring of a path operation function for OpenAPI. Adding an \\f (an escaped \"form feed\" character) causes FastAPI to truncate the output used for OpenAPI at this point. It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest. from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \\f :param item: User input. \"\"\" return item","title":"Advanced description from docstring"},{"location":"advanced/response-change-status-code/","text":"You probably read before that you can set a default Response Status Code . But in some cases you need to return a different status code than the default. Use case \u00b6 For example, imagine that you want to return an HTTP status code of \"OK\" 200 by default. But if the data didn't exist, you want to create it, and return an HTTP status code of \"CREATED\" 201 . But you still want to be able to filter and convert the data you return with a response_model . For those cases, you can use a Response parameter. Use a Response parameter \u00b6 You can declare a parameter of type Response in your path operation function (as you can do for cookies and headers). And then you can set the status_code in that temporal response object. from fastapi import FastAPI from starlette.responses import Response from starlette.status import HTTP_201_CREATED app = FastAPI () tasks = { \"foo\" : \"Listen to the Bar Fighters\" } @app . put ( \"/get-or-create-task/ {task_id} \" , status_code = 200 ) def get_or_create_task ( task_id : str , response : Response ): if task_id not in tasks : tasks [ task_id ] = \"This didn't exist before\" response . status_code = HTTP_201_CREATED return tasks [ task_id ] And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set the status code in them. But have in mind that the last one to be set will win.","title":"Response - Change Status Code"},{"location":"advanced/response-change-status-code/#use-case","text":"For example, imagine that you want to return an HTTP status code of \"OK\" 200 by default. But if the data didn't exist, you want to create it, and return an HTTP status code of \"CREATED\" 201 . But you still want to be able to filter and convert the data you return with a response_model . For those cases, you can use a Response parameter.","title":"Use case"},{"location":"advanced/response-change-status-code/#use-a-response-parameter","text":"You can declare a parameter of type Response in your path operation function (as you can do for cookies and headers). And then you can set the status_code in that temporal response object. from fastapi import FastAPI from starlette.responses import Response from starlette.status import HTTP_201_CREATED app = FastAPI () tasks = { \"foo\" : \"Listen to the Bar Fighters\" } @app . put ( \"/get-or-create-task/ {task_id} \" , status_code = 200 ) def get_or_create_task ( task_id : str , response : Response ): if task_id not in tasks : tasks [ task_id ] = \"This didn't exist before\" response . status_code = HTTP_201_CREATED return tasks [ task_id ] And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set the status code in them. But have in mind that the last one to be set will win.","title":"Use a Response parameter"},{"location":"advanced/response-cookies/","text":"Use a Response parameter \u00b6 You can declare a parameter of type Response in your path operation function . And then you can set headers in that temporal response object. from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . post ( \"/cookie-and-object/\" ) def create_cookie ( response : Response ): response . set_cookie ( key = \"fakesession\" , value = \"fake-cookie-session-value\" ) return { \"message\" : \"Come to the dark side, we have cookies\" } And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set cookies (and headers) in them. Return a Response directly \u00b6 You can also create cookies when returning a Response directly in your code. To do that, you can create a response as described in Return a Response Directly . Then set Cookies in it, and then return it: from fastapi import FastAPI from starlette.responses import JSONResponse app = FastAPI () @app . post ( \"/cookie/\" ) def create_cookie (): content = { \"message\" : \"Come to the dark side, we have cookies\" } response = JSONResponse ( content = content ) response . set_cookie ( key = \"fakesession\" , value = \"fake-cookie-session-value\" ) return response Tip Have in mind that if you return a response directly instead of using the Response parameter, FastAPI will return it directly. So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a JSONResponse . And also that you are not sending any data that should have been filtered by a response_model . More info \u00b6 To see all the available parameters and options, check the documentation in Starlette .","title":"Response Cookies"},{"location":"advanced/response-cookies/#use-a-response-parameter","text":"You can declare a parameter of type Response in your path operation function . And then you can set headers in that temporal response object. from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . post ( \"/cookie-and-object/\" ) def create_cookie ( response : Response ): response . set_cookie ( key = \"fakesession\" , value = \"fake-cookie-session-value\" ) return { \"message\" : \"Come to the dark side, we have cookies\" } And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set cookies (and headers) in them.","title":"Use a Response parameter"},{"location":"advanced/response-cookies/#return-a-response-directly","text":"You can also create cookies when returning a Response directly in your code. To do that, you can create a response as described in Return a Response Directly . Then set Cookies in it, and then return it: from fastapi import FastAPI from starlette.responses import JSONResponse app = FastAPI () @app . post ( \"/cookie/\" ) def create_cookie (): content = { \"message\" : \"Come to the dark side, we have cookies\" } response = JSONResponse ( content = content ) response . set_cookie ( key = \"fakesession\" , value = \"fake-cookie-session-value\" ) return response Tip Have in mind that if you return a response directly instead of using the Response parameter, FastAPI will return it directly. So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a JSONResponse . And also that you are not sending any data that should have been filtered by a response_model .","title":"Return a Response directly"},{"location":"advanced/response-cookies/#more-info","text":"To see all the available parameters and options, check the documentation in Starlette .","title":"More info"},{"location":"advanced/response-directly/","text":"When you create a FastAPI path operation you can normally return any data from it: a dict , a list , a Pydantic model, a database model, etc. By default, FastAPI would automatically convert that return value to JSON using the jsonable_encoder explained in JSON Compatible Encoder . Then, behind the scenes, it would put that JSON-compatible data (e.g. a dict ) inside of a Starlette JSONResponse that would be used to send the response to the client. But you can return a JSONResponse directly from your path operations . It might be useful, for example, to return custom headers or cookies. Starlette Response \u00b6 In fact, you can return any Starlette Response or any sub-class of it. Tip JSONResponse itself is a sub-class of Response . And when you return a Starlette Response , FastAPI will pass it directly. It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc. This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc. Using the jsonable_encoder in a Response \u00b6 Because FastAPI doesn't do any change to a Response you return, you have to make sure it's contents are ready for it. For example, you cannot put a Pydantic model in a JSONResponse without first converting it to a dict with all the data types (like datetime , UUID , etc) converted to JSON-compatible types. For those cases, you can use the jsonable_encoder to convert your data before passing it to a response: from datetime import datetime from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): title : str timestamp : datetime description : str = None app = FastAPI () @app . put ( \"/items/ {id} \" ) def update_item ( id : str , item : Item ): json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = json_compatible_item_data ) Note Notice that you import it directly from starlette.responses , not from fastapi . Returning a custom Response \u00b6 The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the item directly, and FastAPI would put it in a JSONResponse for you, converting it to a dict , etc. All that by default. Now, let's see how you could use that to return a custom response. Let's say you want to return a response that is not available in the default Starlette Response s . Let's say that you want to return XML . You could put your XML content in a string, put it in a Starlette Response, and return it: from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . get ( \"/legacy/\" ) def get_legacy_data (): data = \"\"\"<?xml version=\"1.0\"?> <shampoo> <Header> Apply shampoo here. </Header> <Body> You'll have to use soap here. </Body> </shampoo> \"\"\" return Response ( content = data , media_type = \"application/xml\" ) Notes \u00b6 When you return a Response directly its data is not validated, converted (serialized), nor documented automatically. But you can still document it as described in Additional Responses in OpenAPI . You can see in later sections how to use/declare these custom Response s while still having automatic data conversion, documentation, etc.","title":"Return a Response Directly"},{"location":"advanced/response-directly/#starlette-response","text":"In fact, you can return any Starlette Response or any sub-class of it. Tip JSONResponse itself is a sub-class of Response . And when you return a Starlette Response , FastAPI will pass it directly. It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc. This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.","title":"Starlette Response"},{"location":"advanced/response-directly/#using-the-jsonable_encoder-in-a-response","text":"Because FastAPI doesn't do any change to a Response you return, you have to make sure it's contents are ready for it. For example, you cannot put a Pydantic model in a JSONResponse without first converting it to a dict with all the data types (like datetime , UUID , etc) converted to JSON-compatible types. For those cases, you can use the jsonable_encoder to convert your data before passing it to a response: from datetime import datetime from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel from starlette.responses import JSONResponse class Item ( BaseModel ): title : str timestamp : datetime description : str = None app = FastAPI () @app . put ( \"/items/ {id} \" ) def update_item ( id : str , item : Item ): json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = json_compatible_item_data ) Note Notice that you import it directly from starlette.responses , not from fastapi .","title":"Using the jsonable_encoder in a Response"},{"location":"advanced/response-directly/#returning-a-custom-response","text":"The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the item directly, and FastAPI would put it in a JSONResponse for you, converting it to a dict , etc. All that by default. Now, let's see how you could use that to return a custom response. Let's say you want to return a response that is not available in the default Starlette Response s . Let's say that you want to return XML . You could put your XML content in a string, put it in a Starlette Response, and return it: from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . get ( \"/legacy/\" ) def get_legacy_data (): data = \"\"\"<?xml version=\"1.0\"?> <shampoo> <Header> Apply shampoo here. </Header> <Body> You'll have to use soap here. </Body> </shampoo> \"\"\" return Response ( content = data , media_type = \"application/xml\" )","title":"Returning a custom Response"},{"location":"advanced/response-directly/#notes","text":"When you return a Response directly its data is not validated, converted (serialized), nor documented automatically. But you can still document it as described in Additional Responses in OpenAPI . You can see in later sections how to use/declare these custom Response s while still having automatic data conversion, documentation, etc.","title":"Notes"},{"location":"advanced/response-headers/","text":"Use a Response parameter \u00b6 You can declare a parameter of type Response in your path operation function (as you can do for cookies). And then you can set headers in that temporal response object. from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . get ( \"/headers-and-object/\" ) def get_headers ( response : Response ): response . headers [ \"X-Cat-Dog\" ] = \"alone in the world\" return { \"message\" : \"Hello World\" } And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set headers (and cookies) in them. Return a Response directly \u00b6 You can also add headers when you return a Response directly. Create a response as described in Return a Response Directly and pass the headers as an additional parameter: from fastapi import FastAPI from starlette.responses import JSONResponse app = FastAPI () @app . get ( \"/headers/\" ) def get_headers (): content = { \"message\" : \"Hello World\" } headers = { \"X-Cat-Dog\" : \"alone in the world\" , \"Content-Language\" : \"en-US\" } return JSONResponse ( content = content , headers = headers ) Custom Headers \u00b6 Have in mind that custom proprietary headers can be added using the 'X-' prefix . But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing) ), using the parameter expose_headers documented in Starlette's CORS docs .","title":"Response Headers"},{"location":"advanced/response-headers/#use-a-response-parameter","text":"You can declare a parameter of type Response in your path operation function (as you can do for cookies). And then you can set headers in that temporal response object. from fastapi import FastAPI from starlette.responses import Response app = FastAPI () @app . get ( \"/headers-and-object/\" ) def get_headers ( response : Response ): response . headers [ \"X-Cat-Dog\" ] = \"alone in the world\" return { \"message\" : \"Hello World\" } And then you can return any object you need, as you normally would (a dict , a database model, etc). And if you declared a response_model , it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any response_model . You can also declare the Response parameter in dependencies, and set headers (and cookies) in them.","title":"Use a Response parameter"},{"location":"advanced/response-headers/#return-a-response-directly","text":"You can also add headers when you return a Response directly. Create a response as described in Return a Response Directly and pass the headers as an additional parameter: from fastapi import FastAPI from starlette.responses import JSONResponse app = FastAPI () @app . get ( \"/headers/\" ) def get_headers (): content = { \"message\" : \"Hello World\" } headers = { \"X-Cat-Dog\" : \"alone in the world\" , \"Content-Language\" : \"en-US\" } return JSONResponse ( content = content , headers = headers )","title":"Return a Response directly"},{"location":"advanced/response-headers/#custom-headers","text":"Have in mind that custom proprietary headers can be added using the 'X-' prefix . But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing) ), using the parameter expose_headers documented in Starlette's CORS docs .","title":"Custom Headers"},{"location":"advanced/sql-databases-peewee/","text":"Warning If you are just starting, the tutorial SQL (Relational) Databases that uses SQLAlchemy should be enough. Feel free to skip this. If you are starting a project from scratch, you are probably better off with SQLAlchemy ORM ( SQL (Relational) Databases ), or any other async ORM. If you already have a code base that uses Peewee ORM , you can check here how to use it with FastAPI . Python 3.7+ required You will need Python 3.7 or above to safely use Peewee with FastAPI. Peewee for async \u00b6 Peewee was not designed for async frameworks, or with them in mind. Peewee has some heavy assumptions about its defaults and about how it should be used. If you are developing an application with an older non-async framework, and can work with all its defaults, it can be a great tool . But if you need to change some of the defaults, support more than one predefined database, work with an async framework (like FastAPI), etc, you will need to add quite some complex extra code to override those defaults. Nevertheless, it's possible to do it, and here you'll see exactly what code you have to add to be able to use Peewee with FastAPI. Technical Details You can read more about Peewee's stand about async in Python in the docs , an issue , a PR . The same app \u00b6 We are going to create the same application as in the SQLAlchemy tutorial ( SQL (Relational) Databases ). Most of the code is actually the same. So, we are going to focus only on the differences. File structure \u00b6 Let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this: . \u2514\u2500\u2500 sql_app \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 crud.py \u251c\u2500\u2500 database.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 schemas.py This is almost the same structure as we had for the SQLAlchemy tutorial. Now let's see what each file/module does. Create the Peewee parts \u00b6 Let's refer to the file sql_app/database.py . The standard Peewee code \u00b6 Let's first check all the normal Peewee code, create a Peewee database: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () Tip Have in mind that if you wanted to use a different database, like PostgreSQL, you couldn't just change the string. You would need to use a different Peewee database class. Note \u00b6 The argument: check_same_thread = False is equivalent to the one in the SQLAlchemy tutorial: connect_args = { \"check_same_thread\" : False } ...it is needed only for SQLite . Technical Details Exactly the same technical details as in SQL (Relational) Databases apply. Make Peewee async-compatible PeeweeConnectionState \u00b6 The main issue with Peewee and FastAPI is that Peewee relies heavily on Python's threading.local , and it doesn't have a direct way to override it or let you handle connections/sessions directly (as is done in the SQLAlchemy tutorial). And threading.local is not compatible with the new async features of modern Python. Technical Details threading.local is used to have a \"magic\" variable that has a different value for each thread. This was useful in older frameworks designed to have one single thread per request, no more, no less. Using this, each request would have its own database connection/session, which is the actual final goal. But FastAPI, using the new async features, could handle more than one request on the same thread. And at the same time, for a single request, it could run multiple things in different threads (in a threadpool), depending on if you use async def or normal def . This is what gives all the performance improvements to FastAPI. But Python 3.7 and above provide a more advanced alternative to threading.local , that can also be used in the places where threading.local would be used, but is compatible with the new async features. We are going to use that. It's called contextvars . We are going to override the internal parts of Peewee that use threading.local and replace them with contextvars , with the corresponding updates. This might seem a bit complex (and it actually is), you don't really need to completely understand how it works to use it. We will create a PeeweeConnectionState : from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () This class inherits from a special internal class used by Peewee. It has all the logic to make Peewee use contextvars instead of threading.local . contextvars works a bit differently than threading.local . But the rest of Peewee's internal code assumes that this class works with threading.local . So, we need to do some extra tricks to make it work as if it was just using threading.local . The __init__ , __setattr__ , and __getattr__ implement all the required tricks for this to be used by Peewee without knowing that it is now compatible with FastAPI. Tip This will just make Peewee behave correctly when used with FastAPI. Not randomly opening or closing connections that are being used, creating errors, etc. But it doesn't give Peewee async super-powers. You should still use normal def functions and not async def . Use the custom PeeweeConnectionState class \u00b6 Now, overwrite the ._state internal attribute in the Peewee database db object using the new PeeweeConnectionState : from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () Tip Make sure you overwrite db._state after creating db . Tip You would do the same for any other Peewee database, including PostgresqlDatabase , MySQLDatabase , etc. Create the database models \u00b6 Let's now see the file sql_app/models.py . Create Peewee models for our data \u00b6 Now create the Peewee models (classes) for User and Item . This is the same you would do if you followed the Peewee tutorial and updated the models to have the same data as in the SQLAlchemy tutorial. Tip Peewee also uses the term \" model \" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \" model \" to refer to something different, the data validation, conversion, and documentation classes and instances. Import db from database (the file database.py from above) and use it here. import peewee from .database import db class User ( peewee . Model ): email = peewee . CharField ( unique = True , index = True ) hashed_password = peewee . CharField () is_active = peewee . BooleanField ( default = True ) class Meta : database = db class Item ( peewee . Model ): title = peewee . CharField ( index = True ) description = peewee . CharField ( index = True ) owner = peewee . ForeignKeyField ( User , backref = \"items\" ) class Meta : database = db Tip Peewee creates several magic attributes. It will automatically add an id attribute as an integer to be the primary key. It will chose the name of the tables based on the class names. For the Item , it will create an attribute owner_id with the integer ID of the User . But we don't declare it anywhere. Create the Pydantic models \u00b6 Now let's check the file sql_app/schemas.py . Tip To avoid confusion between the Peewee models and the Pydantic models , we will have the file models.py with the Peewee models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both. Create the Pydantic models / schemas \u00b6 Create all the same Pydantic models as in the SQLAlchemy tutorial: from typing import Any , List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict ( GetterDict ): def get ( self , key : Any , default : Any = None ): res = getattr ( self . _obj , key , default ) if isinstance ( res , peewee . ModelSelect ): return list ( res ) return res class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True getter_dict = PeeweeGetterDict class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True getter_dict = PeeweeGetterDict Tip Here we are creating the models with an id . We didn't explicitly specify an id attribute in the Peewee models, but Peewee adds one automatically. We are also adding the magic owner_id attribute to Item . Create a PeeweeGetterDict for the Pydantic models / schemas \u00b6 When you access a relationship in a Peewee object, like in some_user.items , Peewee doesn't provide a list of Item . It provides a special custom object of class ModelSelect . It's possible to create a list of its items with list(some_user.items) . But the object itself is not a list . And it's also not an actual Python generator . Because of this, Pydantic doesn't know by default how to convert it to a list of Pydantic models / schemas. But recent versions of Pydantic allow providing a custom class that inherits from pydantic.utils.GetterDict , to provide the functionality used when using the orm_mode = True to retrieve the values for ORM model attributes. We are going to create a custom PeeweeGetterDict class and use it in all the same Pydantic models / schemas that use orm_mode : from typing import Any , List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict ( GetterDict ): def get ( self , key : Any , default : Any = None ): res = getattr ( self . _obj , key , default ) if isinstance ( res , peewee . ModelSelect ): return list ( res ) return res class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True getter_dict = PeeweeGetterDict class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True getter_dict = PeeweeGetterDict Here we are checking if the attribute that is being accessed (e.g. .items in some_user.items ) is an instance of peewee.ModelSelect . And if that's the case, just return a list with it. And then we use it in the Pydantic models / schemas that use orm_mode = True , with the configuration variable getter_dict = PeeweeGetterDict . Tip We only need to create one PeeweeGetterDict class, and we can use it in all the Pydantic models / schemas. CRUD utils \u00b6 Now let's see the file sql_app/crud.py . Create all the CRUD utils \u00b6 Create all the same CRUD utils as in the SQLAlchemy tutorial, all the code is very similar: from . import models , schemas def get_user ( user_id : int ): return models . User . filter ( models . User . id == user_id ) . first () def get_user_by_email ( email : str ): return models . User . filter ( models . User . email == email ) . first () def get_users ( skip : int = 0 , limit : int = 100 ): return list ( models . User . select () . offset ( skip ) . limit ( limit )) def create_user ( user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db_user . save () return db_user def get_items ( skip : int = 0 , limit : int = 100 ): return list ( models . Item . select () . offset ( skip ) . limit ( limit )) def create_user_item ( item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db_item . save () return db_item There are some differences with the code for the SQLAlchemy tutorial. We don't pass a db attribute around. Instead we use the models directly. This is because the db object is a global object, that includes all the connection logic. That's why we had to do all the contextvars updates above. Aso, when returning several objects, like in get_users , we directly call list , like in: list ( models . User . select ()) This is for the same reason that we had to create a custom PeeweeGetterDict . But by returning something that is already a list instead of the peewee.ModelSelect the response_model in the path operation with List[models.User] (that we'll see later) will work correctly. Main FastAPI app \u00b6 And now in the file sql_app/main.py let's integrate and use all the other parts we created before. Create the database tables \u00b6 In a very simplistic way create the database tables: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users Create a dependency \u00b6 Create a dependency that will connect the database right at the beginning of a request and disconnect it at the end: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users Here we have an empty yield because we are actually not using the database object directly. It is connecting to the database and storing the connection data in an internal variable that is independent for each request (using the contextvars tricks from above). Because the database connection is potentially I/O blocking, this dependency is created with a normal def function. And then, in each path operation function that needs to access the database we add it as a dependency. But we are not using the value given by this dependency (it actually doesn't give any value, as it has an empty yield ). So, we don't add it to the path operation function but to the path operation decorator in the dependencies parameter: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users Context variable sub-dependency \u00b6 For all the contextvars parts to work, we need to make sure we have an independent value in the ContextVar for each request that uses the database, and that value will be used as the database state (connection, transactions, etc) for the whole request. For that, we need to create another async dependency reset_db_state() that is used as a sub-dependency in get_db() . It will set the value for the context variable (with just a default dict ) that will be used as the database state for the whole request. And then the dependency get_db() will store in it the database state (connection, transactions, etc). import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users For the next request , as we will reset that context variable again in the async dependency reset_db_state() and then create a new connection in the get_db() dependency, that new request will have its own database state (connection, transactions, etc). Tip As FastAPI is an async framework, one request could start being processed, and before finishing, another request could be received and start processing as well, and it all could be processed in the same thread. But context variables are aware of these async features, so, a Peewee database state set in the async dependency reset_db_state() will keep its own data throughout the entire request. And at the same time, the other concurrent request will have its own database state that will be independent for the whole request. Peewee Proxy \u00b6 If you are using a Peewee Proxy , the actual database is at db.obj . So, you would reset it with: async def reset_db_state (): database . db . obj . _state . _state . set ( db_state_default . copy ()) database . db . obj . _state . reset () Create your FastAPI path operations \u00b6 Now, finally, here's the standard FastAPI path operations code. import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users About def vs async def \u00b6 The same as with SQLAlchemy, we are not doing something like: user = await models . User . select () . first () ...but instead we are using: user = models . User . select () . first () So, again, we should declare the path operation functions and the dependency without async def , just with a normal def , as: # Something goes here def read_users ( skip : int = 0 , limit : int = 100 ): # Something goes here Testing Peewee with async \u00b6 This example includes an extra path operation that simulates a long processing request with time.sleep(sleep_time) . It will have the database connection open at the beginning and will just wait some seconds before replying back. And each new request will wait one second less. This will easily let you test that your app with Peewee and FastAPI is behaving correctly with all the stuff about threads. If you want to check how Peewee would break your app if used without modification, go the the sql_app/database.py file and comment the line: # db._state = PeeweeConnectionState() And in the file sql_app/main.py file, comment the body of the async dependency reset_db_state() and replace it with a pass : async def reset_db_state (): # database.db._state._state.set(db_state_default.copy()) # database.db._state.reset() pass Then run your app with Uvicorn: uvicorn sql_app.main:app --reload Open your browser at http://127.0.0.1:8000/docs and create a couple of users. Then open 10 tabs at http://127.0.0.1:8000/docs#/default/read_slow_users_slowusers__get at the same time. Go to the path operation \"Get /slowusers/ \" in all of the tabs. Use the \"Try it out\" button and execute the request in each tab, one right after the other. The tabs will wait for a bit and then some of them will show Internal Server Error . What happens \u00b6 The first tab will make your app create a connection to the database and wait for some seconds before replying back and closing the database connection. Then, for the request in the next tab, your app will wait for one second less, and so on. This means that it will end up finishing some of the last tabs' requests earlier than some of the previous ones. Then one the last requests that wait less seconds will try to open a database connection, but as one of those previous requests for the other tabs will probably be handled in the same thread as the first one, it will have the same database connection that is already open, and Peewee will throw an error and you will see it in the terminal, and the response will have an Internal Server Error . This will probably happen for more than one of those tabs. If you had multiple clients talking to your app exactly at the same time, this is what could happen. And as your app starts to handle more and more clients at the same time, the waiting time in a single request needs to be shorter and shorter to trigger the error. Fix Peewee with FastAPI \u00b6 Now go back to the file sql_app/database.py , and uncomment the line: db . _state = PeeweeConnectionState () And in the file sql_app/main.py file, uncomment the body of the async dependency reset_db_state() : async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () Terminate your running app and start it again. Repeat the same process with the 10 tabs. This time all of them will wait and you will get all the results without errors. ...You fixed it! Review all the files \u00b6 Remember you should have a directory named my_super_project (or however you want) that contains a sub-directory called sql_app . sql_app should have the following files: sql_app/__init__.py : is an empty file. sql_app/database.py : ```Python hl_lines=\"\" from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def init (self, kwargs): super(). setattr (\"_state\", db_state) super(). init ( kwargs) def __setattr__ ( self , name , value ) : self . _state . get () [ name ] = value def __getattr__ ( self , name ) : return self . _state . get () [ name ] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() * `sql_app/models.py`: ```Python hl_lines=\"\" import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed_password = peewee.CharField() is_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db sql_app/schemas.py : ```Python hl_lines=\"\" from typing import Any, List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self._obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: str = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True getter_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True getter_dict = PeeweeGetterDict * `sql_app/crud.py`: Python hl_lines=\"\" from . import models, schemas def get_user(user_id: int): return models.User.filter(models.User.id == user_id).first() def get_user_by_email(email: str): return models.User.filter(models.User.email == email).first() def get_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create_user(user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db_user.save() return db_user def get_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create_user_item(item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db_item.save() return db_item ``` sql_app/main.py : ```Python hl_lines=\"\" import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users ## Technical Details !!! warning These are very technical details that you probably don't need. ### The problem Peewee uses <a href=\"https://docs.python.org/3/library/threading.html#thread-local-data\" class=\"external-link\" target=\"_blank\">`threading.local`</a> by default to store it's database \"state\" data (connection, transactions, etc). `threading.local` creates a value exclusive to the current thread, but an async framework would run all the code (e.g. for each request) in the same thread, and possibly not in order. On top of that, an async framework could run some sync code in a threadpool (using `asyncio.run_in_executor`), but belonging to the same request. This means that, with Peewee's current implementation, multiple tasks could be using the same `threading.local` variable and end up sharing the same connection and data (that they shouldn't), and at the same time, if they execute sync I/O-blocking code in a threadpool (as with normal `def` functions in FastAPI, in *path operations* and dependencies), that code won't have access to the database state variables, even while it's part of the same request and it should be able to get access to the same database state. ### Context variables Python 3.7 has <a href=\"https://docs.python.org/3/library/contextvars.html\" class=\"external-link\" target=\"_blank\">`contextvars`</a> that can create a local variable very similar to `threading.local`, but also supporting these async features. There are several things to have in mind. The `ContextVar` has to be created at the top of the module, like: ```Python some_var = ContextVar(\"some_var\", default=\"default value\") To set a value used in the current \"context\" (e.g. for the current request) use: some_var . set ( \"new value\" ) To get a value anywhere inside of the context (e.g. in any part handling the current request) use: some_var . get () Set context variables in the async dependency reset_db_state() \u00b6 If some part of the async code sets the value with some_var.set(\"updated in function\") (e.g. like the async dependency), the rest of the code in it and the code that goes after (including code inside of async functions called with await ) will see that new value. So, in our case, if we set the Peewee state variable (with a default dict ) in the async dependency, all the rest of the internal code in our app will see this value and will be able to reuse it for the whole request. And the context variable would be set again for the next request, even if they are concurrent. Set database state in the dependency get_db() \u00b6 As get_db() is a normal def function, FastAPI will make it run in a threadpool, with a copy of the \"context\", holding the same value for the context variable (the dict with the reset database state). Then it can add database state to that dict , like the connection, etc. But if the value of the context variable (the default dict ) was set in that normal def function, it would create a new value that would stay only in that thread of the threadpool, and the rest of the code (like the path operation functions ) wouldn't have access to it. In get_db() we can only set values in the dict , but not the entire dict itself. So, we need to have the async dependency reset_db_state() to set the dict in the context variable. That way, all the code has access to the same dict for the database state for a single request. Connect and disconnect in the dependency get_db() \u00b6 Then the next question would be, why not just connect and disconnect the database in the async dependency itself, instead of in get_db() ? The async dependency has to be async for the context variable to be preserved for the rest of the request, but creating and closing the database connection is potentially blocking, so it could degrade performance if it was there. So we also need the normal def dependency get_db() .","title":"SQL (Relational) Databases with Peewee"},{"location":"advanced/sql-databases-peewee/#peewee-for-async","text":"Peewee was not designed for async frameworks, or with them in mind. Peewee has some heavy assumptions about its defaults and about how it should be used. If you are developing an application with an older non-async framework, and can work with all its defaults, it can be a great tool . But if you need to change some of the defaults, support more than one predefined database, work with an async framework (like FastAPI), etc, you will need to add quite some complex extra code to override those defaults. Nevertheless, it's possible to do it, and here you'll see exactly what code you have to add to be able to use Peewee with FastAPI. Technical Details You can read more about Peewee's stand about async in Python in the docs , an issue , a PR .","title":"Peewee for async"},{"location":"advanced/sql-databases-peewee/#the-same-app","text":"We are going to create the same application as in the SQLAlchemy tutorial ( SQL (Relational) Databases ). Most of the code is actually the same. So, we are going to focus only on the differences.","title":"The same app"},{"location":"advanced/sql-databases-peewee/#file-structure","text":"Let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this: . \u2514\u2500\u2500 sql_app \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 crud.py \u251c\u2500\u2500 database.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 schemas.py This is almost the same structure as we had for the SQLAlchemy tutorial. Now let's see what each file/module does.","title":"File structure"},{"location":"advanced/sql-databases-peewee/#create-the-peewee-parts","text":"Let's refer to the file sql_app/database.py .","title":"Create the Peewee parts"},{"location":"advanced/sql-databases-peewee/#the-standard-peewee-code","text":"Let's first check all the normal Peewee code, create a Peewee database: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () Tip Have in mind that if you wanted to use a different database, like PostgreSQL, you couldn't just change the string. You would need to use a different Peewee database class.","title":"The standard Peewee code"},{"location":"advanced/sql-databases-peewee/#note","text":"The argument: check_same_thread = False is equivalent to the one in the SQLAlchemy tutorial: connect_args = { \"check_same_thread\" : False } ...it is needed only for SQLite . Technical Details Exactly the same technical details as in SQL (Relational) Databases apply.","title":"Note"},{"location":"advanced/sql-databases-peewee/#make-peewee-async-compatible-peeweeconnectionstate","text":"The main issue with Peewee and FastAPI is that Peewee relies heavily on Python's threading.local , and it doesn't have a direct way to override it or let you handle connections/sessions directly (as is done in the SQLAlchemy tutorial). And threading.local is not compatible with the new async features of modern Python. Technical Details threading.local is used to have a \"magic\" variable that has a different value for each thread. This was useful in older frameworks designed to have one single thread per request, no more, no less. Using this, each request would have its own database connection/session, which is the actual final goal. But FastAPI, using the new async features, could handle more than one request on the same thread. And at the same time, for a single request, it could run multiple things in different threads (in a threadpool), depending on if you use async def or normal def . This is what gives all the performance improvements to FastAPI. But Python 3.7 and above provide a more advanced alternative to threading.local , that can also be used in the places where threading.local would be used, but is compatible with the new async features. We are going to use that. It's called contextvars . We are going to override the internal parts of Peewee that use threading.local and replace them with contextvars , with the corresponding updates. This might seem a bit complex (and it actually is), you don't really need to completely understand how it works to use it. We will create a PeeweeConnectionState : from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () This class inherits from a special internal class used by Peewee. It has all the logic to make Peewee use contextvars instead of threading.local . contextvars works a bit differently than threading.local . But the rest of Peewee's internal code assumes that this class works with threading.local . So, we need to do some extra tricks to make it work as if it was just using threading.local . The __init__ , __setattr__ , and __getattr__ implement all the required tricks for this to be used by Peewee without knowing that it is now compatible with FastAPI. Tip This will just make Peewee behave correctly when used with FastAPI. Not randomly opening or closing connections that are being used, creating errors, etc. But it doesn't give Peewee async super-powers. You should still use normal def functions and not async def .","title":"Make Peewee async-compatible PeeweeConnectionState"},{"location":"advanced/sql-databases-peewee/#use-the-custom-peeweeconnectionstate-class","text":"Now, overwrite the ._state internal attribute in the Peewee database db object using the new PeeweeConnectionState : from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = { \"closed\" : None , \"conn\" : None , \"ctx\" : None , \"transactions\" : None } db_state = ContextVar ( \"db_state\" , default = db_state_default . copy ()) class PeeweeConnectionState ( peewee . _ConnectionState ): def __init__ ( self , ** kwargs ): super () . __setattr__ ( \"_state\" , db_state ) super () . __init__ ( ** kwargs ) def __setattr__ ( self , name , value ): self . _state . get ()[ name ] = value def __getattr__ ( self , name ): return self . _state . get ()[ name ] db = peewee . SqliteDatabase ( DATABASE_NAME , check_same_thread = False ) db . _state = PeeweeConnectionState () Tip Make sure you overwrite db._state after creating db . Tip You would do the same for any other Peewee database, including PostgresqlDatabase , MySQLDatabase , etc.","title":"Use the custom PeeweeConnectionState class"},{"location":"advanced/sql-databases-peewee/#create-the-database-models","text":"Let's now see the file sql_app/models.py .","title":"Create the database models"},{"location":"advanced/sql-databases-peewee/#create-peewee-models-for-our-data","text":"Now create the Peewee models (classes) for User and Item . This is the same you would do if you followed the Peewee tutorial and updated the models to have the same data as in the SQLAlchemy tutorial. Tip Peewee also uses the term \" model \" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \" model \" to refer to something different, the data validation, conversion, and documentation classes and instances. Import db from database (the file database.py from above) and use it here. import peewee from .database import db class User ( peewee . Model ): email = peewee . CharField ( unique = True , index = True ) hashed_password = peewee . CharField () is_active = peewee . BooleanField ( default = True ) class Meta : database = db class Item ( peewee . Model ): title = peewee . CharField ( index = True ) description = peewee . CharField ( index = True ) owner = peewee . ForeignKeyField ( User , backref = \"items\" ) class Meta : database = db Tip Peewee creates several magic attributes. It will automatically add an id attribute as an integer to be the primary key. It will chose the name of the tables based on the class names. For the Item , it will create an attribute owner_id with the integer ID of the User . But we don't declare it anywhere.","title":"Create Peewee models for our data"},{"location":"advanced/sql-databases-peewee/#create-the-pydantic-models","text":"Now let's check the file sql_app/schemas.py . Tip To avoid confusion between the Peewee models and the Pydantic models , we will have the file models.py with the Peewee models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both.","title":"Create the Pydantic models"},{"location":"advanced/sql-databases-peewee/#create-the-pydantic-models-schemas","text":"Create all the same Pydantic models as in the SQLAlchemy tutorial: from typing import Any , List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict ( GetterDict ): def get ( self , key : Any , default : Any = None ): res = getattr ( self . _obj , key , default ) if isinstance ( res , peewee . ModelSelect ): return list ( res ) return res class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True getter_dict = PeeweeGetterDict class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True getter_dict = PeeweeGetterDict Tip Here we are creating the models with an id . We didn't explicitly specify an id attribute in the Peewee models, but Peewee adds one automatically. We are also adding the magic owner_id attribute to Item .","title":"Create the Pydantic models / schemas"},{"location":"advanced/sql-databases-peewee/#create-a-peeweegetterdict-for-the-pydantic-models-schemas","text":"When you access a relationship in a Peewee object, like in some_user.items , Peewee doesn't provide a list of Item . It provides a special custom object of class ModelSelect . It's possible to create a list of its items with list(some_user.items) . But the object itself is not a list . And it's also not an actual Python generator . Because of this, Pydantic doesn't know by default how to convert it to a list of Pydantic models / schemas. But recent versions of Pydantic allow providing a custom class that inherits from pydantic.utils.GetterDict , to provide the functionality used when using the orm_mode = True to retrieve the values for ORM model attributes. We are going to create a custom PeeweeGetterDict class and use it in all the same Pydantic models / schemas that use orm_mode : from typing import Any , List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict ( GetterDict ): def get ( self , key : Any , default : Any = None ): res = getattr ( self . _obj , key , default ) if isinstance ( res , peewee . ModelSelect ): return list ( res ) return res class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True getter_dict = PeeweeGetterDict class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True getter_dict = PeeweeGetterDict Here we are checking if the attribute that is being accessed (e.g. .items in some_user.items ) is an instance of peewee.ModelSelect . And if that's the case, just return a list with it. And then we use it in the Pydantic models / schemas that use orm_mode = True , with the configuration variable getter_dict = PeeweeGetterDict . Tip We only need to create one PeeweeGetterDict class, and we can use it in all the Pydantic models / schemas.","title":"Create a PeeweeGetterDict for the Pydantic models / schemas"},{"location":"advanced/sql-databases-peewee/#crud-utils","text":"Now let's see the file sql_app/crud.py .","title":"CRUD utils"},{"location":"advanced/sql-databases-peewee/#create-all-the-crud-utils","text":"Create all the same CRUD utils as in the SQLAlchemy tutorial, all the code is very similar: from . import models , schemas def get_user ( user_id : int ): return models . User . filter ( models . User . id == user_id ) . first () def get_user_by_email ( email : str ): return models . User . filter ( models . User . email == email ) . first () def get_users ( skip : int = 0 , limit : int = 100 ): return list ( models . User . select () . offset ( skip ) . limit ( limit )) def create_user ( user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db_user . save () return db_user def get_items ( skip : int = 0 , limit : int = 100 ): return list ( models . Item . select () . offset ( skip ) . limit ( limit )) def create_user_item ( item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db_item . save () return db_item There are some differences with the code for the SQLAlchemy tutorial. We don't pass a db attribute around. Instead we use the models directly. This is because the db object is a global object, that includes all the connection logic. That's why we had to do all the contextvars updates above. Aso, when returning several objects, like in get_users , we directly call list , like in: list ( models . User . select ()) This is for the same reason that we had to create a custom PeeweeGetterDict . But by returning something that is already a list instead of the peewee.ModelSelect the response_model in the path operation with List[models.User] (that we'll see later) will work correctly.","title":"Create all the CRUD utils"},{"location":"advanced/sql-databases-peewee/#main-fastapi-app","text":"And now in the file sql_app/main.py let's integrate and use all the other parts we created before.","title":"Main FastAPI app"},{"location":"advanced/sql-databases-peewee/#create-the-database-tables","text":"In a very simplistic way create the database tables: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users","title":"Create the database tables"},{"location":"advanced/sql-databases-peewee/#create-a-dependency","text":"Create a dependency that will connect the database right at the beginning of a request and disconnect it at the end: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users Here we have an empty yield because we are actually not using the database object directly. It is connecting to the database and storing the connection data in an internal variable that is independent for each request (using the contextvars tricks from above). Because the database connection is potentially I/O blocking, this dependency is created with a normal def function. And then, in each path operation function that needs to access the database we add it as a dependency. But we are not using the value given by this dependency (it actually doesn't give any value, as it has an empty yield ). So, we don't add it to the path operation function but to the path operation decorator in the dependencies parameter: import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users","title":"Create a dependency"},{"location":"advanced/sql-databases-peewee/#context-variable-sub-dependency","text":"For all the contextvars parts to work, we need to make sure we have an independent value in the ContextVar for each request that uses the database, and that value will be used as the database state (connection, transactions, etc) for the whole request. For that, we need to create another async dependency reset_db_state() that is used as a sub-dependency in get_db() . It will set the value for the context variable (with just a default dict ) that will be used as the database state for the whole request. And then the dependency get_db() will store in it the database state (connection, transactions, etc). import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users For the next request , as we will reset that context variable again in the async dependency reset_db_state() and then create a new connection in the get_db() dependency, that new request will have its own database state (connection, transactions, etc). Tip As FastAPI is an async framework, one request could start being processed, and before finishing, another request could be received and start processing as well, and it all could be processed in the same thread. But context variables are aware of these async features, so, a Peewee database state set in the async dependency reset_db_state() will keep its own data throughout the entire request. And at the same time, the other concurrent request will have its own database state that will be independent for the whole request.","title":"Context variable sub-dependency"},{"location":"advanced/sql-databases-peewee/#peewee-proxy","text":"If you are using a Peewee Proxy , the actual database is at db.obj . So, you would reset it with: async def reset_db_state (): database . db . obj . _state . _state . set ( db_state_default . copy ()) database . db . obj . _state . reset ()","title":"Peewee Proxy"},{"location":"advanced/sql-databases-peewee/#create-your-fastapi-path-operations","text":"Now, finally, here's the standard FastAPI path operations code. import time from typing import List from fastapi import Depends , FastAPI , HTTPException from . import crud , database , models , schemas from .database import db_state_default database . db . connect () database . db . create_tables ([ models . User , models . Item ]) database . db . close () app = FastAPI () sleep_time = 10 async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () def get_db ( db_state = Depends ( reset_db_state )): try : database . db . connect () yield finally : if not database . db . is_closed (): database . db . close () @app . post ( \"/users/\" , response_model = schemas . User , dependencies = [ Depends ( get_db )]) def create_user ( user : schemas . UserCreate ): db_user = crud . get_user_by_email ( email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )]) def read_users ( skip : int = 0 , limit : int = 100 ): users = crud . get_users ( skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User , dependencies = [ Depends ( get_db )] ) def read_user ( user_id : int ): db_user = crud . get_user ( user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item , dependencies = [ Depends ( get_db )], ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate ): return crud . create_user_item ( item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ], dependencies = [ Depends ( get_db )]) def read_items ( skip : int = 0 , limit : int = 100 ): items = crud . get_items ( skip = skip , limit = limit ) return items @app . get ( \"/slowusers/\" , response_model = List [ schemas . User ], dependencies = [ Depends ( get_db )] ) def read_slow_users ( skip : int = 0 , limit : int = 100 ): global sleep_time sleep_time = max ( 0 , sleep_time - 1 ) time . sleep ( sleep_time ) # Fake long processing request users = crud . get_users ( skip = skip , limit = limit ) return users","title":"Create your FastAPI path operations"},{"location":"advanced/sql-databases-peewee/#about-def-vs-async-def","text":"The same as with SQLAlchemy, we are not doing something like: user = await models . User . select () . first () ...but instead we are using: user = models . User . select () . first () So, again, we should declare the path operation functions and the dependency without async def , just with a normal def , as: # Something goes here def read_users ( skip : int = 0 , limit : int = 100 ): # Something goes here","title":"About def vs async def"},{"location":"advanced/sql-databases-peewee/#testing-peewee-with-async","text":"This example includes an extra path operation that simulates a long processing request with time.sleep(sleep_time) . It will have the database connection open at the beginning and will just wait some seconds before replying back. And each new request will wait one second less. This will easily let you test that your app with Peewee and FastAPI is behaving correctly with all the stuff about threads. If you want to check how Peewee would break your app if used without modification, go the the sql_app/database.py file and comment the line: # db._state = PeeweeConnectionState() And in the file sql_app/main.py file, comment the body of the async dependency reset_db_state() and replace it with a pass : async def reset_db_state (): # database.db._state._state.set(db_state_default.copy()) # database.db._state.reset() pass Then run your app with Uvicorn: uvicorn sql_app.main:app --reload Open your browser at http://127.0.0.1:8000/docs and create a couple of users. Then open 10 tabs at http://127.0.0.1:8000/docs#/default/read_slow_users_slowusers__get at the same time. Go to the path operation \"Get /slowusers/ \" in all of the tabs. Use the \"Try it out\" button and execute the request in each tab, one right after the other. The tabs will wait for a bit and then some of them will show Internal Server Error .","title":"Testing Peewee with async"},{"location":"advanced/sql-databases-peewee/#what-happens","text":"The first tab will make your app create a connection to the database and wait for some seconds before replying back and closing the database connection. Then, for the request in the next tab, your app will wait for one second less, and so on. This means that it will end up finishing some of the last tabs' requests earlier than some of the previous ones. Then one the last requests that wait less seconds will try to open a database connection, but as one of those previous requests for the other tabs will probably be handled in the same thread as the first one, it will have the same database connection that is already open, and Peewee will throw an error and you will see it in the terminal, and the response will have an Internal Server Error . This will probably happen for more than one of those tabs. If you had multiple clients talking to your app exactly at the same time, this is what could happen. And as your app starts to handle more and more clients at the same time, the waiting time in a single request needs to be shorter and shorter to trigger the error.","title":"What happens"},{"location":"advanced/sql-databases-peewee/#fix-peewee-with-fastapi","text":"Now go back to the file sql_app/database.py , and uncomment the line: db . _state = PeeweeConnectionState () And in the file sql_app/main.py file, uncomment the body of the async dependency reset_db_state() : async def reset_db_state (): database . db . _state . _state . set ( db_state_default . copy ()) database . db . _state . reset () Terminate your running app and start it again. Repeat the same process with the 10 tabs. This time all of them will wait and you will get all the results without errors. ...You fixed it!","title":"Fix Peewee with FastAPI"},{"location":"advanced/sql-databases-peewee/#review-all-the-files","text":"Remember you should have a directory named my_super_project (or however you want) that contains a sub-directory called sql_app . sql_app should have the following files: sql_app/__init__.py : is an empty file. sql_app/database.py : ```Python hl_lines=\"\" from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def init (self, kwargs): super(). setattr (\"_state\", db_state) super(). init ( kwargs) def __setattr__ ( self , name , value ) : self . _state . get () [ name ] = value def __getattr__ ( self , name ) : return self . _state . get () [ name ] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() * `sql_app/models.py`: ```Python hl_lines=\"\" import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed_password = peewee.CharField() is_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db sql_app/schemas.py : ```Python hl_lines=\"\" from typing import Any, List import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self._obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: str = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True getter_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True getter_dict = PeeweeGetterDict * `sql_app/crud.py`: Python hl_lines=\"\" from . import models, schemas def get_user(user_id: int): return models.User.filter(models.User.id == user_id).first() def get_user_by_email(email: str): return models.User.filter(models.User.email == email).first() def get_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create_user(user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db_user.save() return db_user def get_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create_user_item(item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db_item.save() return db_item ``` sql_app/main.py : ```Python hl_lines=\"\" import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users ## Technical Details !!! warning These are very technical details that you probably don't need. ### The problem Peewee uses <a href=\"https://docs.python.org/3/library/threading.html#thread-local-data\" class=\"external-link\" target=\"_blank\">`threading.local`</a> by default to store it's database \"state\" data (connection, transactions, etc). `threading.local` creates a value exclusive to the current thread, but an async framework would run all the code (e.g. for each request) in the same thread, and possibly not in order. On top of that, an async framework could run some sync code in a threadpool (using `asyncio.run_in_executor`), but belonging to the same request. This means that, with Peewee's current implementation, multiple tasks could be using the same `threading.local` variable and end up sharing the same connection and data (that they shouldn't), and at the same time, if they execute sync I/O-blocking code in a threadpool (as with normal `def` functions in FastAPI, in *path operations* and dependencies), that code won't have access to the database state variables, even while it's part of the same request and it should be able to get access to the same database state. ### Context variables Python 3.7 has <a href=\"https://docs.python.org/3/library/contextvars.html\" class=\"external-link\" target=\"_blank\">`contextvars`</a> that can create a local variable very similar to `threading.local`, but also supporting these async features. There are several things to have in mind. The `ContextVar` has to be created at the top of the module, like: ```Python some_var = ContextVar(\"some_var\", default=\"default value\") To set a value used in the current \"context\" (e.g. for the current request) use: some_var . set ( \"new value\" ) To get a value anywhere inside of the context (e.g. in any part handling the current request) use: some_var . get ()","title":"Review all the files"},{"location":"advanced/sql-databases-peewee/#set-context-variables-in-the-async-dependency-reset_db_state","text":"If some part of the async code sets the value with some_var.set(\"updated in function\") (e.g. like the async dependency), the rest of the code in it and the code that goes after (including code inside of async functions called with await ) will see that new value. So, in our case, if we set the Peewee state variable (with a default dict ) in the async dependency, all the rest of the internal code in our app will see this value and will be able to reuse it for the whole request. And the context variable would be set again for the next request, even if they are concurrent.","title":"Set context variables in the async dependency reset_db_state()"},{"location":"advanced/sql-databases-peewee/#set-database-state-in-the-dependency-get_db","text":"As get_db() is a normal def function, FastAPI will make it run in a threadpool, with a copy of the \"context\", holding the same value for the context variable (the dict with the reset database state). Then it can add database state to that dict , like the connection, etc. But if the value of the context variable (the default dict ) was set in that normal def function, it would create a new value that would stay only in that thread of the threadpool, and the rest of the code (like the path operation functions ) wouldn't have access to it. In get_db() we can only set values in the dict , but not the entire dict itself. So, we need to have the async dependency reset_db_state() to set the dict in the context variable. That way, all the code has access to the same dict for the database state for a single request.","title":"Set database state in the dependency get_db()"},{"location":"advanced/sql-databases-peewee/#connect-and-disconnect-in-the-dependency-get_db","text":"Then the next question would be, why not just connect and disconnect the database in the async dependency itself, instead of in get_db() ? The async dependency has to be async for the context variable to be preserved for the rest of the request, but creating and closing the database connection is potentially blocking, so it could degrade performance if it was there. So we also need the normal def dependency get_db() .","title":"Connect and disconnect in the dependency get_db()"},{"location":"advanced/sub-applications-proxy/","text":"There are at least two situations where you could need to create your FastAPI application using some specific paths. But then you need to set them up to be served with a path prefix. It could happen if you have a: Proxy server. You are \" mounting \" a FastAPI application inside another FastAPI application (or inside another ASGI application, like Starlette). Proxy \u00b6 Having a proxy in this case means that you could declare a path at /app , but then, you could need to add a layer on top (the Proxy) that would put your FastAPI application under a path like /api/v1 . In this case, the original path /app will actually be served at /api/v1/app . Even though your application \"thinks\" it is serving at /app . And the Proxy could be re-writing the path \"on the fly\" to keep your application convinced that it is serving at /app . Up to here, everything would work as normally. But then, when you open the integrated docs, they would expect to get the OpenAPI schema at /openapi.json , instead of /api/v1/openapi.json . So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema. So, it's needed that the frontend looks for the OpenAPI schema at /api/v1/openapi.json . And it's also needed that the returned JSON OpenAPI schema has the defined path at /api/v1/app (behind the proxy) instead of /app . For these cases, you can declare an openapi_prefix parameter in your FastAPI application. See the section below, about \"mounting\", for an example. Mounting a FastAPI application \u00b6 \"Mounting\" means adding a complete \"independent\" application in a specific path, that then takes care of handling all the sub-paths. You could want to do this if you have several \"independent\" applications that you want to separate, having their own independent OpenAPI schema and user interfaces. Top-level application \u00b6 First, create the main, top-level, FastAPI application, and its path operations : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi ) Sub-application \u00b6 Then, create your sub-application, and its path operations . This sub-application is just another standard FastAPI application, but this is the one that will be \"mounted\". When creating the sub-application, use the parameter openapi_prefix . In this case, with a prefix of /subapi : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi ) Mount the sub-application \u00b6 In your top-level application, app , mount the sub-application, subapi . Here you need to make sure you use the same path that you used for the openapi_prefix , in this case, /subapi : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi ) Check the automatic API docs \u00b6 Now, run uvicorn , if your file is at main.py , it would be: uvicorn main:app --reload And open the docs at http://127.0.0.1:8000/docs . You will see the automatic API docs for the main app, including only its own paths: And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs . You will see the automatic API docs for the sub-application, including only its own sub-paths, with their correct prefix: If you try interacting with any of the two user interfaces, they will work, because the browser will be able to talk to the correct path (or sub-path).","title":"Sub Applications - Behind a Proxy"},{"location":"advanced/sub-applications-proxy/#proxy","text":"Having a proxy in this case means that you could declare a path at /app , but then, you could need to add a layer on top (the Proxy) that would put your FastAPI application under a path like /api/v1 . In this case, the original path /app will actually be served at /api/v1/app . Even though your application \"thinks\" it is serving at /app . And the Proxy could be re-writing the path \"on the fly\" to keep your application convinced that it is serving at /app . Up to here, everything would work as normally. But then, when you open the integrated docs, they would expect to get the OpenAPI schema at /openapi.json , instead of /api/v1/openapi.json . So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema. So, it's needed that the frontend looks for the OpenAPI schema at /api/v1/openapi.json . And it's also needed that the returned JSON OpenAPI schema has the defined path at /api/v1/app (behind the proxy) instead of /app . For these cases, you can declare an openapi_prefix parameter in your FastAPI application. See the section below, about \"mounting\", for an example.","title":"Proxy"},{"location":"advanced/sub-applications-proxy/#mounting-a-fastapi-application","text":"\"Mounting\" means adding a complete \"independent\" application in a specific path, that then takes care of handling all the sub-paths. You could want to do this if you have several \"independent\" applications that you want to separate, having their own independent OpenAPI schema and user interfaces.","title":"Mounting a FastAPI application"},{"location":"advanced/sub-applications-proxy/#top-level-application","text":"First, create the main, top-level, FastAPI application, and its path operations : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi )","title":"Top-level application"},{"location":"advanced/sub-applications-proxy/#sub-application","text":"Then, create your sub-application, and its path operations . This sub-application is just another standard FastAPI application, but this is the one that will be \"mounted\". When creating the sub-application, use the parameter openapi_prefix . In this case, with a prefix of /subapi : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi )","title":"Sub-application"},{"location":"advanced/sub-applications-proxy/#mount-the-sub-application","text":"In your top-level application, app , mount the sub-application, subapi . Here you need to make sure you use the same path that you used for the openapi_prefix , in this case, /subapi : from fastapi import FastAPI app = FastAPI () @app . get ( \"/app\" ) def read_main (): return { \"message\" : \"Hello World from main app\" } subapi = FastAPI ( openapi_prefix = \"/subapi\" ) @subapi . get ( \"/sub\" ) def read_sub (): return { \"message\" : \"Hello World from sub API\" } app . mount ( \"/subapi\" , subapi )","title":"Mount the sub-application"},{"location":"advanced/sub-applications-proxy/#check-the-automatic-api-docs","text":"Now, run uvicorn , if your file is at main.py , it would be: uvicorn main:app --reload And open the docs at http://127.0.0.1:8000/docs . You will see the automatic API docs for the main app, including only its own paths: And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs . You will see the automatic API docs for the sub-application, including only its own sub-paths, with their correct prefix: If you try interacting with any of the two user interfaces, they will work, because the browser will be able to talk to the correct path (or sub-path).","title":"Check the automatic API docs"},{"location":"advanced/templates/","text":"You can use any template engine you want with FastAPI . A common election is Jinja2, the same one used by Flask and other tools. Starlette has utilities to configure it easily that you can use directly in your FastAPI application. Install dependencies \u00b6 Install jinja2 : pip install jinja2 If you need to also serve static files (as in this example), install aiofiles : pip install aiofiles Using Jinja2Templates \u00b6 Import Jinja2Templates form Starlette. Create a templates object that you can re-use later. Declare a Request parameter in the path operation that will return a template. Use the templates you created to render and return a TemplateResponse , passing the request as one of the key-value pairs in the Jinja2 \"context\". from fastapi import FastAPI from starlette.requests import Request from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates app = FastAPI () app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) templates = Jinja2Templates ( directory = \"templates\" ) @app . get ( \"/items/ {id} \" ) async def read_item ( request : Request , id : str ): return templates . TemplateResponse ( \"item.html\" , { \"request\" : request , \"id\" : id }) Note Notice that you have to pass the request as part of the key-value pairs in the context for Jinja2. So, you also have to declare it in your path operation . Writing templates \u00b6 Then you can write a template at templates/item.html with: <html> <head> <title>Item Details</title> <link href=\" {{ url_for ( 'static' , path = '/styles.css' ) }} \" rel=\"stylesheet\"> </head> <body> <h1>Item ID: {{ id }} </h1> </body> </html> It will show the id taken from the \"context\" dict you passed: { \"request\" : request , \"id\" : id } Templates and static files \u00b6 And you can also use url_for() inside of the template, and use it, for example, with the StaticFiles you mounted. <html> <head> <title>Item Details</title> <link href=\" {{ url_for ( 'static' , path = '/styles.css' ) }} \" rel=\"stylesheet\"> </head> <body> <h1>Item ID: {{ id }} </h1> </body> </html> In this example, it would link to a CSS file at static/styles.css with: h1 { color : green ; } And because you are using StaticFiles , that CSS file would be served automatically by your FastAPI application at the URL /static/styles.css . More details \u00b6 For more details, including how to test templates, check Starlette's docs on templates .","title":"Templates"},{"location":"advanced/templates/#install-dependencies","text":"Install jinja2 : pip install jinja2 If you need to also serve static files (as in this example), install aiofiles : pip install aiofiles","title":"Install dependencies"},{"location":"advanced/templates/#using-jinja2templates","text":"Import Jinja2Templates form Starlette. Create a templates object that you can re-use later. Declare a Request parameter in the path operation that will return a template. Use the templates you created to render and return a TemplateResponse , passing the request as one of the key-value pairs in the Jinja2 \"context\". from fastapi import FastAPI from starlette.requests import Request from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates app = FastAPI () app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) templates = Jinja2Templates ( directory = \"templates\" ) @app . get ( \"/items/ {id} \" ) async def read_item ( request : Request , id : str ): return templates . TemplateResponse ( \"item.html\" , { \"request\" : request , \"id\" : id }) Note Notice that you have to pass the request as part of the key-value pairs in the context for Jinja2. So, you also have to declare it in your path operation .","title":"Using Jinja2Templates"},{"location":"advanced/templates/#writing-templates","text":"Then you can write a template at templates/item.html with: <html> <head> <title>Item Details</title> <link href=\" {{ url_for ( 'static' , path = '/styles.css' ) }} \" rel=\"stylesheet\"> </head> <body> <h1>Item ID: {{ id }} </h1> </body> </html> It will show the id taken from the \"context\" dict you passed: { \"request\" : request , \"id\" : id }","title":"Writing templates"},{"location":"advanced/templates/#templates-and-static-files","text":"And you can also use url_for() inside of the template, and use it, for example, with the StaticFiles you mounted. <html> <head> <title>Item Details</title> <link href=\" {{ url_for ( 'static' , path = '/styles.css' ) }} \" rel=\"stylesheet\"> </head> <body> <h1>Item ID: {{ id }} </h1> </body> </html> In this example, it would link to a CSS file at static/styles.css with: h1 { color : green ; } And because you are using StaticFiles , that CSS file would be served automatically by your FastAPI application at the URL /static/styles.css .","title":"Templates and static files"},{"location":"advanced/templates/#more-details","text":"For more details, including how to test templates, check Starlette's docs on templates .","title":"More details"},{"location":"advanced/testing-dependencies/","text":"Overriding dependencies during testing \u00b6 There are some scenarios where you might want to override a dependency during testing. You don't want the original dependency to run (nor any of the sub-dependencies it might have). Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used. Use cases: external service \u00b6 An example could be that you have an external authentication provider that you need to call. You send it a token and it returns an authenticated user. This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests. You probably want to test the external provider once, but not necessarily call it for every test that runs. In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests. Use case: testing database \u00b6 Other example could be that you are using a specific database only for testing. Your normal dependency would return a database session. But then, after each test, you could want to rollback all the operations or remove data. Or you could want to alter the data before the tests run, etc. In this case, you could use a dependency override to return your custom database session instead of the one that would be used normally. Use the app.dependency_overrides attribute \u00b6 For these cases, your FastAPI application has an attribute app.dependency_overrides , it is a simple dict . To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function). And then FastAPI will call that override instead of the original dependency. from fastapi import Depends , FastAPI from starlette.testclient import TestClient app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return { \"message\" : \"Hello Items!\" , \"params\" : commons } @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return { \"message\" : \"Hello Users!\" , \"params\" : commons } client = TestClient ( app ) async def override_dependency ( q : str = None ): return { \"q\" : q , \"skip\" : 5 , \"limit\" : 10 } app . dependency_overrides [ common_parameters ] = override_dependency def test_override_in_items (): response = client . get ( \"/items/\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : None , \"skip\" : 5 , \"limit\" : 10 }, } def test_override_in_items_with_q (): response = client . get ( \"/items/?q=foo\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : \"foo\" , \"skip\" : 5 , \"limit\" : 10 }, } def test_override_in_items_with_params (): response = client . get ( \"/items/?q=foo&skip=100&limit=200\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : \"foo\" , \"skip\" : 5 , \"limit\" : 10 }, } Tip You can set a dependency override for a dependency used anywhere in your FastAPI application. The original dependency could be used in a path operation function , a path operation decorator (when you don't use the return value), a .include_router() call, etc. FastAPI will still be able to override it. Then you can reset your overrides (remove them) by setting app.dependency_overrides to be an empty dict : app . dependency_overrides = {} Tip If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).","title":"Testing Dependencies with Overrides"},{"location":"advanced/testing-dependencies/#overriding-dependencies-during-testing","text":"There are some scenarios where you might want to override a dependency during testing. You don't want the original dependency to run (nor any of the sub-dependencies it might have). Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.","title":"Overriding dependencies during testing"},{"location":"advanced/testing-dependencies/#use-cases-external-service","text":"An example could be that you have an external authentication provider that you need to call. You send it a token and it returns an authenticated user. This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests. You probably want to test the external provider once, but not necessarily call it for every test that runs. In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.","title":"Use cases: external service"},{"location":"advanced/testing-dependencies/#use-case-testing-database","text":"Other example could be that you are using a specific database only for testing. Your normal dependency would return a database session. But then, after each test, you could want to rollback all the operations or remove data. Or you could want to alter the data before the tests run, etc. In this case, you could use a dependency override to return your custom database session instead of the one that would be used normally.","title":"Use case: testing database"},{"location":"advanced/testing-dependencies/#use-the-appdependency_overrides-attribute","text":"For these cases, your FastAPI application has an attribute app.dependency_overrides , it is a simple dict . To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function). And then FastAPI will call that override instead of the original dependency. from fastapi import Depends , FastAPI from starlette.testclient import TestClient app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return { \"message\" : \"Hello Items!\" , \"params\" : commons } @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return { \"message\" : \"Hello Users!\" , \"params\" : commons } client = TestClient ( app ) async def override_dependency ( q : str = None ): return { \"q\" : q , \"skip\" : 5 , \"limit\" : 10 } app . dependency_overrides [ common_parameters ] = override_dependency def test_override_in_items (): response = client . get ( \"/items/\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : None , \"skip\" : 5 , \"limit\" : 10 }, } def test_override_in_items_with_q (): response = client . get ( \"/items/?q=foo\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : \"foo\" , \"skip\" : 5 , \"limit\" : 10 }, } def test_override_in_items_with_params (): response = client . get ( \"/items/?q=foo&skip=100&limit=200\" ) assert response . status_code == 200 assert response . json () == { \"message\" : \"Hello Items!\" , \"params\" : { \"q\" : \"foo\" , \"skip\" : 5 , \"limit\" : 10 }, } Tip You can set a dependency override for a dependency used anywhere in your FastAPI application. The original dependency could be used in a path operation function , a path operation decorator (when you don't use the return value), a .include_router() call, etc. FastAPI will still be able to override it. Then you can reset your overrides (remove them) by setting app.dependency_overrides to be an empty dict : app . dependency_overrides = {} Tip If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).","title":"Use the app.dependency_overrides attribute"},{"location":"advanced/testing-events/","text":"Testing Events, startup and shutdown \u00b6 When you need your event handlers ( startup and shutdown ) to run in your tests, you can use the TestClient with a with statement: from fastapi import FastAPI from starlette.testclient import TestClient app = FastAPI () items = {} @app . on_event ( \"startup\" ) async def startup_event (): items [ \"foo\" ] = { \"name\" : \"Fighters\" } items [ \"bar\" ] = { \"name\" : \"Tenders\" } @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : str ): return items [ item_id ] def test_read_items (): with TestClient ( app ) as client : response = client . get ( \"/items/foo\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"Fighters\" }","title":"Testing Events: startup - shutdown"},{"location":"advanced/testing-events/#testing-events-startup-and-shutdown","text":"When you need your event handlers ( startup and shutdown ) to run in your tests, you can use the TestClient with a with statement: from fastapi import FastAPI from starlette.testclient import TestClient app = FastAPI () items = {} @app . on_event ( \"startup\" ) async def startup_event (): items [ \"foo\" ] = { \"name\" : \"Fighters\" } items [ \"bar\" ] = { \"name\" : \"Tenders\" } @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : str ): return items [ item_id ] def test_read_items (): with TestClient ( app ) as client : response = client . get ( \"/items/foo\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"Fighters\" }","title":"Testing Events, startup and shutdown"},{"location":"advanced/testing-websockets/","text":"Testing WebSockets \u00b6 You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: from fastapi import FastAPI from starlette.testclient import TestClient from starlette.websockets import WebSocket app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" } @app . websocket_route ( \"/ws\" ) async def websocket ( websocket : WebSocket ): await websocket . accept () await websocket . send_json ({ \"msg\" : \"Hello WebSocket\" }) await websocket . close () def test_read_main (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" } def test_websocket (): client = TestClient ( app ) with client . websocket_connect ( \"/ws\" ) as websocket : data = websocket . receive_json () assert data == { \"msg\" : \"Hello WebSocket\" }","title":"Testing WebSockets"},{"location":"advanced/testing-websockets/#testing-websockets","text":"You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: from fastapi import FastAPI from starlette.testclient import TestClient from starlette.websockets import WebSocket app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" } @app . websocket_route ( \"/ws\" ) async def websocket ( websocket : WebSocket ): await websocket . accept () await websocket . send_json ({ \"msg\" : \"Hello WebSocket\" }) await websocket . close () def test_read_main (): client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" } def test_websocket (): client = TestClient ( app ) with client . websocket_connect ( \"/ws\" ) as websocket : data = websocket . receive_json () assert data == { \"msg\" : \"Hello WebSocket\" }","title":"Testing WebSockets"},{"location":"advanced/using-request-directly/","text":"Up to now, you have been declaring the parts of the request that you need with their types. Taking data from: The path as parameters. Headers. Cookies. etc. And by doing so, FastAPI is validating that data, converting it and generating documentation for your API automatically. But there are situations where you might need to access the Request object directly. Details about the Request object \u00b6 As FastAPI is actually Starlette underneath, with a layer of several tools on top, you can use Starlette's Request object directly when you need to. It would also mean that if you get data from the Request object directly (for example, read the body) it won't be validated, converted or annotated (with OpenAPI, for the automatic documentation) by FastAPI. Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc. But there are specific cases where it's useful to get the Request object. Use the Request object directly \u00b6 Let's imagine you want to get the client's IP address/host inside of your path operation function . For that you need to access the request directly. Import the Request \u00b6 First, import the Request class from Starlette: from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . get ( \"/items/ {item_id} \" ) def read_root ( item_id : str , request : Request ): client_host = request . client . host return { \"client_host\" : client_host , \"item_id\" : item_id } Declare the Request parameter \u00b6 Then declare a path operation function parameter with the type being the Request class: from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . get ( \"/items/ {item_id} \" ) def read_root ( item_id : str , request : Request ): client_host = request . client . host return { \"client_host\" : client_host , \"item_id\" : item_id } Tip Note that in this case, we are declaring a path parameter besides the request parameter. So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI. The same way, you can declare any other parameter as normally, and additionally, get the Request too. Request documentation \u00b6 You can read more details about the Request object in the official Starlette documentation site .","title":"Using the Request Directly"},{"location":"advanced/using-request-directly/#details-about-the-request-object","text":"As FastAPI is actually Starlette underneath, with a layer of several tools on top, you can use Starlette's Request object directly when you need to. It would also mean that if you get data from the Request object directly (for example, read the body) it won't be validated, converted or annotated (with OpenAPI, for the automatic documentation) by FastAPI. Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc. But there are specific cases where it's useful to get the Request object.","title":"Details about the Request object"},{"location":"advanced/using-request-directly/#use-the-request-object-directly","text":"Let's imagine you want to get the client's IP address/host inside of your path operation function . For that you need to access the request directly.","title":"Use the Request object directly"},{"location":"advanced/using-request-directly/#import-the-request","text":"First, import the Request class from Starlette: from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . get ( \"/items/ {item_id} \" ) def read_root ( item_id : str , request : Request ): client_host = request . client . host return { \"client_host\" : client_host , \"item_id\" : item_id }","title":"Import the Request"},{"location":"advanced/using-request-directly/#declare-the-request-parameter","text":"Then declare a path operation function parameter with the type being the Request class: from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . get ( \"/items/ {item_id} \" ) def read_root ( item_id : str , request : Request ): client_host = request . client . host return { \"client_host\" : client_host , \"item_id\" : item_id } Tip Note that in this case, we are declaring a path parameter besides the request parameter. So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI. The same way, you can declare any other parameter as normally, and additionally, get the Request too.","title":"Declare the Request parameter"},{"location":"advanced/using-request-directly/#request-documentation","text":"You can read more details about the Request object in the official Starlette documentation site .","title":"Request documentation"},{"location":"advanced/websockets/","text":"You can use WebSockets with FastAPI . WebSockets client \u00b6 In production \u00b6 In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular. And to communicate using WebSockets with your backend you would probably use your frontend's utilities. Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code. Or you might have any other way to communicate with the WebSocket endpoint. But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string. This, of course, is not optimal and you wouldn't use it for production. In production you would have one of the options above. But it's the simplest way to focus on the server-side of WebSockets and have a working example: from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" ) Create a websocket \u00b6 In your FastAPI application, create a websocket : from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" ) Tip In this example we are importing WebSocket from starlette.websockets to use it in the type declaration in the WebSocket route function. Await for messages and send messages \u00b6 In your WebSocket route you can await for messages and send messages. from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" ) You can receive and send binary, text, and JSON data. Using Depends and others \u00b6 In WebSocket endpoints you can import from fastapi and use: Depends Security Cookie Header Path Query They work the same way as for other FastAPI endpoints/ path operations : from fastapi import Cookie , Depends , FastAPI , Header from starlette.responses import HTMLResponse from starlette.status import WS_1008_POLICY_VIOLATION from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <label>Item ID: <input type=\"text\" id=\"itemId\" autocomplete=\"off\" value=\"foo\"/></label> <button onclick=\"connect(event)\">Connect</button> <br> <label>Message: <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/></label> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = null; function connect(event) { var input = document.getElementById(\"itemId\") ws = new WebSocket(\"ws://localhost:8000/items/\" + input.value + \"/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; } function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) async def get_cookie_or_client ( websocket : WebSocket , session : str = Cookie ( None ), x_client : str = Header ( None ) ): if session is None and x_client is None : await websocket . close ( code = WS_1008_POLICY_VIOLATION ) return session or x_client @app . websocket ( \"/items/ {item_id} /ws\" ) async def websocket_endpoint ( websocket : WebSocket , item_id : int , q : str = None , cookie_or_client : str = Depends ( get_cookie_or_client ), ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Session Cookie or X-Client Header value is: {cookie_or_client} \" ) if q is not None : await websocket . send_text ( f \"Query parameter q is: {q} \" ) await websocket . send_text ( f \"Message text was: {data} , for item ID: {item_id} \" ) Info In a WebSocket it doesn't really make sense to raise an HTTPException . So it's better to close the WebSocket connection directly. You can use a closing code from the valid codes defined in the specification . In the future, there will be a WebSocketException that you will be able to raise from anywhere, and add exception handlers for it. It depends on the PR #527 in Starlette. More info \u00b6 To learn more about the options, check Starlette's documentation for: Applications ( websocket_route ) . The WebSocket class . Class-based WebSocket handling . Test it \u00b6 If your file is named main.py , run your application with: uvicorn main:app --reload Open your browser at http://127.0.0.1:8000 . You will see a simple page like: You can type messages in the input box, and send them: And your FastAPI application with WebSockets will respond back: You can send (and receive) many messages: And all of them will use the same WebSocket connection.","title":"WebSockets"},{"location":"advanced/websockets/#websockets-client","text":"","title":"WebSockets client"},{"location":"advanced/websockets/#in-production","text":"In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular. And to communicate using WebSockets with your backend you would probably use your frontend's utilities. Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code. Or you might have any other way to communicate with the WebSocket endpoint. But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string. This, of course, is not optimal and you wouldn't use it for production. In production you would have one of the options above. But it's the simplest way to focus on the server-side of WebSockets and have a working example: from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" )","title":"In production"},{"location":"advanced/websockets/#create-a-websocket","text":"In your FastAPI application, create a websocket : from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" ) Tip In this example we are importing WebSocket from starlette.websockets to use it in the type declaration in the WebSocket route function.","title":"Create a websocket"},{"location":"advanced/websockets/#await-for-messages-and-send-messages","text":"In your WebSocket route you can await for messages and send messages. from fastapi import FastAPI from starlette.responses import HTMLResponse from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( \"/ws\" ) async def websocket_endpoint ( websocket : WebSocket ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Message text was: {data} \" ) You can receive and send binary, text, and JSON data.","title":"Await for messages and send messages"},{"location":"advanced/websockets/#using-depends-and-others","text":"In WebSocket endpoints you can import from fastapi and use: Depends Security Cookie Header Path Query They work the same way as for other FastAPI endpoints/ path operations : from fastapi import Cookie , Depends , FastAPI , Header from starlette.responses import HTMLResponse from starlette.status import WS_1008_POLICY_VIOLATION from starlette.websockets import WebSocket app = FastAPI () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <label>Item ID: <input type=\"text\" id=\"itemId\" autocomplete=\"off\" value=\"foo\"/></label> <button onclick=\"connect(event)\">Connect</button> <br> <label>Message: <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/></label> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = null; function connect(event) { var input = document.getElementById(\"itemId\") ws = new WebSocket(\"ws://localhost:8000/items/\" + input.value + \"/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; } function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) async def get_cookie_or_client ( websocket : WebSocket , session : str = Cookie ( None ), x_client : str = Header ( None ) ): if session is None and x_client is None : await websocket . close ( code = WS_1008_POLICY_VIOLATION ) return session or x_client @app . websocket ( \"/items/ {item_id} /ws\" ) async def websocket_endpoint ( websocket : WebSocket , item_id : int , q : str = None , cookie_or_client : str = Depends ( get_cookie_or_client ), ): await websocket . accept () while True : data = await websocket . receive_text () await websocket . send_text ( f \"Session Cookie or X-Client Header value is: {cookie_or_client} \" ) if q is not None : await websocket . send_text ( f \"Query parameter q is: {q} \" ) await websocket . send_text ( f \"Message text was: {data} , for item ID: {item_id} \" ) Info In a WebSocket it doesn't really make sense to raise an HTTPException . So it's better to close the WebSocket connection directly. You can use a closing code from the valid codes defined in the specification . In the future, there will be a WebSocketException that you will be able to raise from anywhere, and add exception handlers for it. It depends on the PR #527 in Starlette.","title":"Using Depends and others"},{"location":"advanced/websockets/#more-info","text":"To learn more about the options, check Starlette's documentation for: Applications ( websocket_route ) . The WebSocket class . Class-based WebSocket handling .","title":"More info"},{"location":"advanced/websockets/#test-it","text":"If your file is named main.py , run your application with: uvicorn main:app --reload Open your browser at http://127.0.0.1:8000 . You will see a simple page like: You can type messages in the input box, and send them: And your FastAPI application with WebSockets will respond back: You can send (and receive) many messages: And all of them will use the same WebSocket connection.","title":"Test it"},{"location":"advanced/security/","text":"Additional Features \u00b6 There are some extra features to handle security apart from the ones covered in the Tutorial - User Guide: Security . Tip The next sections are not necessarily \"advanced\" . And it's possible that for your use case, the solution is in one of them. Read the Tutorial first \u00b6 The next sections assume you already read the main Tutorial - User Guide: Security . They are all based on the same concepts, but allow some extra functionalities.","title":"Advanced Security - Intro"},{"location":"advanced/security/#additional-features","text":"There are some extra features to handle security apart from the ones covered in the Tutorial - User Guide: Security . Tip The next sections are not necessarily \"advanced\" . And it's possible that for your use case, the solution is in one of them.","title":"Additional Features"},{"location":"advanced/security/#read-the-tutorial-first","text":"The next sections assume you already read the main Tutorial - User Guide: Security . They are all based on the same concepts, but allow some extra functionalities.","title":"Read the Tutorial first"},{"location":"advanced/security/http-basic-auth/","text":"For the simplest cases, you can use HTTP Basic Auth. In HTTP Basic Auth, the application expects a header that contains a username and a password. If it doesn't receive it, it returns an HTTP 401 \"Unauthorized\" error. And returns a header WWW-Authenticate with a value of Basic , and an optional realm parameter. That tells the browser to show the integrated prompt for a username and password. Then, when you type that username and password, the browser sends them in the header automatically. Simple HTTP Basic Auth \u00b6 Import HTTPBasic and HTTPBasicCredentials . Create a \" security scheme\" using HTTPBasic . Use that security with a dependency in your path operation . It returns an object of type HTTPBasicCredentials : It contains the username and password sent. from fastapi import Depends , FastAPI from fastapi.security import HTTPBasic , HTTPBasicCredentials app = FastAPI () security = HTTPBasic () @app . get ( \"/users/me\" ) def read_current_user ( credentials : HTTPBasicCredentials = Depends ( security )): return { \"username\" : credentials . username , \"password\" : credentials . password } When you try to open the URL for the first time (or click the \"Execute\" button in the docs) the browser will ask you for your username and password: Check the username \u00b6 Here's a more complete example. Use a dependency to check if the username and password are correct. For this, use the Python standard module secrets to check the username and password: import secrets from fastapi import Depends , FastAPI , HTTPException from fastapi.security import HTTPBasic , HTTPBasicCredentials from starlette.status import HTTP_401_UNAUTHORIZED app = FastAPI () security = HTTPBasic () def get_current_username ( credentials : HTTPBasicCredentials = Depends ( security )): correct_username = secrets . compare_digest ( credentials . username , \"stanleyjobson\" ) correct_password = secrets . compare_digest ( credentials . password , \"swordfish\" ) if not ( correct_username and correct_password ): raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect email or password\" , headers = { \"WWW-Authenticate\" : \"Basic\" }, ) return credentials . username @app . get ( \"/users/me\" ) def read_current_user ( username : str = Depends ( get_current_username )): return { \"username\" : username } This will ensure that credentials.username is \"stanleyjobson\" , and that credentials.password is \"swordfish\" . This would be similar to: if not ( credentials . username == \"stanleyjobson\" ) or not ( credentials . password == \"swordfish\" ): # Return some error ... But by using the secrets.compare_digest() it will be secure against a type of attacks called \"timing attacks\". Timing Attacks \u00b6 But what's a \"timing attack\"? Let's imagine an attacker is trying to guess the username and password. And that attacker sends a request with a username johndoe and a password love123 . Then the Python code in your application would be equivalent to something like: if \"johndoe\" == \"stanleyjobson\" and \"love123\" == \"swordfish\" : ... But right at the moment Python compares the first j in johndoe to the first s in stanleyjobson , it will return False , because it already knows that those two strings are not the same, thinking that \"there's no need to waste more computation comparing the rest of the letters\". And your application will say \"incorrect user or password\". But then the attacker tries with username stanleyjobsox and password love123 . And your application code does something like: if \"stanleyjobsox\" == \"stanleyjobson\" and \"love123\" == \"swordfish\" : ... Python will have to compare the whole stanleyjobso in both stanleyjobsox and stanleyjobson before realizing that both strings are not the same. So it will take some extra microseconds to reply back \"incorrect user or password\". The time to answer helps the attacker \u00b6 At that point, by noticing that the server took some microseconds longer to send the \"incorrect user or password\" response, the attacker will know that she/he got something right, some of the initial letters were right. And then she/he can try again knowing that it's probably something more similar to stanleyjobsox than to johndoe . A \"professional\" attack \u00b6 Of course, the attacker would not try all this by hand, she/he would write a program to do it, possibly with thousands or millions of tests per second. And would get just one extra correct letter at a time. But doing that, in some minutes or hours the attacker would have guessed the correct username and password, with the \"help\" of our application, just using the time taken to answer. Fix it with secrets.compare_digest() \u00b6 But in our code we are actually using secrets.compare_digest() . In short, it will take the same time to compare stanleyjobsox to stanleyjobson than it takes to compare johndoe to stanleyjobson . And the same for the password. That way, using secrets.compare_digest() in your application code, it will be safe against this whole range of security attacks. Return the error \u00b6 After detecting that the credentials are incorrect, return an HTTPException with a status code 401 (the same returned when no credentials are provided) and add the header WWW-Authenticate to make the browser show the login prompt again: import secrets from fastapi import Depends , FastAPI , HTTPException from fastapi.security import HTTPBasic , HTTPBasicCredentials from starlette.status import HTTP_401_UNAUTHORIZED app = FastAPI () security = HTTPBasic () def get_current_username ( credentials : HTTPBasicCredentials = Depends ( security )): correct_username = secrets . compare_digest ( credentials . username , \"stanleyjobson\" ) correct_password = secrets . compare_digest ( credentials . password , \"swordfish\" ) if not ( correct_username and correct_password ): raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect email or password\" , headers = { \"WWW-Authenticate\" : \"Basic\" }, ) return credentials . username @app . get ( \"/users/me\" ) def read_current_user ( username : str = Depends ( get_current_username )): return { \"username\" : username }","title":"HTTP Basic Auth"},{"location":"advanced/security/http-basic-auth/#simple-http-basic-auth","text":"Import HTTPBasic and HTTPBasicCredentials . Create a \" security scheme\" using HTTPBasic . Use that security with a dependency in your path operation . It returns an object of type HTTPBasicCredentials : It contains the username and password sent. from fastapi import Depends , FastAPI from fastapi.security import HTTPBasic , HTTPBasicCredentials app = FastAPI () security = HTTPBasic () @app . get ( \"/users/me\" ) def read_current_user ( credentials : HTTPBasicCredentials = Depends ( security )): return { \"username\" : credentials . username , \"password\" : credentials . password } When you try to open the URL for the first time (or click the \"Execute\" button in the docs) the browser will ask you for your username and password:","title":"Simple HTTP Basic Auth"},{"location":"advanced/security/http-basic-auth/#check-the-username","text":"Here's a more complete example. Use a dependency to check if the username and password are correct. For this, use the Python standard module secrets to check the username and password: import secrets from fastapi import Depends , FastAPI , HTTPException from fastapi.security import HTTPBasic , HTTPBasicCredentials from starlette.status import HTTP_401_UNAUTHORIZED app = FastAPI () security = HTTPBasic () def get_current_username ( credentials : HTTPBasicCredentials = Depends ( security )): correct_username = secrets . compare_digest ( credentials . username , \"stanleyjobson\" ) correct_password = secrets . compare_digest ( credentials . password , \"swordfish\" ) if not ( correct_username and correct_password ): raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect email or password\" , headers = { \"WWW-Authenticate\" : \"Basic\" }, ) return credentials . username @app . get ( \"/users/me\" ) def read_current_user ( username : str = Depends ( get_current_username )): return { \"username\" : username } This will ensure that credentials.username is \"stanleyjobson\" , and that credentials.password is \"swordfish\" . This would be similar to: if not ( credentials . username == \"stanleyjobson\" ) or not ( credentials . password == \"swordfish\" ): # Return some error ... But by using the secrets.compare_digest() it will be secure against a type of attacks called \"timing attacks\".","title":"Check the username"},{"location":"advanced/security/http-basic-auth/#timing-attacks","text":"But what's a \"timing attack\"? Let's imagine an attacker is trying to guess the username and password. And that attacker sends a request with a username johndoe and a password love123 . Then the Python code in your application would be equivalent to something like: if \"johndoe\" == \"stanleyjobson\" and \"love123\" == \"swordfish\" : ... But right at the moment Python compares the first j in johndoe to the first s in stanleyjobson , it will return False , because it already knows that those two strings are not the same, thinking that \"there's no need to waste more computation comparing the rest of the letters\". And your application will say \"incorrect user or password\". But then the attacker tries with username stanleyjobsox and password love123 . And your application code does something like: if \"stanleyjobsox\" == \"stanleyjobson\" and \"love123\" == \"swordfish\" : ... Python will have to compare the whole stanleyjobso in both stanleyjobsox and stanleyjobson before realizing that both strings are not the same. So it will take some extra microseconds to reply back \"incorrect user or password\".","title":"Timing Attacks"},{"location":"advanced/security/http-basic-auth/#the-time-to-answer-helps-the-attacker","text":"At that point, by noticing that the server took some microseconds longer to send the \"incorrect user or password\" response, the attacker will know that she/he got something right, some of the initial letters were right. And then she/he can try again knowing that it's probably something more similar to stanleyjobsox than to johndoe .","title":"The time to answer helps the attacker"},{"location":"advanced/security/http-basic-auth/#a-professional-attack","text":"Of course, the attacker would not try all this by hand, she/he would write a program to do it, possibly with thousands or millions of tests per second. And would get just one extra correct letter at a time. But doing that, in some minutes or hours the attacker would have guessed the correct username and password, with the \"help\" of our application, just using the time taken to answer.","title":"A \"professional\" attack"},{"location":"advanced/security/http-basic-auth/#fix-it-with-secretscompare_digest","text":"But in our code we are actually using secrets.compare_digest() . In short, it will take the same time to compare stanleyjobsox to stanleyjobson than it takes to compare johndoe to stanleyjobson . And the same for the password. That way, using secrets.compare_digest() in your application code, it will be safe against this whole range of security attacks.","title":"Fix it with secrets.compare_digest()"},{"location":"advanced/security/http-basic-auth/#return-the-error","text":"After detecting that the credentials are incorrect, return an HTTPException with a status code 401 (the same returned when no credentials are provided) and add the header WWW-Authenticate to make the browser show the login prompt again: import secrets from fastapi import Depends , FastAPI , HTTPException from fastapi.security import HTTPBasic , HTTPBasicCredentials from starlette.status import HTTP_401_UNAUTHORIZED app = FastAPI () security = HTTPBasic () def get_current_username ( credentials : HTTPBasicCredentials = Depends ( security )): correct_username = secrets . compare_digest ( credentials . username , \"stanleyjobson\" ) correct_password = secrets . compare_digest ( credentials . password , \"swordfish\" ) if not ( correct_username and correct_password ): raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect email or password\" , headers = { \"WWW-Authenticate\" : \"Basic\" }, ) return credentials . username @app . get ( \"/users/me\" ) def read_current_user ( username : str = Depends ( get_current_username )): return { \"username\" : username }","title":"Return the error"},{"location":"advanced/security/oauth2-scopes/","text":"You can use OAuth2 scopes directly with FastAPI , they are integrated to work seamlessly. This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs). OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications. Every time you \"log in with\" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes. In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your FastAPI application. Warning This is a more or less advanced section. If you are just starting, you can skip it. You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want. But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs. Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code. In many cases, OAuth2 with scopes can be an overkill. But if you know you need it, or you are curious, keep reading. OAuth2 scopes and OpenAPI \u00b6 The OAuth2 specification defines \"scopes\" as a list of strings separated by spaces. The content of each of these strings can have any format, but should not contain spaces. These scopes represent \"permissions\". In OpenAPI (e.g. the API docs), you can define \"security schemes\". When one of these security schemes uses OAuth2, you can also declare and use scopes. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings. Global view \u00b6 First, let's quickly see the parts that change from the examples in the main Tutorial - User Guide for OAuth2 with Password (and hashing), Bearer with JWT tokens . Now using OAuth2 scopes: from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Now let's review those changes step by step. OAuth2 Security scheme \u00b6 The first change is that now we are declaring the OAuth2 security scheme with two available scopes, me and items . The scopes parameter receives a dict with each scope as a key and the description as the value: from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize. And you will be able to select which scopes you want to give access to: me and items . This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc: JWT token with scopes \u00b6 Now, modify the token path operation to return the scopes requested. We are still using the same OAuth2PasswordRequestForm . It includes a property scopes with a list of str , with each scope it received in the request. And we return the scopes as part of the JWT token. Danger For simplicity, here we are just adding the scopes received directly to the token. But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Declare scopes in path operations and dependencies \u00b6 Now we declare that the path operation for /users/me/items/ requires the scope items . For this, we import and use Security from fastapi . You can use Security to declare dependencies (just like Depends ), but Security also receives a parameter scopes with a list of scopes (strings). In this case, we pass a dependency function get_current_active_user to Security (the same way we would do with Depends ). But we also pass a list of scopes, in this case with just one scope: items (it could have more). And the dependency function get_current_active_user can also declare sub-dependencies, not only with Depends but also with Security . Declaring its own sub-dependency function ( get_current_user ), and more scope requirements. In this case, it requires the scope me (it could require more than one scope). Note You don't necessarily need to add different scopes in different places. We are doing it here to demonstrate how FastAPI handles scopes declared at different levels. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Technical Details Security is actually a subclass of Depends , and it has just one extra parameter that we'll see later. But by using Security instead of Depends , FastAPI will know that it can declare security scopes, use them internally, and document the API with OpenAPI. But when you import Query , Path , Depends , Security and others from fastapi , those are actually functions that return special classes. Use SecurityScopes \u00b6 Now update the dependency get_current_user . This is the one used by the dependencies above. Here's were we are using the same OAuth2 scheme we created before, declaring it as a dependency: oauth2_scheme . Because this dependency function doesn't have any scope requirements itself, we can use Depends with oauth2_scheme , we don't have to use Security when we don't need to specify security scopes. We also declare a special parameter of type SecurityScopes , imported from fastapi.security . This SecurityScopes class is similar to Request ( Request was used to get the request object directly). from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Use the scopes \u00b6 The parameter security_scopes will be of type SecurityScopes . It will have a property scopes with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the \"dependants\"... this might sound confusing, it is explained again later below. The security_scopes object (of class SecurityScopes ) also provides a scope_str attribute with a single string, containing those scopes separated by spaces (we are going to use it). We create an HTTPException that we can re-use ( raise ) later at several points. In this exception, we include the scopes required (if any) as a string separated by spaces (using scope_str ). We put that string containing the scopes in in the WWW-Authenticate header (this is part of the spec). from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Verify the username and data shape \u00b6 We verify that we get a username , and extract the scopes. And then we validate that data with the Pydantic model (catching the ValidationError exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the HTTPException we created before. For that, we update the Pydantic model TokenData with a new property scopes . By validating the data with Pydantic we can make sure that we have, for example, exactly a list of str with the scopes and a str with the username . Instead of, for example, a dict , or something else, as it could break the application at some point later, making it a security risk. We also verify that we have a user with that username, and if not, we raise that same exception we created before. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Verify the scopes \u00b6 We now verify that all the scopes required, by this dependency and all the dependants (including path operations ), are included in the scopes provided in the token received, otherwise raise an HTTPException . For this, we use security_scopes.scopes , that contains a list with all these scopes as str . from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Dependency tree and scopes \u00b6 Let's review again this dependency tree and the scopes. As the get_current_active_user dependency has as a sub-dependency on get_current_user , the scope \"me\" declared at get_current_active_user will be included in the list of required scopes in the security_scopes.scopes passed to get_current_user . The path operation itself also declares a scope, \"items\" , so this will also be in the list of security_scopes.scopes passed to get_current_user . Here's how the hierarchy of dependencies and scopes looks like: The path operation read_own_items has: Required scopes [\"items\"] with the dependency: get_current_active_user : The dependency function get_current_active_user has: Required scopes [\"me\"] with the dependency: get_current_user : The dependency function get_current_user has: No scopes required by itself. A dependency using oauth2_scheme . A security_scopes parameter of type SecurityScopes : This security_scopes parameter has a property scopes with a list containing all these scopes declared above, so: security_scopes.scopes will contain [\"me\", \"items\"] for the path operation read_own_items . security_scopes.scopes will contain [\"me\"] for the path operation read_users_me , because it is declared in the dependency get_current_active_user . security_scopes.scopes will contain [] (nothing) for the path operation read_system_status , because it didn't declare any Security with scopes , and its dependency, get_current_user , doesn't declare any scope either. Tip The important and \"magic\" thing here is that get_current_user will have a different list of scopes to check for each path operation . All depending on the scopes declared in each path operation and each dependency in the dependency tree for that specific path operation . More details about SecurityScopes \u00b6 You can use SecurityScopes at any point, and in multiple places, it doesn't have to be at the \"root\" dependency. It will always have the security scopes declared in the current Security dependencies and all the dependants for that specific path operation and that specific dependency tree. Because the SecurityScopes will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different path operations . They will be checked independently for each path operation . Check it \u00b6 If you open the API docs, you can authenticate and specify which scopes you want to authorize. If you don't select any scope, you will be \"authenticated\", but when you try to access /users/me/ or /users/me/items/ you will get an error saying that you don't have enough permissions. You will still be able to access /status/ . And if you select the scope me but not the scope items , you will be able to access /users/me/ but not /users/me/items/ . That's what would happen to a third party application that tried to access one of these path operations with a token provided by a user, depending on how many permissions the user gave the application. About third party integrations \u00b6 In this example we are using the OAuth2 \"password\" flow. This is appropriate when we are logging in to our own application, probably with our own frontend. Because we can trust it to receive the username and password , as we control it. But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows. The most common is the implicit flow. The most secure is the code flow, but is more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow. Note It's common that each authentication provider names their flows in a different way, to make it part of their brand. But in the end, they are implementing the same OAuth2 standard. FastAPI includes utilities for all these OAuth2 authentication flows in fastapi.security.oauth2 . Security in decorator dependencies \u00b6 The same way you can define a list of Depends in the decorator's dependencies parameter (as explained in Dependencies in path operation decorators ), you could also use Security with scopes there.","title":"OAuth2 scopes"},{"location":"advanced/security/oauth2-scopes/#oauth2-scopes-and-openapi","text":"The OAuth2 specification defines \"scopes\" as a list of strings separated by spaces. The content of each of these strings can have any format, but should not contain spaces. These scopes represent \"permissions\". In OpenAPI (e.g. the API docs), you can define \"security schemes\". When one of these security schemes uses OAuth2, you can also declare and use scopes. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings.","title":"OAuth2 scopes and OpenAPI"},{"location":"advanced/security/oauth2-scopes/#global-view","text":"First, let's quickly see the parts that change from the examples in the main Tutorial - User Guide for OAuth2 with Password (and hashing), Bearer with JWT tokens . Now using OAuth2 scopes: from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Now let's review those changes step by step.","title":"Global view"},{"location":"advanced/security/oauth2-scopes/#oauth2-security-scheme","text":"The first change is that now we are declaring the OAuth2 security scheme with two available scopes, me and items . The scopes parameter receives a dict with each scope as a key and the description as the value: from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize. And you will be able to select which scopes you want to give access to: me and items . This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:","title":"OAuth2 Security scheme"},{"location":"advanced/security/oauth2-scopes/#jwt-token-with-scopes","text":"Now, modify the token path operation to return the scopes requested. We are still using the same OAuth2PasswordRequestForm . It includes a property scopes with a list of str , with each scope it received in the request. And we return the scopes as part of the JWT token. Danger For simplicity, here we are just adding the scopes received directly to the token. But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" }","title":"JWT token with scopes"},{"location":"advanced/security/oauth2-scopes/#declare-scopes-in-path-operations-and-dependencies","text":"Now we declare that the path operation for /users/me/items/ requires the scope items . For this, we import and use Security from fastapi . You can use Security to declare dependencies (just like Depends ), but Security also receives a parameter scopes with a list of scopes (strings). In this case, we pass a dependency function get_current_active_user to Security (the same way we would do with Depends ). But we also pass a list of scopes, in this case with just one scope: items (it could have more). And the dependency function get_current_active_user can also declare sub-dependencies, not only with Depends but also with Security . Declaring its own sub-dependency function ( get_current_user ), and more scope requirements. In this case, it requires the scope me (it could require more than one scope). Note You don't necessarily need to add different scopes in different places. We are doing it here to demonstrate how FastAPI handles scopes declared at different levels. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" } Technical Details Security is actually a subclass of Depends , and it has just one extra parameter that we'll see later. But by using Security instead of Depends , FastAPI will know that it can declare security scopes, use them internally, and document the API with OpenAPI. But when you import Query , Path , Depends , Security and others from fastapi , those are actually functions that return special classes.","title":"Declare scopes in path operations and dependencies"},{"location":"advanced/security/oauth2-scopes/#use-securityscopes","text":"Now update the dependency get_current_user . This is the one used by the dependencies above. Here's were we are using the same OAuth2 scheme we created before, declaring it as a dependency: oauth2_scheme . Because this dependency function doesn't have any scope requirements itself, we can use Depends with oauth2_scheme , we don't have to use Security when we don't need to specify security scopes. We also declare a special parameter of type SecurityScopes , imported from fastapi.security . This SecurityScopes class is similar to Request ( Request was used to get the request object directly). from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" }","title":"Use SecurityScopes"},{"location":"advanced/security/oauth2-scopes/#use-the-scopes","text":"The parameter security_scopes will be of type SecurityScopes . It will have a property scopes with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the \"dependants\"... this might sound confusing, it is explained again later below. The security_scopes object (of class SecurityScopes ) also provides a scope_str attribute with a single string, containing those scopes separated by spaces (we are going to use it). We create an HTTPException that we can re-use ( raise ) later at several points. In this exception, we include the scopes required (if any) as a string separated by spaces (using scope_str ). We put that string containing the scopes in in the WWW-Authenticate header (this is part of the spec). from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" }","title":"Use the scopes"},{"location":"advanced/security/oauth2-scopes/#verify-the-username-and-data-shape","text":"We verify that we get a username , and extract the scopes. And then we validate that data with the Pydantic model (catching the ValidationError exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the HTTPException we created before. For that, we update the Pydantic model TokenData with a new property scopes . By validating the data with Pydantic we can make sure that we have, for example, exactly a list of str with the scopes and a str with the username . Instead of, for example, a dict , or something else, as it could break the application at some point later, making it a security risk. We also verify that we have a user with that username, and if not, we raise that same exception we created before. from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" }","title":"Verify the username and data shape"},{"location":"advanced/security/oauth2-scopes/#verify-the-scopes","text":"We now verify that all the scopes required, by this dependency and all the dependants (including path operations ), are included in the scopes provided in the token received, otherwise raise an HTTPException . For this, we use security_scopes.scopes , that contains a list with all these scopes as str . from datetime import datetime , timedelta from typing import List import jwt from fastapi import Depends , FastAPI , HTTPException , Security from fastapi.security import ( OAuth2PasswordBearer , OAuth2PasswordRequestForm , SecurityScopes , ) from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel , ValidationError from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Chains\" , \"email\" : \"alicechains@example.com\" , \"hashed_password\" : \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\" , \"disabled\" : True , }, } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None scopes : List [ str ] = [] class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" , scopes = { \"me\" : \"Read information about the current user.\" , \"items\" : \"Read items.\" }, ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( security_scopes : SecurityScopes , token : str = Depends ( oauth2_scheme ) ): if security_scopes . scopes : authenticate_value = f 'Bearer scope=\" {security_scopes.scope_str} \"' else : authenticate_value = f \"Bearer\" credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_scopes = payload . get ( \"scopes\" , []) token_data = TokenData ( scopes = token_scopes , username = username ) except ( PyJWTError , ValidationError ): raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception for scope in security_scopes . scopes : if scope not in token_data . scopes : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Not enough permissions\" , headers = { \"WWW-Authenticate\" : authenticate_value }, ) return user async def get_current_active_user ( current_user : User = Security ( get_current_user , scopes = [ \"me\" ]) ): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username , \"scopes\" : form_data . scopes }, expires_delta = access_token_expires , ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Security ( get_current_active_user , scopes = [ \"items\" ]) ): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] @app . get ( \"/status/\" ) async def read_system_status ( current_user : User = Depends ( get_current_user )): return { \"status\" : \"ok\" }","title":"Verify the scopes"},{"location":"advanced/security/oauth2-scopes/#dependency-tree-and-scopes","text":"Let's review again this dependency tree and the scopes. As the get_current_active_user dependency has as a sub-dependency on get_current_user , the scope \"me\" declared at get_current_active_user will be included in the list of required scopes in the security_scopes.scopes passed to get_current_user . The path operation itself also declares a scope, \"items\" , so this will also be in the list of security_scopes.scopes passed to get_current_user . Here's how the hierarchy of dependencies and scopes looks like: The path operation read_own_items has: Required scopes [\"items\"] with the dependency: get_current_active_user : The dependency function get_current_active_user has: Required scopes [\"me\"] with the dependency: get_current_user : The dependency function get_current_user has: No scopes required by itself. A dependency using oauth2_scheme . A security_scopes parameter of type SecurityScopes : This security_scopes parameter has a property scopes with a list containing all these scopes declared above, so: security_scopes.scopes will contain [\"me\", \"items\"] for the path operation read_own_items . security_scopes.scopes will contain [\"me\"] for the path operation read_users_me , because it is declared in the dependency get_current_active_user . security_scopes.scopes will contain [] (nothing) for the path operation read_system_status , because it didn't declare any Security with scopes , and its dependency, get_current_user , doesn't declare any scope either. Tip The important and \"magic\" thing here is that get_current_user will have a different list of scopes to check for each path operation . All depending on the scopes declared in each path operation and each dependency in the dependency tree for that specific path operation .","title":"Dependency tree and scopes"},{"location":"advanced/security/oauth2-scopes/#more-details-about-securityscopes","text":"You can use SecurityScopes at any point, and in multiple places, it doesn't have to be at the \"root\" dependency. It will always have the security scopes declared in the current Security dependencies and all the dependants for that specific path operation and that specific dependency tree. Because the SecurityScopes will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different path operations . They will be checked independently for each path operation .","title":"More details about SecurityScopes"},{"location":"advanced/security/oauth2-scopes/#check-it","text":"If you open the API docs, you can authenticate and specify which scopes you want to authorize. If you don't select any scope, you will be \"authenticated\", but when you try to access /users/me/ or /users/me/items/ you will get an error saying that you don't have enough permissions. You will still be able to access /status/ . And if you select the scope me but not the scope items , you will be able to access /users/me/ but not /users/me/items/ . That's what would happen to a third party application that tried to access one of these path operations with a token provided by a user, depending on how many permissions the user gave the application.","title":"Check it"},{"location":"advanced/security/oauth2-scopes/#about-third-party-integrations","text":"In this example we are using the OAuth2 \"password\" flow. This is appropriate when we are logging in to our own application, probably with our own frontend. Because we can trust it to receive the username and password , as we control it. But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows. The most common is the implicit flow. The most secure is the code flow, but is more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow. Note It's common that each authentication provider names their flows in a different way, to make it part of their brand. But in the end, they are implementing the same OAuth2 standard. FastAPI includes utilities for all these OAuth2 authentication flows in fastapi.security.oauth2 .","title":"About third party integrations"},{"location":"advanced/security/oauth2-scopes/#security-in-decorator-dependencies","text":"The same way you can define a list of Depends in the decorator's dependencies parameter (as explained in Dependencies in path operation decorators ), you could also use Security with scopes there.","title":"Security in decorator dependencies"},{"location":"tutorial/","text":"This tutorial shows you how to use FastAPI with most of its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs. It is also built to work as a future reference. So you can come back and see exactly what you need. Run the code \u00b6 All the code blocks can be copied and used directly (they are actually tested Python files). To run any of the examples, copy the code to a file main.py , and start uvicorn with: uvicorn main:app --reload It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc. Install FastAPI \u00b6 The first step is to install FastAPI. For the tutorial, you might want to install it with all the optional dependencies and features: pip install fastapi [ all ] ...that also includes uvicorn , that you can use as the server that runs your code. Note You can also install it part by part. This is what you would probably do once you want to deploy your application to production: pip install fastapi Also install uvicorn to work as the server: pip install uvicorn And the same for each of the optional dependencies that you want to use. Advanced User Guide \u00b6 There is also an Advanced User Guide that you can read later after this Tutorial - User guide . The Advanced User Guide , builds on this, uses the same concepts, and teaches you some extra features. But you should first read the Tutorial - User guide (what you are reading right now). It's designed so that you can build a complete application with just the Tutorial - User guide , and then extend it in different ways, depending on your needs, using some of the additional ideas from the Advanced User Guide .","title":"Tutorial - User Guide - Intro"},{"location":"tutorial/#run-the-code","text":"All the code blocks can be copied and used directly (they are actually tested Python files). To run any of the examples, copy the code to a file main.py , and start uvicorn with: uvicorn main:app --reload It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc.","title":"Run the code"},{"location":"tutorial/#install-fastapi","text":"The first step is to install FastAPI. For the tutorial, you might want to install it with all the optional dependencies and features: pip install fastapi [ all ] ...that also includes uvicorn , that you can use as the server that runs your code. Note You can also install it part by part. This is what you would probably do once you want to deploy your application to production: pip install fastapi Also install uvicorn to work as the server: pip install uvicorn And the same for each of the optional dependencies that you want to use.","title":"Install FastAPI"},{"location":"tutorial/#advanced-user-guide","text":"There is also an Advanced User Guide that you can read later after this Tutorial - User guide . The Advanced User Guide , builds on this, uses the same concepts, and teaches you some extra features. But you should first read the Tutorial - User guide (what you are reading right now). It's designed so that you can build a complete application with just the Tutorial - User guide , and then extend it in different ways, depending on your needs, using some of the additional ideas from the Advanced User Guide .","title":"Advanced User Guide"},{"location":"tutorial/application-configuration/","text":"There are several things that you can configure in your FastAPI application. Title, description, and version \u00b6 You can set the: Title: used as your API's title/name, in OpenAPI and the automatic API docs UIs. Description: the description of your API, in OpenAPI and the automatic API docs UIs. Version: the version of your API, e.g. v2 or 2.5.0 . Useful for example if you had a previous version of the application, also using OpenAPI. To set them, use the parameters title , description , and version : from fastapi import FastAPI app = FastAPI ( title = \"My Super Project\" , description = \"This is a very fancy project, with auto docs for the API and everything\" , version = \"2.5.0\" , ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] With this configuration, the automatic API docs would look like: OpenAPI URL \u00b6 By default, the OpenAPI schema is served at /openapi.json . But you can configure it with the parameter openapi_url . For example, to set it to be served at /api/v1/openapi.json : from fastapi import FastAPI app = FastAPI ( openapi_url = \"/api/v1/openapi.json\" ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] If you want to disable the OpenAPI schema completely you can set openapi_url=None . Docs URLs \u00b6 You can configure the two documentation user interfaces included: Swagger UI : served at /docs . You can set its URL with the parameter docs_url . You can disable it by setting docs_url=None . ReDoc: served at /redoc . You can set its URL with the parameter redoc_url . You can disable it by setting redoc_url=None . For example, to set Swagger UI to be served at /documentation and disable ReDoc: from fastapi import FastAPI app = FastAPI ( docs_url = \"/documentation\" , redoc_url = None ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }]","title":"Application Configuration"},{"location":"tutorial/application-configuration/#title-description-and-version","text":"You can set the: Title: used as your API's title/name, in OpenAPI and the automatic API docs UIs. Description: the description of your API, in OpenAPI and the automatic API docs UIs. Version: the version of your API, e.g. v2 or 2.5.0 . Useful for example if you had a previous version of the application, also using OpenAPI. To set them, use the parameters title , description , and version : from fastapi import FastAPI app = FastAPI ( title = \"My Super Project\" , description = \"This is a very fancy project, with auto docs for the API and everything\" , version = \"2.5.0\" , ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] With this configuration, the automatic API docs would look like:","title":"Title, description, and version"},{"location":"tutorial/application-configuration/#openapi-url","text":"By default, the OpenAPI schema is served at /openapi.json . But you can configure it with the parameter openapi_url . For example, to set it to be served at /api/v1/openapi.json : from fastapi import FastAPI app = FastAPI ( openapi_url = \"/api/v1/openapi.json\" ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }] If you want to disable the OpenAPI schema completely you can set openapi_url=None .","title":"OpenAPI URL"},{"location":"tutorial/application-configuration/#docs-urls","text":"You can configure the two documentation user interfaces included: Swagger UI : served at /docs . You can set its URL with the parameter docs_url . You can disable it by setting docs_url=None . ReDoc: served at /redoc . You can set its URL with the parameter redoc_url . You can disable it by setting redoc_url=None . For example, to set Swagger UI to be served at /documentation and disable ReDoc: from fastapi import FastAPI app = FastAPI ( docs_url = \"/documentation\" , redoc_url = None ) @app . get ( \"/items/\" ) async def read_items (): return [{ \"name\" : \"Foo\" }]","title":"Docs URLs"},{"location":"tutorial/background-tasks/","text":"You can define background tasks to be run after returning a response. This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving his response. This includes, for example: Email notifications sent after performing an action: As connecting to an email server and sending an email tends to be \"slow\" (several seconds), you can return the response right away and send the email notification in the background. Processing data: For example, let's say you receive a file that must go through a slow process, you can return a response of \"Accepted\" (HTTP 202) and process it in the background. Using BackgroundTasks \u00b6 First, import BackgroundTasks and define a parameter in your path operation function with a type declaration of BackgroundTasks : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" } FastAPI will create the object of type BackgroundTasks for you and pass it as that parameter. Create a task function \u00b6 Create a function to be run as the background task. It is just a standard function that can receive parameters. It can be an async def or normal def function, FastAPI will know how to handle it correctly. In this case, the task function will write to a file (simulating sending an email). And as the write operation doesn't use async and await , we define the function with normal def : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" } Add the background task \u00b6 Inside of your path operation function , pass your task function to the background tasks object with the method .add_task() : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" } .add_task() receives as arguments: A task function to be run in the background ( write_notification ). Any sequence of arguments that should be passed to the task function in order ( email ). Any keyword arguments that should be passed to the task function ( message=\"some notification\" ). Dependency Injection \u00b6 Using BackgroundTasks also works with the dependency injection system, you can declare a parameter of type BackgroundTasks at multiple levels: in a path operation function , in a dependency (dependable), in a sub-dependency, etc. FastAPI knows what to do in each case and how to re-use the same object, so that all the background tasks are merged together and are run in the background afterwards: from fastapi import BackgroundTasks , Depends , FastAPI app = FastAPI () def write_log ( message : str ): with open ( \"log.txt\" , mode = \"a\" ) as log : log . write ( message ) def get_query ( background_tasks : BackgroundTasks , q : str = None ): if q : message = f \"found query: {q} \\n \" background_tasks . add_task ( write_log , message ) return q @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks , q : str = Depends ( get_query ) ): message = f \"message to {email} \\n \" background_tasks . add_task ( write_log , message ) return { \"message\" : \"Message sent\" } In this example, the messages will be written to the log.txt file after the response is sent. If there was a query in the request, it will be written to the log in a background task. And then another background task generated at the path operation function will write a message using the email path parameter. Technical Details \u00b6 The class BackgroundTasks comes directly from starlette.background . It is imported/included directly into FastAPI so that you can import it from fastapi and avoid accidentally importing the alternative BackgroundTask (without the s at the end) from starlette.background . By only using BackgroundTasks (and not BackgroundTask ), it's then possible to use it as a path operation function parameter and have FastAPI handle the rest for you, just like when using the Request object directly. It's still possible to use BackgroundTask alone in FastAPI, but you have to create the object in your code and return a Starlette Response including it. You can see more details in Starlette's official docs for Background Tasks . Caveat \u00b6 If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like Celery . They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers. To see an example, check the Project Generators , they all include Celery already configured. But if you need to access variables and objects from the same FastAPI app, or you need to perform small background tasks (like sending an email notification), you can simply just use BackgroundTasks . Recap \u00b6 Import and use BackgroundTasks with parameters in path operation functions and dependencies to add background tasks.","title":"Background Tasks"},{"location":"tutorial/background-tasks/#using-backgroundtasks","text":"First, import BackgroundTasks and define a parameter in your path operation function with a type declaration of BackgroundTasks : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" } FastAPI will create the object of type BackgroundTasks for you and pass it as that parameter.","title":"Using BackgroundTasks"},{"location":"tutorial/background-tasks/#create-a-task-function","text":"Create a function to be run as the background task. It is just a standard function that can receive parameters. It can be an async def or normal def function, FastAPI will know how to handle it correctly. In this case, the task function will write to a file (simulating sending an email). And as the write operation doesn't use async and await , we define the function with normal def : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" }","title":"Create a task function"},{"location":"tutorial/background-tasks/#add-the-background-task","text":"Inside of your path operation function , pass your task function to the background tasks object with the method .add_task() : from fastapi import BackgroundTasks , FastAPI app = FastAPI () def write_notification ( email : str , message = \"\" ): with open ( \"log.txt\" , mode = \"w\" ) as email_file : content = f \"notification for {email} : {message} \" email_file . write ( content ) @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks ): background_tasks . add_task ( write_notification , email , message = \"some notification\" ) return { \"message\" : \"Notification sent in the background\" } .add_task() receives as arguments: A task function to be run in the background ( write_notification ). Any sequence of arguments that should be passed to the task function in order ( email ). Any keyword arguments that should be passed to the task function ( message=\"some notification\" ).","title":"Add the background task"},{"location":"tutorial/background-tasks/#dependency-injection","text":"Using BackgroundTasks also works with the dependency injection system, you can declare a parameter of type BackgroundTasks at multiple levels: in a path operation function , in a dependency (dependable), in a sub-dependency, etc. FastAPI knows what to do in each case and how to re-use the same object, so that all the background tasks are merged together and are run in the background afterwards: from fastapi import BackgroundTasks , Depends , FastAPI app = FastAPI () def write_log ( message : str ): with open ( \"log.txt\" , mode = \"a\" ) as log : log . write ( message ) def get_query ( background_tasks : BackgroundTasks , q : str = None ): if q : message = f \"found query: {q} \\n \" background_tasks . add_task ( write_log , message ) return q @app . post ( \"/send-notification/ {email} \" ) async def send_notification ( email : str , background_tasks : BackgroundTasks , q : str = Depends ( get_query ) ): message = f \"message to {email} \\n \" background_tasks . add_task ( write_log , message ) return { \"message\" : \"Message sent\" } In this example, the messages will be written to the log.txt file after the response is sent. If there was a query in the request, it will be written to the log in a background task. And then another background task generated at the path operation function will write a message using the email path parameter.","title":"Dependency Injection"},{"location":"tutorial/background-tasks/#technical-details","text":"The class BackgroundTasks comes directly from starlette.background . It is imported/included directly into FastAPI so that you can import it from fastapi and avoid accidentally importing the alternative BackgroundTask (without the s at the end) from starlette.background . By only using BackgroundTasks (and not BackgroundTask ), it's then possible to use it as a path operation function parameter and have FastAPI handle the rest for you, just like when using the Request object directly. It's still possible to use BackgroundTask alone in FastAPI, but you have to create the object in your code and return a Starlette Response including it. You can see more details in Starlette's official docs for Background Tasks .","title":"Technical Details"},{"location":"tutorial/background-tasks/#caveat","text":"If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like Celery . They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers. To see an example, check the Project Generators , they all include Celery already configured. But if you need to access variables and objects from the same FastAPI app, or you need to perform small background tasks (like sending an email notification), you can simply just use BackgroundTasks .","title":"Caveat"},{"location":"tutorial/background-tasks/#recap","text":"Import and use BackgroundTasks with parameters in path operation functions and dependencies to add background tasks.","title":"Recap"},{"location":"tutorial/bigger-applications/","text":"If you are building an application or a web API, it's rarely the case that you can put everything on a single file. FastAPI provides a convenience tool to structure your application while keeping all the flexibility. Info If you come from Flask, this would be the equivalent of Flask's Blueprints. An example file structure \u00b6 Let's say you have a file structure like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Tip There are two __init__.py files: one in each directory or subdirectory. This is what allows importing code from one file into another. For example, in app/main.py you could have a line like: from app.routers import items The app directory contains everything. This app directory has an empty file app/__init__.py . So, the app directory is a \"Python package\" (a collection of \"Python modules\"). The app directory also has a app/main.py file. As it is inside a Python package directory (because there's a file __init__.py ), it is a \"module\" of that package: app.main . There's a subdirectory app/routers/ . The subdirectory app/routers also has an empty file __init__.py . So, it is a \"Python subpackage\". The file app/routers/items.py is beside the app/routers/__init__.py . So, it's a submodule: app.routers.items . The file app/routers/users.py is beside the app/routers/__init__.py . So, it's a submodule: app.routers.users . APIRouter \u00b6 Let's say the file dedicated to handling just users is the submodule at /app/routers/users.py . You want to have the path operations related to your users separated from the rest of the code, to keep it organized. But it's still part of the same FastAPI application/web API (it's part of the same \"Python Package\"). You can create the path operations for that module using APIRouter . Import APIRouter \u00b6 You import it and create an \"instance\" the same way you would with the class FastAPI : from fastapi import APIRouter router = APIRouter () @router . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"Foo\" }, { \"username\" : \"Bar\" }] @router . get ( \"/users/me\" , tags = [ \"users\" ]) async def read_user_me (): return { \"username\" : \"fakecurrentuser\" } @router . get ( \"/users/ {username} \" , tags = [ \"users\" ]) async def read_user ( username : str ): return { \"username\" : username } Path operations with APIRouter \u00b6 And then you use it to declare your path operations . Use it the same way you would use the FastAPI class: from fastapi import APIRouter router = APIRouter () @router . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"Foo\" }, { \"username\" : \"Bar\" }] @router . get ( \"/users/me\" , tags = [ \"users\" ]) async def read_user_me (): return { \"username\" : \"fakecurrentuser\" } @router . get ( \"/users/ {username} \" , tags = [ \"users\" ]) async def read_user ( username : str ): return { \"username\" : username } You can think of APIRouter as a \"mini FastAPI \" class. All the same options are supported. All the same parameters, responses, dependencies, tags, etc. Tip In this example, the variable is called router , but you can name it however you want. We are going to include this APIrouter in the main FastAPI app, but first, let's add another APIRouter . Another module with APIRouter \u00b6 Let's say you also have the endpoints dedicated to handling \"Items\" from your application in the module at app/routers/items.py . You have path operations for: /items/ /items/{item_id} It's all the same structure as with app/routers/users.py . But let's say that this time we are more lazy. And we don't want to have to explicitly type /items/ and tags=[\"items\"] in every path operation (we will be able to do it later): from fastapi import APIRouter , HTTPException router = APIRouter () @router . get ( \"/\" ) async def read_items (): return [{ \"name\" : \"Item Foo\" }, { \"name\" : \"item Bar\" }] @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): return { \"name\" : \"Fake Specific Item\" , \"item_id\" : item_id } @router . put ( \"/ {item_id} \" , tags = [ \"custom\" ], responses = { 403 : { \"description\" : \"Operation forbidden\" }}, ) async def update_item ( item_id : str ): if item_id != \"foo\" : raise HTTPException ( status_code = 403 , detail = \"You can only update the item: foo\" ) return { \"item_id\" : item_id , \"name\" : \"The Fighters\" } Add some custom tags , responses , and dependencies \u00b6 We are not adding the prefix /items/ nor the tags=[\"items\"] to add them later. But we can add custom tags and responses that will be applied to a specific path operation : from fastapi import APIRouter , HTTPException router = APIRouter () @router . get ( \"/\" ) async def read_items (): return [{ \"name\" : \"Item Foo\" }, { \"name\" : \"item Bar\" }] @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): return { \"name\" : \"Fake Specific Item\" , \"item_id\" : item_id } @router . put ( \"/ {item_id} \" , tags = [ \"custom\" ], responses = { 403 : { \"description\" : \"Operation forbidden\" }}, ) async def update_item ( item_id : str ): if item_id != \"foo\" : raise HTTPException ( status_code = 403 , detail = \"You can only update the item: foo\" ) return { \"item_id\" : item_id , \"name\" : \"The Fighters\" } The main FastAPI \u00b6 Now, let's see the module at app/main.py . Here's where you import and use the class FastAPI . This will be the main file in your application that ties everything together. Import FastAPI \u00b6 You import and create a FastAPI class as normally: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) Import the APIRouter \u00b6 But this time we are not adding path operations directly with the FastAPI app . We import the other submodules that have APIRouter s: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) As the file app/routers/items.py is part of the same Python package, we can import it using \"dot notation\". How the importing works \u00b6 The section: from .routers import items , users Means: Starting in the same package that this module (the file app/main.py ) lives in (the directory app/ )... look for the subpackage routers (the directory at app/routers/ )... and from it, import the submodule items (the file at app/routers/items.py ) and users (the file at app/routers/users.py )... The module items will have a variable router ( items.router ). This is the same one we created in the file app/routers/items.py . It's an APIRouter . The same for the module users . We could also import them like: from app.routers import items , users Info The first version is a \"relative import\". The second version is an \"absolute import\". To learn more about Python Packages and Modules, read the official Python documentation about Modules . Avoid name collisions \u00b6 We are importing the submodule items directly, instead of importing just its variable router . This is because we also have another variable named router in the submodule users . If we had imported one after the other, like: from .routers.items import router from .routers.users import router The router from users would overwrite the one from items and we wouldn't be able to use them at the same time. So, to be able to use both of them in the same file, we import the submodules directly: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) Include an APIRouter \u00b6 Now, let's include the router from the submodule users : from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) Info users.router contains the APIRouter inside of the file app/routers/users.py . With app.include_router() we can add an APIRouter to the main FastAPI application. It will include all the routes from that router as part of it. Technical Details It will actually internally create a path operation for each path operation that was declared in the APIRouter . So, behind the scenes, it will actually work as if everything was the same single app. Check You don't have to worry about performance when including routers. This will take microseconds and will only happen at startup. So it won't affect performance. Include an APIRouter with a prefix , tags , responses , and dependencies \u00b6 Now, let's include the router from the items submodule. But, remember that we were lazy and didn't add /items/ nor tags to all the path operations ? We can add a prefix to all the path operations using the parameter prefix of app.include_router() . As the path of each path operation has to start with / , like in: @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): ... ...the prefix must not include a final / . So, the prefix in this case would be /items . We can also add a list of tags that will be applied to all the path operations included in this router. And we can add predefined responses that will be included in all the path operations too. And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them. Note that, much like dependencies in path operation decorators , no value will be passed to your path operation function . from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) The end result is that the item paths are now: /items/ /items/{item_id} ...as we intended. They will be marked with a list of tags that contain a single string \"items\" . The path operation that declared a \"custom\" tag will have both tags, items and custom . These \"tags\" are especially useful for the automatic interactive documentation systems (using OpenAPI). All of them will include the predefined responses . The path operation that declared a custom 403 response will have both the predefined responses ( 404 ) and the 403 declared in it directly. All these path operations will have the list of dependencies evaluated/executed before them. If you also declare dependencies in a specific path operation , they will be executed too . The router dependencies are executed first, then the dependencies in the decorator , and then the normal parameter dependencies. You can also add Security dependencies with scopes . Tip Having dependencies in a decorator can be used, for example, to require authentication for a whole group of path operations . Even if the dependencies are not added individually to each one of them. Check The prefix , tags , responses and dependencies parameters are (as in many other cases) just a feature from FastAPI to help you avoid code duplication. Tip You could also add path operations directly, for example with: @app.get(...) . Apart from app.include_router() , in the same FastAPI app. It would still work the same. Very Technical Details Note : this is a very technical detail that you probably can just skip . The APIRouter s are not \"mounted\", they are not isolated from the rest of the application. This is because we want to include their path operations in the OpenAPI schema and the user interfaces. As we cannot just isolate them and \"mount\" them independently of the rest, the path operations are \"cloned\" (re-created), not included directly. Check the automatic API docs \u00b6 Now, run uvicorn , using the module app.main and the variable app : uvicorn app.main:app --reload And open the docs at http://127.0.0.1:8000/docs . You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags: Include the same router multiple times with different prefix \u00b6 You can also use .include_router() multiple times with the same router using different prefixes. This could be useful, for example, to expose the same API under different prefixes, e.g. /api/v1 and /api/latest . This is an advanced usage that you might not really need, but it's there in case you do.","title":"Bigger Applications - Multiple Files"},{"location":"tutorial/bigger-applications/#an-example-file-structure","text":"Let's say you have a file structure like this: . \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Tip There are two __init__.py files: one in each directory or subdirectory. This is what allows importing code from one file into another. For example, in app/main.py you could have a line like: from app.routers import items The app directory contains everything. This app directory has an empty file app/__init__.py . So, the app directory is a \"Python package\" (a collection of \"Python modules\"). The app directory also has a app/main.py file. As it is inside a Python package directory (because there's a file __init__.py ), it is a \"module\" of that package: app.main . There's a subdirectory app/routers/ . The subdirectory app/routers also has an empty file __init__.py . So, it is a \"Python subpackage\". The file app/routers/items.py is beside the app/routers/__init__.py . So, it's a submodule: app.routers.items . The file app/routers/users.py is beside the app/routers/__init__.py . So, it's a submodule: app.routers.users .","title":"An example file structure"},{"location":"tutorial/bigger-applications/#apirouter","text":"Let's say the file dedicated to handling just users is the submodule at /app/routers/users.py . You want to have the path operations related to your users separated from the rest of the code, to keep it organized. But it's still part of the same FastAPI application/web API (it's part of the same \"Python Package\"). You can create the path operations for that module using APIRouter .","title":"APIRouter"},{"location":"tutorial/bigger-applications/#import-apirouter","text":"You import it and create an \"instance\" the same way you would with the class FastAPI : from fastapi import APIRouter router = APIRouter () @router . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"Foo\" }, { \"username\" : \"Bar\" }] @router . get ( \"/users/me\" , tags = [ \"users\" ]) async def read_user_me (): return { \"username\" : \"fakecurrentuser\" } @router . get ( \"/users/ {username} \" , tags = [ \"users\" ]) async def read_user ( username : str ): return { \"username\" : username }","title":"Import APIRouter"},{"location":"tutorial/bigger-applications/#path-operations-with-apirouter","text":"And then you use it to declare your path operations . Use it the same way you would use the FastAPI class: from fastapi import APIRouter router = APIRouter () @router . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"Foo\" }, { \"username\" : \"Bar\" }] @router . get ( \"/users/me\" , tags = [ \"users\" ]) async def read_user_me (): return { \"username\" : \"fakecurrentuser\" } @router . get ( \"/users/ {username} \" , tags = [ \"users\" ]) async def read_user ( username : str ): return { \"username\" : username } You can think of APIRouter as a \"mini FastAPI \" class. All the same options are supported. All the same parameters, responses, dependencies, tags, etc. Tip In this example, the variable is called router , but you can name it however you want. We are going to include this APIrouter in the main FastAPI app, but first, let's add another APIRouter .","title":"Path operations with APIRouter"},{"location":"tutorial/bigger-applications/#another-module-with-apirouter","text":"Let's say you also have the endpoints dedicated to handling \"Items\" from your application in the module at app/routers/items.py . You have path operations for: /items/ /items/{item_id} It's all the same structure as with app/routers/users.py . But let's say that this time we are more lazy. And we don't want to have to explicitly type /items/ and tags=[\"items\"] in every path operation (we will be able to do it later): from fastapi import APIRouter , HTTPException router = APIRouter () @router . get ( \"/\" ) async def read_items (): return [{ \"name\" : \"Item Foo\" }, { \"name\" : \"item Bar\" }] @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): return { \"name\" : \"Fake Specific Item\" , \"item_id\" : item_id } @router . put ( \"/ {item_id} \" , tags = [ \"custom\" ], responses = { 403 : { \"description\" : \"Operation forbidden\" }}, ) async def update_item ( item_id : str ): if item_id != \"foo\" : raise HTTPException ( status_code = 403 , detail = \"You can only update the item: foo\" ) return { \"item_id\" : item_id , \"name\" : \"The Fighters\" }","title":"Another module with APIRouter"},{"location":"tutorial/bigger-applications/#add-some-custom-tags-responses-and-dependencies","text":"We are not adding the prefix /items/ nor the tags=[\"items\"] to add them later. But we can add custom tags and responses that will be applied to a specific path operation : from fastapi import APIRouter , HTTPException router = APIRouter () @router . get ( \"/\" ) async def read_items (): return [{ \"name\" : \"Item Foo\" }, { \"name\" : \"item Bar\" }] @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): return { \"name\" : \"Fake Specific Item\" , \"item_id\" : item_id } @router . put ( \"/ {item_id} \" , tags = [ \"custom\" ], responses = { 403 : { \"description\" : \"Operation forbidden\" }}, ) async def update_item ( item_id : str ): if item_id != \"foo\" : raise HTTPException ( status_code = 403 , detail = \"You can only update the item: foo\" ) return { \"item_id\" : item_id , \"name\" : \"The Fighters\" }","title":"Add some custom tags, responses, and dependencies"},{"location":"tutorial/bigger-applications/#the-main-fastapi","text":"Now, let's see the module at app/main.py . Here's where you import and use the class FastAPI . This will be the main file in your application that ties everything together.","title":"The main FastAPI"},{"location":"tutorial/bigger-applications/#import-fastapi","text":"You import and create a FastAPI class as normally: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, )","title":"Import FastAPI"},{"location":"tutorial/bigger-applications/#import-the-apirouter","text":"But this time we are not adding path operations directly with the FastAPI app . We import the other submodules that have APIRouter s: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) As the file app/routers/items.py is part of the same Python package, we can import it using \"dot notation\".","title":"Import the APIRouter"},{"location":"tutorial/bigger-applications/#how-the-importing-works","text":"The section: from .routers import items , users Means: Starting in the same package that this module (the file app/main.py ) lives in (the directory app/ )... look for the subpackage routers (the directory at app/routers/ )... and from it, import the submodule items (the file at app/routers/items.py ) and users (the file at app/routers/users.py )... The module items will have a variable router ( items.router ). This is the same one we created in the file app/routers/items.py . It's an APIRouter . The same for the module users . We could also import them like: from app.routers import items , users Info The first version is a \"relative import\". The second version is an \"absolute import\". To learn more about Python Packages and Modules, read the official Python documentation about Modules .","title":"How the importing works"},{"location":"tutorial/bigger-applications/#avoid-name-collisions","text":"We are importing the submodule items directly, instead of importing just its variable router . This is because we also have another variable named router in the submodule users . If we had imported one after the other, like: from .routers.items import router from .routers.users import router The router from users would overwrite the one from items and we wouldn't be able to use them at the same time. So, to be able to use both of them in the same file, we import the submodules directly: from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, )","title":"Avoid name collisions"},{"location":"tutorial/bigger-applications/#include-an-apirouter","text":"Now, let's include the router from the submodule users : from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) Info users.router contains the APIRouter inside of the file app/routers/users.py . With app.include_router() we can add an APIRouter to the main FastAPI application. It will include all the routes from that router as part of it. Technical Details It will actually internally create a path operation for each path operation that was declared in the APIRouter . So, behind the scenes, it will actually work as if everything was the same single app. Check You don't have to worry about performance when including routers. This will take microseconds and will only happen at startup. So it won't affect performance.","title":"Include an APIRouter"},{"location":"tutorial/bigger-applications/#include-an-apirouter-with-a-prefix-tags-responses-and-dependencies","text":"Now, let's include the router from the items submodule. But, remember that we were lazy and didn't add /items/ nor tags to all the path operations ? We can add a prefix to all the path operations using the parameter prefix of app.include_router() . As the path of each path operation has to start with / , like in: @router . get ( \"/ {item_id} \" ) async def read_item ( item_id : str ): ... ...the prefix must not include a final / . So, the prefix in this case would be /items . We can also add a list of tags that will be applied to all the path operations included in this router. And we can add predefined responses that will be included in all the path operations too. And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them. Note that, much like dependencies in path operation decorators , no value will be passed to your path operation function . from fastapi import Depends , FastAPI , Header , HTTPException from .routers import items , users app = FastAPI () async def get_token_header ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) app . include_router ( users . router ) app . include_router ( items . router , prefix = \"/items\" , tags = [ \"items\" ], dependencies = [ Depends ( get_token_header )], responses = { 404 : { \"description\" : \"Not found\" }}, ) The end result is that the item paths are now: /items/ /items/{item_id} ...as we intended. They will be marked with a list of tags that contain a single string \"items\" . The path operation that declared a \"custom\" tag will have both tags, items and custom . These \"tags\" are especially useful for the automatic interactive documentation systems (using OpenAPI). All of them will include the predefined responses . The path operation that declared a custom 403 response will have both the predefined responses ( 404 ) and the 403 declared in it directly. All these path operations will have the list of dependencies evaluated/executed before them. If you also declare dependencies in a specific path operation , they will be executed too . The router dependencies are executed first, then the dependencies in the decorator , and then the normal parameter dependencies. You can also add Security dependencies with scopes . Tip Having dependencies in a decorator can be used, for example, to require authentication for a whole group of path operations . Even if the dependencies are not added individually to each one of them. Check The prefix , tags , responses and dependencies parameters are (as in many other cases) just a feature from FastAPI to help you avoid code duplication. Tip You could also add path operations directly, for example with: @app.get(...) . Apart from app.include_router() , in the same FastAPI app. It would still work the same. Very Technical Details Note : this is a very technical detail that you probably can just skip . The APIRouter s are not \"mounted\", they are not isolated from the rest of the application. This is because we want to include their path operations in the OpenAPI schema and the user interfaces. As we cannot just isolate them and \"mount\" them independently of the rest, the path operations are \"cloned\" (re-created), not included directly.","title":"Include an APIRouter with a prefix, tags, responses, and dependencies"},{"location":"tutorial/bigger-applications/#check-the-automatic-api-docs","text":"Now, run uvicorn , using the module app.main and the variable app : uvicorn app.main:app --reload And open the docs at http://127.0.0.1:8000/docs . You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:","title":"Check the automatic API docs"},{"location":"tutorial/bigger-applications/#include-the-same-router-multiple-times-with-different-prefix","text":"You can also use .include_router() multiple times with the same router using different prefixes. This could be useful, for example, to expose the same API under different prefixes, e.g. /api/v1 and /api/latest . This is an advanced usage that you might not really need, but it's there in case you do.","title":"Include the same router multiple times with different prefix"},{"location":"tutorial/body-fields/","text":"The same way you can declare additional validation and metadata in path operation function parameters with Query , Path and Body , you can declare validation and metadata inside of Pydantic models using Pydantic's Field . Import Field \u00b6 First, you have to import it: from fastapi import Body , FastAPI from pydantic import BaseModel , Field app = FastAPI () class Item ( BaseModel ): name : str description : str = Field ( None , title = \"The description of the item\" , max_length = 300 ) price : float = Field ( ... , gt = 0 , description = \"The price must be greater than zero\" ) tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results Warning Notice that Field is imported directly from pydantic , not from fastapi as are all the rest ( Query , Path , Body , etc). Declare model attributes \u00b6 You can then use Field with model attributes: from fastapi import Body , FastAPI from pydantic import BaseModel , Field app = FastAPI () class Item ( BaseModel ): name : str description : str = Field ( None , title = \"The description of the item\" , max_length = 300 ) price : float = Field ( ... , gt = 0 , description = \"The price must be greater than zero\" ) tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results Field works the same way as Query , Path and Body , it has all the same parameters, etc. Technical Details Actually, Query , Path and others you'll see next create objects of subclasses of a common Param class, which is itself a subclass of Pydantic's FieldInfo class. And Pydantic's Field returns an instance of FieldInfo as well. Body also returns objects of a subclass of FieldInfo directly. And there are others you will see later that are subclasses of the Body class. Remember that when you import Query , Path , and others from fastapi , those are actually functions that return special classes. Tip Notice how each model's attribute with a type, default value and Field has the same structure as a path operation function's parameter, with Field instead of Path , Query and Body . JSON Schema extras \u00b6 In Field , Path , Query , Body and others you'll see later, you can declare extra parameters apart from those described before. Those parameters will be added as-is to the output JSON Schema. If you know JSON Schema and want to add extra information apart from what we have discussed here, you can pass that as extra keyword arguments. Warning Have in mind that extra parameters passed won't add any validation, only annotation, for documentation purposes. For example, you can use that functionality to pass a JSON Schema example field to a body request JSON Schema: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , example = { \"name\" : \"Foo\" , \"description\" : \"A very nice Item\" , \"price\" : 35.4 , \"tax\" : 3.2 , }, ) ): results = { \"item_id\" : item_id , \"item\" : item } return results And it would look in the /docs like this: Recap \u00b6 You can use Pydantic's Field to declare extra validations and metadata for model attributes. You can also use the extra keyword arguments to pass additional JSON Schema metadata.","title":"Body - Fields"},{"location":"tutorial/body-fields/#import-field","text":"First, you have to import it: from fastapi import Body , FastAPI from pydantic import BaseModel , Field app = FastAPI () class Item ( BaseModel ): name : str description : str = Field ( None , title = \"The description of the item\" , max_length = 300 ) price : float = Field ( ... , gt = 0 , description = \"The price must be greater than zero\" ) tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results Warning Notice that Field is imported directly from pydantic , not from fastapi as are all the rest ( Query , Path , Body , etc).","title":"Import Field"},{"location":"tutorial/body-fields/#declare-model-attributes","text":"You can then use Field with model attributes: from fastapi import Body , FastAPI from pydantic import BaseModel , Field app = FastAPI () class Item ( BaseModel ): name : str description : str = Field ( None , title = \"The description of the item\" , max_length = 300 ) price : float = Field ( ... , gt = 0 , description = \"The price must be greater than zero\" ) tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results Field works the same way as Query , Path and Body , it has all the same parameters, etc. Technical Details Actually, Query , Path and others you'll see next create objects of subclasses of a common Param class, which is itself a subclass of Pydantic's FieldInfo class. And Pydantic's Field returns an instance of FieldInfo as well. Body also returns objects of a subclass of FieldInfo directly. And there are others you will see later that are subclasses of the Body class. Remember that when you import Query , Path , and others from fastapi , those are actually functions that return special classes. Tip Notice how each model's attribute with a type, default value and Field has the same structure as a path operation function's parameter, with Field instead of Path , Query and Body .","title":"Declare model attributes"},{"location":"tutorial/body-fields/#json-schema-extras","text":"In Field , Path , Query , Body and others you'll see later, you can declare extra parameters apart from those described before. Those parameters will be added as-is to the output JSON Schema. If you know JSON Schema and want to add extra information apart from what we have discussed here, you can pass that as extra keyword arguments. Warning Have in mind that extra parameters passed won't add any validation, only annotation, for documentation purposes. For example, you can use that functionality to pass a JSON Schema example field to a body request JSON Schema: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , example = { \"name\" : \"Foo\" , \"description\" : \"A very nice Item\" , \"price\" : 35.4 , \"tax\" : 3.2 , }, ) ): results = { \"item_id\" : item_id , \"item\" : item } return results And it would look in the /docs like this:","title":"JSON Schema extras"},{"location":"tutorial/body-fields/#recap","text":"You can use Pydantic's Field to declare extra validations and metadata for model attributes. You can also use the extra keyword arguments to pass additional JSON Schema metadata.","title":"Recap"},{"location":"tutorial/body-multiple-params/","text":"Now that we have seen how to use Path and Query , let's see more advanced uses of request body declarations. Mix Path , Query and body parameters \u00b6 First, of course, you can mix Path , Query and request body parameter declarations freely and FastAPI will know what to do. And you can also declare body parameters as optional, by setting the default to None : from fastapi import FastAPI , Path from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 0 , le = 1000 ), q : str = None , item : Item = None , ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) if item : results . update ({ \"item\" : item }) return results Note Notice that, in this case, the item that would be taken from the body is optional. As it has a None default value. Multiple body parameters \u00b6 In the previous example, the path operations would expect a JSON body with the attributes of an Item , like: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 } But you can also declare multiple body parameters, e.g. item and user : from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user } return results In this case, FastAPI will notice that there are more than one body parameters in the function (two parameters that are Pydantic models). So, it will then use the parameter names as keys (field names) in the body, and expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" } } Note Notice that even though the item was declared the same way as before, it is now expected to be inside of the body with a key item . FastAPI will do the automatic conversion from the request, so that the parameter item receives it's specific content and the same for user . It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs. Singular values in body \u00b6 The same way there is a Query and Path to define extra data for query and path parameters, FastAPI provides an equivalent Body . For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user . If you declare it as is, because it is a singular value, FastAPI will assume that it is a query parameter. But you can instruct FastAPI to treat it as another body key using Body : from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User , importance : int = Body ( ... ) ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } return results In this case, FastAPI will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" }, \"importance\" : 5 } Again, it will convert the data types, validate, document, etc. Multiple body params and query \u00b6 Of course, you can also declare additional query parameters whenever you need, additional to any body parameters. As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query , you can just do: q : str = None as in: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User , importance : int = Body ( ... , gt = 0 ), q : str = None ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } if q : results . update ({ \"q\" : q }) return results Info Body also has all the same extra validation and metadata parameters as Query , Path and others you will see later. Embed a single body parameter \u00b6 Let's say you only have a single item body parameter from a Pydantic model Item . By default, FastAPI will then expect its body directly. But if you want it to expect a JSON with a key item and inside of it the model contents, as it does when you declare extra body parameters, you can use the special Body parameter embed : item : Item = Body ( ... , embed = True ) as in: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results In this case FastAPI will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 } } instead of: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 } Recap \u00b6 You can add multiple body parameters to your path operation function , even though a request can only have a single body. But FastAPI will handle it, give you the correct data in your function, and validate and document the correct schema in the path operation . You can also declare singular values to be received as part of the body. And you can instruct FastAPI to embed the body in a key even when there is only a single parameter declared.","title":"Body - Multiple Parameters"},{"location":"tutorial/body-multiple-params/#mix-path-query-and-body-parameters","text":"First, of course, you can mix Path , Query and request body parameter declarations freely and FastAPI will know what to do. And you can also declare body parameters as optional, by setting the default to None : from fastapi import FastAPI , Path from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 0 , le = 1000 ), q : str = None , item : Item = None , ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) if item : results . update ({ \"item\" : item }) return results Note Notice that, in this case, the item that would be taken from the body is optional. As it has a None default value.","title":"Mix Path, Query and body parameters"},{"location":"tutorial/body-multiple-params/#multiple-body-parameters","text":"In the previous example, the path operations would expect a JSON body with the attributes of an Item , like: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 } But you can also declare multiple body parameters, e.g. item and user : from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user } return results In this case, FastAPI will notice that there are more than one body parameters in the function (two parameters that are Pydantic models). So, it will then use the parameter names as keys (field names) in the body, and expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" } } Note Notice that even though the item was declared the same way as before, it is now expected to be inside of the body with a key item . FastAPI will do the automatic conversion from the request, so that the parameter item receives it's specific content and the same for user . It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.","title":"Multiple body parameters"},{"location":"tutorial/body-multiple-params/#singular-values-in-body","text":"The same way there is a Query and Path to define extra data for query and path parameters, FastAPI provides an equivalent Body . For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user . If you declare it as is, because it is a singular value, FastAPI will assume that it is a query parameter. But you can instruct FastAPI to treat it as another body key using Body : from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User , importance : int = Body ( ... ) ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } return results In this case, FastAPI will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" }, \"importance\" : 5 } Again, it will convert the data types, validate, document, etc.","title":"Singular values in body"},{"location":"tutorial/body-multiple-params/#multiple-body-params-and-query","text":"Of course, you can also declare additional query parameters whenever you need, additional to any body parameters. As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query , you can just do: q : str = None as in: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None class User ( BaseModel ): username : str full_name : str = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item , user : User , importance : int = Body ( ... , gt = 0 ), q : str = None ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } if q : results . update ({ \"q\" : q }) return results Info Body also has all the same extra validation and metadata parameters as Query , Path and others you will see later.","title":"Multiple body params and query"},{"location":"tutorial/body-multiple-params/#embed-a-single-body-parameter","text":"Let's say you only have a single item body parameter from a Pydantic model Item . By default, FastAPI will then expect its body directly. But if you want it to expect a JSON with a key item and inside of it the model contents, as it does when you declare extra body parameters, you can use the special Body parameter embed : item : Item = Body ( ... , embed = True ) as in: from fastapi import Body , FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item = Body ( ... , embed = True )): results = { \"item_id\" : item_id , \"item\" : item } return results In this case FastAPI will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 } } instead of: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }","title":"Embed a single body parameter"},{"location":"tutorial/body-multiple-params/#recap","text":"You can add multiple body parameters to your path operation function , even though a request can only have a single body. But FastAPI will handle it, give you the correct data in your function, and validate and document the correct schema in the path operation . You can also declare singular values to be received as part of the body. And you can instruct FastAPI to embed the body in a key even when there is only a single parameter declared.","title":"Recap"},{"location":"tutorial/body-nested-models/","text":"With FastAPI , you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic). List fields \u00b6 You can define an attribute to be a subtype. For example, a Python list : from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : list = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This will make tags be a list of items. Although it doesn't declare the type of each of the items. List fields with subtype \u00b6 But Python has a specific way to declare lists with subtypes: Import typing's List \u00b6 First, import List from standard Python's typing module: from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : List [ str ] = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results Declare a List with a subtype \u00b6 To declare types that have subtypes, like list , dict , tuple : Import them from the typing module Pass the subtype(s) as \"type arguments\" using square brackets: [ and ] from typing import List my_list : List [ str ] That's all standard Python syntax for type declarations. Use that same standard syntax for model attributes with subtypes. So, in our example, we can make tags be specifically a \"list of strings\": from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : List [ str ] = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results Set types \u00b6 But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings. And Python has a special data type for sets of unique items, the set . Then we can import Set and declare tags as a set of str : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = set () @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results With this, even if you receive a request with duplicate data, it will be converted to a set of unique items. And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items. And it will be annotated / documented accordingly too. Nested Models \u00b6 Each attribute of a Pydantic model has a type. But that type can itself be another Pydantic model. So, you can declare deeply nested JSON object s with specific attribute names, types and validations. All that, arbitrarily nested. Define a submodel \u00b6 For example, we can define an Image model: from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results Use the submodel as a type \u00b6 And then we can use it as the type of an attribute: from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This would mean that FastAPI would expect a body similar to: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 , \"tags\" : [ \"rock\" , \"metal\" , \"bar\" ], \"image\" : { \"url\" : \"http://example.com/baz.jpg\" , \"name\" : \"The Foo live\" } } Again, doing just that declaration, with FastAPI you get: Editor support (completion, etc), even for nested models Data conversion Data validation Automatic documentation Special types and validation \u00b6 Apart from normal singular types like str , int , float , etc. You can use more complex singular types that inherit from str . To see all the options you have, checkout the docs for Pydantic's exotic types . You will see some examples in the next chapter. For example, as in the Image model we have a url field, we can declare it to be instead of a str , a Pydantic's HttpUrl : from typing import Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such. Attributes with lists of submodels \u00b6 You can also use Pydantic models as subtypes of list , set , etc: from typing import List , Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] images : List [ Image ] = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This will expect (convert, validate, document, etc) a JSON body like: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 , \"tags\" : [ \"rock\" , \"metal\" , \"bar\" ], \"images\" : [ { \"url\" : \"http://example.com/baz.jpg\" , \"name\" : \"The Foo live\" }, { \"url\" : \"http://example.com/dave.jpg\" , \"name\" : \"The Baz\" } ] } Info Notice how the images key now has a list of image objects. Deeply nested models \u00b6 You can define arbitrarily deeply nested models: from typing import List , Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] images : List [ Image ] = None class Offer ( BaseModel ): name : str description : str = None price : float items : List [ Item ] @app . post ( \"/offers/\" ) async def create_offer ( * , offer : Offer ): return offer Info Notice how Offer as a list of Item s, which in turn have an optional list of Image s Bodies of pure lists \u00b6 If the top level value of the JSON body you expect is a JSON array (a Python list ), you can declare the type in the parameter of the function, the same as in Pydantic models: images : List [ Image ] as in: from typing import List from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str @app . post ( \"/images/multiple/\" ) async def create_multiple_images ( * , images : List [ Image ]): return images Editor support everywhere \u00b6 And you get editor support everywhere. Even for items inside of lists: You couldn't get this kind of editor support if you where working directly with dict instead of Pydantic models. But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too. Bodies of arbitrary dict s \u00b6 You can also declare a body as a dict with keys of some type and values of other type. Without having to know beforehand what are the valid field/attribute names (as would be the case with Pydantic models). This would be useful if you want to receive keys that you don't already know. Other useful case is when you want to have keys of other type, e.g. int . That's what we are going to see here. In this case, you would accept any dict as long as it has int keys with float values: from typing import Dict from fastapi import FastAPI app = FastAPI () @app . post ( \"/index-weights/\" ) async def create_index_weights ( weights : Dict [ int , float ]): return weights Tip Have in mind that JSON only supports str as keys. But Pydantic has automatic data conversion. This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them. And the dict you receive as weights will actually have int keys and float values. Recap \u00b6 With FastAPI you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant. But with all the benefits: Editor support (completion everywhere!) Data conversion (a.k.a. parsing / serialization) Data validation Schema documentation Automatic docs","title":"Body - Nested Models"},{"location":"tutorial/body-nested-models/#list-fields","text":"You can define an attribute to be a subtype. For example, a Python list : from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : list = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This will make tags be a list of items. Although it doesn't declare the type of each of the items.","title":"List fields"},{"location":"tutorial/body-nested-models/#list-fields-with-subtype","text":"But Python has a specific way to declare lists with subtypes:","title":"List fields with subtype"},{"location":"tutorial/body-nested-models/#import-typings-list","text":"First, import List from standard Python's typing module: from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : List [ str ] = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results","title":"Import typing's List"},{"location":"tutorial/body-nested-models/#declare-a-list-with-a-subtype","text":"To declare types that have subtypes, like list , dict , tuple : Import them from the typing module Pass the subtype(s) as \"type arguments\" using square brackets: [ and ] from typing import List my_list : List [ str ] That's all standard Python syntax for type declarations. Use that same standard syntax for model attributes with subtypes. So, in our example, we can make tags be specifically a \"list of strings\": from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : List [ str ] = [] @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results","title":"Declare a List with a subtype"},{"location":"tutorial/body-nested-models/#set-types","text":"But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings. And Python has a special data type for sets of unique items, the set . Then we can import Set and declare tags as a set of str : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = set () @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results With this, even if you receive a request with duplicate data, it will be converted to a set of unique items. And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items. And it will be annotated / documented accordingly too.","title":"Set types"},{"location":"tutorial/body-nested-models/#nested-models","text":"Each attribute of a Pydantic model has a type. But that type can itself be another Pydantic model. So, you can declare deeply nested JSON object s with specific attribute names, types and validations. All that, arbitrarily nested.","title":"Nested Models"},{"location":"tutorial/body-nested-models/#define-a-submodel","text":"For example, we can define an Image model: from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results","title":"Define a submodel"},{"location":"tutorial/body-nested-models/#use-the-submodel-as-a-type","text":"And then we can use it as the type of an attribute: from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This would mean that FastAPI would expect a body similar to: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 , \"tags\" : [ \"rock\" , \"metal\" , \"bar\" ], \"image\" : { \"url\" : \"http://example.com/baz.jpg\" , \"name\" : \"The Foo live\" } } Again, doing just that declaration, with FastAPI you get: Editor support (completion, etc), even for nested models Data conversion Data validation Automatic documentation","title":"Use the submodel as a type"},{"location":"tutorial/body-nested-models/#special-types-and-validation","text":"Apart from normal singular types like str , int , float , etc. You can use more complex singular types that inherit from str . To see all the options you have, checkout the docs for Pydantic's exotic types . You will see some examples in the next chapter. For example, as in the Image model we have a url field, we can declare it to be instead of a str , a Pydantic's HttpUrl : from typing import Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] image : Image = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.","title":"Special types and validation"},{"location":"tutorial/body-nested-models/#attributes-with-lists-of-submodels","text":"You can also use Pydantic models as subtypes of list , set , etc: from typing import List , Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] images : List [ Image ] = None @app . put ( \"/items/ {item_id} \" ) async def update_item ( * , item_id : int , item : Item ): results = { \"item_id\" : item_id , \"item\" : item } return results This will expect (convert, validate, document, etc) a JSON body like: { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 , \"tags\" : [ \"rock\" , \"metal\" , \"bar\" ], \"images\" : [ { \"url\" : \"http://example.com/baz.jpg\" , \"name\" : \"The Foo live\" }, { \"url\" : \"http://example.com/dave.jpg\" , \"name\" : \"The Baz\" } ] } Info Notice how the images key now has a list of image objects.","title":"Attributes with lists of submodels"},{"location":"tutorial/body-nested-models/#deeply-nested-models","text":"You can define arbitrarily deeply nested models: from typing import List , Set from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] images : List [ Image ] = None class Offer ( BaseModel ): name : str description : str = None price : float items : List [ Item ] @app . post ( \"/offers/\" ) async def create_offer ( * , offer : Offer ): return offer Info Notice how Offer as a list of Item s, which in turn have an optional list of Image s","title":"Deeply nested models"},{"location":"tutorial/body-nested-models/#bodies-of-pure-lists","text":"If the top level value of the JSON body you expect is a JSON array (a Python list ), you can declare the type in the parameter of the function, the same as in Pydantic models: images : List [ Image ] as in: from typing import List from fastapi import FastAPI from pydantic import BaseModel , HttpUrl app = FastAPI () class Image ( BaseModel ): url : HttpUrl name : str @app . post ( \"/images/multiple/\" ) async def create_multiple_images ( * , images : List [ Image ]): return images","title":"Bodies of pure lists"},{"location":"tutorial/body-nested-models/#editor-support-everywhere","text":"And you get editor support everywhere. Even for items inside of lists: You couldn't get this kind of editor support if you where working directly with dict instead of Pydantic models. But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.","title":"Editor support everywhere"},{"location":"tutorial/body-nested-models/#bodies-of-arbitrary-dicts","text":"You can also declare a body as a dict with keys of some type and values of other type. Without having to know beforehand what are the valid field/attribute names (as would be the case with Pydantic models). This would be useful if you want to receive keys that you don't already know. Other useful case is when you want to have keys of other type, e.g. int . That's what we are going to see here. In this case, you would accept any dict as long as it has int keys with float values: from typing import Dict from fastapi import FastAPI app = FastAPI () @app . post ( \"/index-weights/\" ) async def create_index_weights ( weights : Dict [ int , float ]): return weights Tip Have in mind that JSON only supports str as keys. But Pydantic has automatic data conversion. This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them. And the dict you receive as weights will actually have int keys and float values.","title":"Bodies of arbitrary dicts"},{"location":"tutorial/body-nested-models/#recap","text":"With FastAPI you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant. But with all the benefits: Editor support (completion everywhere!) Data conversion (a.k.a. parsing / serialization) Data validation Schema documentation Automatic docs","title":"Recap"},{"location":"tutorial/body-updates/","text":"Update replacing with PUT \u00b6 To update an item you can use the HTTP PUT operation. You can use the jsonable_encoder to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting datetime to str . from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . put ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): update_item_encoded = jsonable_encoder ( item ) items [ item_id ] = update_item_encoded return update_item_encoded PUT is used to receive data that should replace the existing data. Warning about replacing \u00b6 That means that if you want to update the item bar using PUT with a body containing: { \"name\" : \"Barz\" , \"price\" : 3 , \"description\" : None , } because it doesn't include the already stored attribute \"tax\": 20.2 , the input model would take the default value of \"tax\": 10.5 . And the data would be saved with that \"new\" tax of 10.5 . Partial updates with PATCH \u00b6 You can also use the HTTP PATCH operation to partially update data. This means that you can send only the data that you want to update, leaving the rest intact. Note PATCH is less commonly used and known than PUT . And many teams use only PUT , even for partial updates. You are free to use them however you want, FastAPI doesn't impose any restrictions. But this guide shows you, more or less, how they are intended to be used. Using Pydantic's exclude_unset parameter \u00b6 If you want to receive partial updates, it's very useful to use the parameter exclude_unset in Pydantic's model's .dict() . Like item.dict(exclude_unset=True) . That would generate a dict with only the data that was set when creating the item model, excluding default values. Then you can use this to generate a dict with only the data that was set (sent in the request), omitting default values: from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item Using Pydantic's update parameter \u00b6 Now, you can create a copy of the existing model using .copy() , and pass the update parameter with a dict containing the data to update. Like stored_item_model.copy(update=update_data) : from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item Partial updates recap \u00b6 In summary, to apply partial updates you would: (Optionally) use PATCH instead of PUT . Retrieve the stored data. Put that data in a Pydantic model. Generate a dict without default values from the input model (using exclude_unset ). This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model. Create a copy of the stored model, updating it's attributes with the received partial updates (using the update parameter). Convert the copied model to something that can be stored in your DB (for example, using the jsonable_encoder ). This is comparable to using the model's .dict() method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, datetime to str . Save the data to your DB. Return the updated model. from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item Tip You can actually use this same technique with an HTTP PUT operation. But the example here uses PATCH because it was created for these use cases. Note Notice that the input model is still validated. So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or None ). To distinguish from the models with all optional values for updates and models with required values for creation , you can use the ideas described in Extra Models .","title":"Body - updates"},{"location":"tutorial/body-updates/#update-replacing-with-put","text":"To update an item you can use the HTTP PUT operation. You can use the jsonable_encoder to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting datetime to str . from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . put ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): update_item_encoded = jsonable_encoder ( item ) items [ item_id ] = update_item_encoded return update_item_encoded PUT is used to receive data that should replace the existing data.","title":"Update replacing with PUT"},{"location":"tutorial/body-updates/#warning-about-replacing","text":"That means that if you want to update the item bar using PUT with a body containing: { \"name\" : \"Barz\" , \"price\" : 3 , \"description\" : None , } because it doesn't include the already stored attribute \"tax\": 20.2 , the input model would take the default value of \"tax\": 10.5 . And the data would be saved with that \"new\" tax of 10.5 .","title":"Warning about replacing"},{"location":"tutorial/body-updates/#partial-updates-with-patch","text":"You can also use the HTTP PATCH operation to partially update data. This means that you can send only the data that you want to update, leaving the rest intact. Note PATCH is less commonly used and known than PUT . And many teams use only PUT , even for partial updates. You are free to use them however you want, FastAPI doesn't impose any restrictions. But this guide shows you, more or less, how they are intended to be used.","title":"Partial updates with PATCH"},{"location":"tutorial/body-updates/#using-pydantics-exclude_unset-parameter","text":"If you want to receive partial updates, it's very useful to use the parameter exclude_unset in Pydantic's model's .dict() . Like item.dict(exclude_unset=True) . That would generate a dict with only the data that was set when creating the item model, excluding default values. Then you can use this to generate a dict with only the data that was set (sent in the request), omitting default values: from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item","title":"Using Pydantic's exclude_unset parameter"},{"location":"tutorial/body-updates/#using-pydantics-update-parameter","text":"Now, you can create a copy of the existing model using .copy() , and pass the update parameter with a dict containing the data to update. Like stored_item_model.copy(update=update_data) : from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item","title":"Using Pydantic's update parameter"},{"location":"tutorial/body-updates/#partial-updates-recap","text":"In summary, to apply partial updates you would: (Optionally) use PATCH instead of PUT . Retrieve the stored data. Put that data in a Pydantic model. Generate a dict without default values from the input model (using exclude_unset ). This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model. Create a copy of the stored model, updating it's attributes with the received partial updates (using the update parameter). Convert the copied model to something that can be stored in your DB (for example, using the jsonable_encoder ). This is comparable to using the model's .dict() method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, datetime to str . Save the data to your DB. Return the updated model. from typing import List from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str = None description : str = None price : float = None tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_item ( item_id : str ): return items [ item_id ] @app . patch ( \"/items/ {item_id} \" , response_model = Item ) async def update_item ( item_id : str , item : Item ): stored_item_data = items [ item_id ] stored_item_model = Item ( ** stored_item_data ) update_data = item . dict ( exclude_unset = True ) updated_item = stored_item_model . copy ( update = update_data ) items [ item_id ] = jsonable_encoder ( updated_item ) return updated_item Tip You can actually use this same technique with an HTTP PUT operation. But the example here uses PATCH because it was created for these use cases. Note Notice that the input model is still validated. So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or None ). To distinguish from the models with all optional values for updates and models with required values for creation , you can use the ideas described in Extra Models .","title":"Partial updates recap"},{"location":"tutorial/body/","text":"When you need to send data from a client (let's say, a browser) to your API, you send it as a request body . A request body is data sent by the client to your API. A response body is the data your API sends to the client. Your API almost always has to send a response body. But clients don't necessarily need to send request bodies all the time. To declare a request body, you use Pydantic models with all their power and benefits. Info You cannot send a request body using a GET operation (HTTP method). To send data, you have to use one of: POST (the more common), PUT , DELETE or PATCH . Import Pydantic's BaseModel \u00b6 First, you need to import BaseModel from pydantic : from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item Create your data model \u00b6 Then you declare your data model as a class that inherits from BaseModel . Use standard Python types for all the attributes: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use None to make it just optional. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Foo\" , \"description\" : \"An optional description\" , \"price\" : 45.2 , \"tax\" : 3.5 } ...as description and tax are optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Foo\" , \"price\" : 45.2 } Declare it as a parameter \u00b6 To add it to your path operation , declare it the same way you declared path and query parameters: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item ...and declare its type as the model you created, Item . Results \u00b6 With just that Python type declaration, FastAPI will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter item . As you declared it in the function to be of type Item , you will also have all the editor support (completion, etc) for all of the attributes and their types. Generate JSON Schema definitions for your model, you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs . Automatic docs \u00b6 The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: And will be also used in the API docs inside each path operation that needs them: Editor support \u00b6 In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Pydantic model): You also get error checks for incorrect type operations: This is not by chance, the whole framework was built around that design. And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors. There were even some changes to Pydantic itself to support this. The previous screenshots were taken with Visual Studio Code . But you would get the same editor support with PyCharm and most of the other Python editors: Use the model \u00b6 Inside of the function, you can access all the attributes of the model object directly: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): item_dict = item . dict () if item . tax : price_with_tax = item . price + item . tax item_dict . update ({ \"price_with_tax\" : price_with_tax }) return item_dict Request body + path parameters \u00b6 You can declare path parameters and body requests at the same time. FastAPI will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared to be Pydantic models should be taken from the request body . from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def create_item ( item_id : int , item : Item ): return { \"item_id\" : item_id , ** item . dict ()} Request body + path + query parameters \u00b6 You can also declare body , path and query parameters, all at the same time. FastAPI will recognize each of them and take the data from the correct place. from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def create_item ( item_id : int , item : Item , q : str = None ): result = { \"item_id\" : item_id , ** item . dict ()} if q : result . update ({ \"q\" : q }) return result The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc) it will be interpreted as a query parameter. If the parameter is declared to be of the type of a Pydantic model , it will be interpreted as a request body . Without Pydantic \u00b6 If you don't want to use Pydantic models, you can also use Body parameters. See the docs for Body - Multiple Parameters: Singular values in body .","title":"Request Body"},{"location":"tutorial/body/#import-pydantics-basemodel","text":"First, you need to import BaseModel from pydantic : from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item","title":"Import Pydantic's BaseModel"},{"location":"tutorial/body/#create-your-data-model","text":"Then you declare your data model as a class that inherits from BaseModel . Use standard Python types for all the attributes: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use None to make it just optional. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Foo\" , \"description\" : \"An optional description\" , \"price\" : 45.2 , \"tax\" : 3.5 } ...as description and tax are optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Foo\" , \"price\" : 45.2 }","title":"Create your data model"},{"location":"tutorial/body/#declare-it-as-a-parameter","text":"To add it to your path operation , declare it the same way you declared path and query parameters: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item ...and declare its type as the model you created, Item .","title":"Declare it as a parameter"},{"location":"tutorial/body/#results","text":"With just that Python type declaration, FastAPI will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter item . As you declared it in the function to be of type Item , you will also have all the editor support (completion, etc) for all of the attributes and their types. Generate JSON Schema definitions for your model, you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs .","title":"Results"},{"location":"tutorial/body/#automatic-docs","text":"The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: And will be also used in the API docs inside each path operation that needs them:","title":"Automatic docs"},{"location":"tutorial/body/#editor-support","text":"In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Pydantic model): You also get error checks for incorrect type operations: This is not by chance, the whole framework was built around that design. And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors. There were even some changes to Pydantic itself to support this. The previous screenshots were taken with Visual Studio Code . But you would get the same editor support with PyCharm and most of the other Python editors:","title":"Editor support"},{"location":"tutorial/body/#use-the-model","text":"Inside of the function, you can access all the attributes of the model object directly: from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . post ( \"/items/\" ) async def create_item ( item : Item ): item_dict = item . dict () if item . tax : price_with_tax = item . price + item . tax item_dict . update ({ \"price_with_tax\" : price_with_tax }) return item_dict","title":"Use the model"},{"location":"tutorial/body/#request-body-path-parameters","text":"You can declare path parameters and body requests at the same time. FastAPI will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared to be Pydantic models should be taken from the request body . from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def create_item ( item_id : int , item : Item ): return { \"item_id\" : item_id , ** item . dict ()}","title":"Request body + path parameters"},{"location":"tutorial/body/#request-body-path-query-parameters","text":"You can also declare body , path and query parameters, all at the same time. FastAPI will recognize each of them and take the data from the correct place. from fastapi import FastAPI from pydantic import BaseModel class Item ( BaseModel ): name : str description : str = None price : float tax : float = None app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def create_item ( item_id : int , item : Item , q : str = None ): result = { \"item_id\" : item_id , ** item . dict ()} if q : result . update ({ \"q\" : q }) return result The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc) it will be interpreted as a query parameter. If the parameter is declared to be of the type of a Pydantic model , it will be interpreted as a request body .","title":"Request body + path + query parameters"},{"location":"tutorial/body/#without-pydantic","text":"If you don't want to use Pydantic models, you can also use Body parameters. See the docs for Body - Multiple Parameters: Singular values in body .","title":"Without Pydantic"},{"location":"tutorial/cookie-params/","text":"You can define Cookie parameters the same way you define Query and Path parameters. Import Cookie \u00b6 First import Cookie : from fastapi import Cookie , FastAPI app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , ads_id : str = Cookie ( None )): return { \"ads_id\" : ads_id } Declare Cookie parameters \u00b6 Then declare the cookie parameters using the same structure as with Path and Query . The first value is the default value, you can pass all the extra validation or annotation parameters: from fastapi import Cookie , FastAPI app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , ads_id : str = Cookie ( None )): return { \"ads_id\" : ads_id } Technical Details Cookie is a \"sister\" class of Path and Query . It also inherits from the same common Param class. But remember that when you import Query , Path , Cookie and others from fastapi , those are actually functions that return special classes. Info To declare cookies, you need to use Cookie , because otherwise the parameters would be interpreted as query parameters. Recap \u00b6 Declare cookies with Cookie , using the same common pattern as Query and Path .","title":"Cookie Parameters"},{"location":"tutorial/cookie-params/#import-cookie","text":"First import Cookie : from fastapi import Cookie , FastAPI app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , ads_id : str = Cookie ( None )): return { \"ads_id\" : ads_id }","title":"Import Cookie"},{"location":"tutorial/cookie-params/#declare-cookie-parameters","text":"Then declare the cookie parameters using the same structure as with Path and Query . The first value is the default value, you can pass all the extra validation or annotation parameters: from fastapi import Cookie , FastAPI app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , ads_id : str = Cookie ( None )): return { \"ads_id\" : ads_id } Technical Details Cookie is a \"sister\" class of Path and Query . It also inherits from the same common Param class. But remember that when you import Query , Path , Cookie and others from fastapi , those are actually functions that return special classes. Info To declare cookies, you need to use Cookie , because otherwise the parameters would be interpreted as query parameters.","title":"Declare Cookie parameters"},{"location":"tutorial/cookie-params/#recap","text":"Declare cookies with Cookie , using the same common pattern as Query and Path .","title":"Recap"},{"location":"tutorial/cors/","text":"CORS or \"Cross-Origin Resource Sharing\" refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different \"origin\" than the frontend. Origin \u00b6 An origin is the combination of protocol ( http , https ), domain ( myapp.com , localhost , localhost.tiangolo.com ), and port ( 80 , 443 , 8080 ). So, all these are different origins: http://localhost https://localhost http://localhost:8080 Even if they are all in localhost , they use different protocols or ports, so, they are different \"origins\". Steps \u00b6 So, let's say you have a frontend running in your browser at http://localhost:8080 , and its JavaScript is trying to communicate with a backend running at http://localhost (because we don't specify a port, the browser will assume the default port 80 ). Then, the browser will send an HTTP OPTIONS request to the backend, and if the backend sends the appropriate headers authorizing the communication from this different origin ( http://localhost:8080 ) then the browser will let the JavaScript in the frontend send its request to the backend. To achieve this, the backend must have a list of \"allowed origins\". In this case, it would have to include http://localhost:8080 for the frontend to work correctly. Wildcards \u00b6 It's also possible to declare the list as \"*\" (a \"wildcard\") to say that all are allowed. But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc. So, for everything to work correctly, it's better to specify explicitly the allowed origins. Use CORSMiddleware \u00b6 You can configure it in your FastAPI application using Starlette's CORSMiddleware . Import it from Starlette. Create a list of allowed origins (as strings). Add it as a \"middleware\" to your FastAPI application. You can also specify if your backend allows: Credentials (Authorization headers, Cookies, etc). Specific HTTP methods ( POST , PUT ) or all of them with the wildcard \"*\" . Specific HTTP headers or all of them with the wildcard \"*\" . from fastapi import FastAPI from starlette.middleware.cors import CORSMiddleware app = FastAPI () origins = [ \"http://localhost.tiangolo.com\" , \"https://localhost.tiangolo.com\" , \"http://localhost\" , \"http://localhost:8080\" , ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) More info \u00b6 For more details of what you can specify in CORSMiddleware , check Starlette's CORSMiddleware docs . For more info about CORS , check the Mozilla CORS documentation .","title":"CORS (Cross-Origin Resource Sharing)"},{"location":"tutorial/cors/#origin","text":"An origin is the combination of protocol ( http , https ), domain ( myapp.com , localhost , localhost.tiangolo.com ), and port ( 80 , 443 , 8080 ). So, all these are different origins: http://localhost https://localhost http://localhost:8080 Even if they are all in localhost , they use different protocols or ports, so, they are different \"origins\".","title":"Origin"},{"location":"tutorial/cors/#steps","text":"So, let's say you have a frontend running in your browser at http://localhost:8080 , and its JavaScript is trying to communicate with a backend running at http://localhost (because we don't specify a port, the browser will assume the default port 80 ). Then, the browser will send an HTTP OPTIONS request to the backend, and if the backend sends the appropriate headers authorizing the communication from this different origin ( http://localhost:8080 ) then the browser will let the JavaScript in the frontend send its request to the backend. To achieve this, the backend must have a list of \"allowed origins\". In this case, it would have to include http://localhost:8080 for the frontend to work correctly.","title":"Steps"},{"location":"tutorial/cors/#wildcards","text":"It's also possible to declare the list as \"*\" (a \"wildcard\") to say that all are allowed. But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc. So, for everything to work correctly, it's better to specify explicitly the allowed origins.","title":"Wildcards"},{"location":"tutorial/cors/#use-corsmiddleware","text":"You can configure it in your FastAPI application using Starlette's CORSMiddleware . Import it from Starlette. Create a list of allowed origins (as strings). Add it as a \"middleware\" to your FastAPI application. You can also specify if your backend allows: Credentials (Authorization headers, Cookies, etc). Specific HTTP methods ( POST , PUT ) or all of them with the wildcard \"*\" . Specific HTTP headers or all of them with the wildcard \"*\" . from fastapi import FastAPI from starlette.middleware.cors import CORSMiddleware app = FastAPI () origins = [ \"http://localhost.tiangolo.com\" , \"https://localhost.tiangolo.com\" , \"http://localhost\" , \"http://localhost:8080\" , ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], )","title":"Use CORSMiddleware"},{"location":"tutorial/cors/#more-info","text":"For more details of what you can specify in CORSMiddleware , check Starlette's CORSMiddleware docs . For more info about CORS , check the Mozilla CORS documentation .","title":"More info"},{"location":"tutorial/debugging/","text":"You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm. Call uvicorn \u00b6 In your FastAPI application, import and run uvicorn directly: import uvicorn from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def root (): a = \"a\" b = \"b\" + a return { \"hello world\" : b } if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) About __name__ == \"__main__\" \u00b6 The main purpose of the __name__ == \"__main__\" is to have some code that is executed when your file is called with: python myapp.py but is not called when another file imports it, like in: from myapp import app More details \u00b6 Let's say your file is named myapp.py . If you run it with: python myapp.py then the internal variable __name__ in your file, created automatically by Python, will have as value the string \"__main__\" . So, the section: uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) will run. This won't happen if you import that module (file). So, if you have another file importer.py with: from myapp import app # Some more code in that case, the automatic variable inside of myapp.py will not have the variable __name__ with a value of \"__main__\" . So, the line: uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) will not be executed. Info For more information, check the official Python docs . Run your code with your debugger \u00b6 Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger. For example, in Visual Studio Code, you can: Go to the \"Debug\" panel. \"Add configuration...\". Select \"Python\" Run the debugger with the option \" Python: Current File (Integrated Terminal) \". It will then start the server with your FastAPI code, stop at your breakpoints, etc. Here's how it might look:","title":"Debugging"},{"location":"tutorial/debugging/#call-uvicorn","text":"In your FastAPI application, import and run uvicorn directly: import uvicorn from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def root (): a = \"a\" b = \"b\" + a return { \"hello world\" : b } if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 )","title":"Call uvicorn"},{"location":"tutorial/debugging/#about-__name__-__main__","text":"The main purpose of the __name__ == \"__main__\" is to have some code that is executed when your file is called with: python myapp.py but is not called when another file imports it, like in: from myapp import app","title":"About __name__ == \"__main__\""},{"location":"tutorial/debugging/#more-details","text":"Let's say your file is named myapp.py . If you run it with: python myapp.py then the internal variable __name__ in your file, created automatically by Python, will have as value the string \"__main__\" . So, the section: uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) will run. This won't happen if you import that module (file). So, if you have another file importer.py with: from myapp import app # Some more code in that case, the automatic variable inside of myapp.py will not have the variable __name__ with a value of \"__main__\" . So, the line: uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) will not be executed. Info For more information, check the official Python docs .","title":"More details"},{"location":"tutorial/debugging/#run-your-code-with-your-debugger","text":"Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger. For example, in Visual Studio Code, you can: Go to the \"Debug\" panel. \"Add configuration...\". Select \"Python\" Run the debugger with the option \" Python: Current File (Integrated Terminal) \". It will then start the server with your FastAPI code, stop at your breakpoints, etc. Here's how it might look:","title":"Run your code with your debugger"},{"location":"tutorial/encoder/","text":"There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a dict , list , etc). For example, if you need to store it in a database. For that, FastAPI provides a jsonable_encoder() function. Using the jsonable_encoder \u00b6 Let's imagine that you have a database fake_db that only receives JSON compatible data. For example, it doesn't receive datetime objects, as those are not compatible with JSON. So, a datetime object would have to be converted to a str containing the data in ISO format . The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a dict . You can use jsonable_encoder for that. It receives an object, like a Pydantic model, and returns a JSON compatible version: from datetime import datetime from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel fake_db = {} class Item ( BaseModel ): title : str timestamp : datetime description : str = None app = FastAPI () @app . put ( \"/items/ {id} \" ) def update_item ( id : str , item : Item ): json_compatible_item_data = jsonable_encoder ( item ) fake_db [ id ] = json_compatible_item_data In this example, it would convert the Pydantic model to a dict , and the datetime to a str . The result of calling it is something that can be encoded with the Python standard json.dumps() . It doesn't return a large str containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a dict ) with values and sub-values that are all compatible with JSON. Note jsonable_encoder is actually used by FastAPI internally to convert data. But it is useful in many other scenarios.","title":"JSON Compatible Encoder"},{"location":"tutorial/encoder/#using-the-jsonable_encoder","text":"Let's imagine that you have a database fake_db that only receives JSON compatible data. For example, it doesn't receive datetime objects, as those are not compatible with JSON. So, a datetime object would have to be converted to a str containing the data in ISO format . The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a dict . You can use jsonable_encoder for that. It receives an object, like a Pydantic model, and returns a JSON compatible version: from datetime import datetime from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel fake_db = {} class Item ( BaseModel ): title : str timestamp : datetime description : str = None app = FastAPI () @app . put ( \"/items/ {id} \" ) def update_item ( id : str , item : Item ): json_compatible_item_data = jsonable_encoder ( item ) fake_db [ id ] = json_compatible_item_data In this example, it would convert the Pydantic model to a dict , and the datetime to a str . The result of calling it is something that can be encoded with the Python standard json.dumps() . It doesn't return a large str containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a dict ) with values and sub-values that are all compatible with JSON. Note jsonable_encoder is actually used by FastAPI internally to convert data. But it is useful in many other scenarios.","title":"Using the jsonable_encoder"},{"location":"tutorial/extra-data-types/","text":"Up to now, you have been using common data types, like: int float str bool But you can also use more complex data types. And you will still have the same features as seen up to now: Great editor support. Data conversion from incoming requests. Data conversion for response data. Data validation. Automatic annotation and documentation. Other data types \u00b6 Here are some of the additional data types you can use: UUID : A standard \"Universally Unique Identifier\", common as an ID in many databases and systems. In requests and responses will be represented as a str . datetime.datetime : A Python datetime.datetime . In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00 . datetime.date : Python datetime.date . In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15 . datetime.time : A Python datetime.time . In requests and responses will be represented as a str in ISO 8601 format, like: 14:23:55.003 . datetime.timedelta : A Python datetime.timedelta . In requests and responses will be represented as a float of total seconds. Pydantic also allows representing it as a \"ISO 8601 time diff encoding\", see the docs for more info . frozenset : In requests and responses, treated the same as a set : In requests, a list will be read, eliminating duplicates and converting it to a set . In responses, the set will be converted to a list . The generated schema will specify that the set values are unique (using JSON Schema's uniqueItems ). bytes : Standard Python bytes . In requests and responses will be treated as str . The generated schema will specify that it's a str with binary \"format\". Decimal : Standard Python Decimal . In requests and responses, handled the same as a float . Example \u00b6 Here's an example path operation with parameters using some of the above types. from datetime import datetime , time , timedelta from uuid import UUID from fastapi import Body , FastAPI app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def read_items ( item_id : UUID , start_datetime : datetime = Body ( None ), end_datetime : datetime = Body ( None ), repeat_at : time = Body ( None ), process_after : timedelta = Body ( None ), ): start_process = start_datetime + process_after duration = end_datetime - start_process return { \"item_id\" : item_id , \"start_datetime\" : start_datetime , \"end_datetime\" : end_datetime , \"repeat_at\" : repeat_at , \"process_after\" : process_after , \"start_process\" : start_process , \"duration\" : duration , } Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like: from datetime import datetime , time , timedelta from uuid import UUID from fastapi import Body , FastAPI app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def read_items ( item_id : UUID , start_datetime : datetime = Body ( None ), end_datetime : datetime = Body ( None ), repeat_at : time = Body ( None ), process_after : timedelta = Body ( None ), ): start_process = start_datetime + process_after duration = end_datetime - start_process return { \"item_id\" : item_id , \"start_datetime\" : start_datetime , \"end_datetime\" : end_datetime , \"repeat_at\" : repeat_at , \"process_after\" : process_after , \"start_process\" : start_process , \"duration\" : duration , }","title":"Extra data types"},{"location":"tutorial/extra-data-types/#other-data-types","text":"Here are some of the additional data types you can use: UUID : A standard \"Universally Unique Identifier\", common as an ID in many databases and systems. In requests and responses will be represented as a str . datetime.datetime : A Python datetime.datetime . In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00 . datetime.date : Python datetime.date . In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15 . datetime.time : A Python datetime.time . In requests and responses will be represented as a str in ISO 8601 format, like: 14:23:55.003 . datetime.timedelta : A Python datetime.timedelta . In requests and responses will be represented as a float of total seconds. Pydantic also allows representing it as a \"ISO 8601 time diff encoding\", see the docs for more info . frozenset : In requests and responses, treated the same as a set : In requests, a list will be read, eliminating duplicates and converting it to a set . In responses, the set will be converted to a list . The generated schema will specify that the set values are unique (using JSON Schema's uniqueItems ). bytes : Standard Python bytes . In requests and responses will be treated as str . The generated schema will specify that it's a str with binary \"format\". Decimal : Standard Python Decimal . In requests and responses, handled the same as a float .","title":"Other data types"},{"location":"tutorial/extra-data-types/#example","text":"Here's an example path operation with parameters using some of the above types. from datetime import datetime , time , timedelta from uuid import UUID from fastapi import Body , FastAPI app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def read_items ( item_id : UUID , start_datetime : datetime = Body ( None ), end_datetime : datetime = Body ( None ), repeat_at : time = Body ( None ), process_after : timedelta = Body ( None ), ): start_process = start_datetime + process_after duration = end_datetime - start_process return { \"item_id\" : item_id , \"start_datetime\" : start_datetime , \"end_datetime\" : end_datetime , \"repeat_at\" : repeat_at , \"process_after\" : process_after , \"start_process\" : start_process , \"duration\" : duration , } Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like: from datetime import datetime , time , timedelta from uuid import UUID from fastapi import Body , FastAPI app = FastAPI () @app . put ( \"/items/ {item_id} \" ) async def read_items ( item_id : UUID , start_datetime : datetime = Body ( None ), end_datetime : datetime = Body ( None ), repeat_at : time = Body ( None ), process_after : timedelta = Body ( None ), ): start_process = start_datetime + process_after duration = end_datetime - start_process return { \"item_id\" : item_id , \"start_datetime\" : start_datetime , \"end_datetime\" : end_datetime , \"repeat_at\" : repeat_at , \"process_after\" : process_after , \"start_process\" : start_process , \"duration\" : duration , }","title":"Example"},{"location":"tutorial/extra-models/","text":"Continuing with the previous example, it will be common to have more than one related model. This is especially the case for user models, because: The input model needs to be able to have a password. The output model should not have a password. The database model would probably need to have a hashed password. Danger Never store user's plaintext passwords. Always store a \"secure hash\" that you can then verify. If you don't know, you will learn what a \"password hash\" is in the security chapters . Multiple models \u00b6 Here's a general idea of how the models could look like with their password fields and the places where they are used: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None class UserInDB ( BaseModel ): username : str hashed_password : str email : EmailStr full_name : str = None def fake_password_hasher ( raw_password : str ): return \"supersecret\" + raw_password def fake_save_user ( user_in : UserIn ): hashed_password = fake_password_hasher ( user_in . password ) user_in_db = UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) print ( \"User saved! ..not really\" ) return user_in_db @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user_in : UserIn ): user_saved = fake_save_user ( user_in ) return user_saved About **user_in.dict() \u00b6 Pydantic's .dict() \u00b6 user_in is a Pydantic model of class UserIn . Pydantic models have a .dict() method that returns a dict with the model's data. So, if we create a Pydantic object user_in like: user_in = UserIn ( username = \"john\" , password = \"secret\" , email = \"john.doe@example.com\" ) and then we call: user_dict = user_in . dict () we now have a dict with the data in the variable user_dict (it's a dict instead of a Pydantic model object). And if we call: print ( user_dict ) we would get a Python dict with: { 'username' : 'john' , 'password' : 'secret' , 'email' : 'john.doe@example.com' , 'full_name' : None , } Unwrapping a dict \u00b6 If we take a dict like user_dict and pass it to a function (or class) with **user_dict , Python will \"unwrap\" it. It will pass the keys and values of the user_dict directly as key-value arguments. So, continuing with the user_dict from above, writing: UserInDB ( ** user_dict ) Would result in something equivalent to: UserInDB ( username = \"john\" , password = \"secret\" , email = \"john.doe@example.com\" , full_name = None , ) Or more exactly, using user_dict directly, with whatever contents it might have in the future: UserInDB ( username = user_dict [ \"username\" ], password = user_dict [ \"password\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], ) A Pydantic model from the contents of another \u00b6 As in the example above we got user_dict from user_in.dict() , this code: user_dict = user_in . dict () UserInDB ( ** user_dict ) would be equivalent to: UserInDB ( ** user_in . dict ()) ...because user_in.dict() is a dict , and then we make Python \"unwrap\" it by passing it to UserInDB prepended with ** . So, we get a Pydantic model from the data in another Pydantic model. Unwrapping a dict and extra keywords \u00b6 And then adding the extra keyword argument hashed_password=hashed_password , like in: UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) ...ends up being like: UserInDB ( username = user_dict [ \"username\" ], password = user_dict [ \"password\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], hashed_password = hashed_password , ) Warning The supporting additional functions are just to demo a possible flow of the data, but they of course are not providing any real security. Reduce duplication \u00b6 Reducing code duplication is one of the core ideas in FastAPI . As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc. And these models are all sharing a lot of the data and duplicating attribute names and types. We could do better. We can declare a UserBase model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc). All the data conversion, validation, documentation, etc. will still work as normally. That way, we can declare just the differences between the models (with plaintext password , with hashed_password and without password): from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserBase ( BaseModel ): username : str email : EmailStr full_name : str = None class UserIn ( UserBase ): password : str class UserOut ( UserBase ): pass class UserInDB ( UserBase ): hashed_password : str def fake_password_hasher ( raw_password : str ): return \"supersecret\" + raw_password def fake_save_user ( user_in : UserIn ): hashed_password = fake_password_hasher ( user_in . password ) user_in_db = UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) print ( \"User saved! ..not really\" ) return user_in_db @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user_in : UserIn ): user_saved = fake_save_user ( user_in ) return user_saved Union or anyOf \u00b6 You can declare a response to be the Union of two types, that means, that the response would be any of the two. It will be defined in OpenAPI with anyOf . To do that, use the standard Python type hint typing.Union : from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class BaseItem ( BaseModel ): description : str type : str class CarItem ( BaseItem ): type = \"car\" class PlaneItem ( BaseItem ): type = \"plane\" size : int items = { \"item1\" : { \"description\" : \"All my friends drive a low rider\" , \"type\" : \"car\" }, \"item2\" : { \"description\" : \"Music is my aeroplane, it's my aeroplane\" , \"type\" : \"plane\" , \"size\" : 5 , }, } @app . get ( \"/items/ {item_id} \" , response_model = Union [ PlaneItem , CarItem ]) async def read_item ( item_id : str ): return items [ item_id ] List of models \u00b6 The same way, you can declare responses of lists of objects. For that, use the standard Python typing.List : from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str items = [ { \"name\" : \"Foo\" , \"description\" : \"There comes my hero\" }, { \"name\" : \"Red\" , \"description\" : \"It's my aeroplane\" }, ] @app . get ( \"/items/\" , response_model = List [ Item ]) async def read_items (): return items Response with arbitrary dict \u00b6 You can also declare a response using a plain arbitrary dict , declaring just the type of the keys and values, without using a Pydantic model. This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand. In this case, you can use typing.Dict : from typing import Dict from fastapi import FastAPI app = FastAPI () @app . get ( \"/keyword-weights/\" , response_model = Dict [ str , float ]) async def read_keyword_weights (): return { \"foo\" : 2.3 , \"bar\" : 3.4 } Recap \u00b6 Use multiple Pydantic models and inherit freely for each case. You don't need to have a single data model per entity if that entity must be able to have different \"states\". As the case with the user \"entity\" with a state including password , password_hash and no password.","title":"Extra Models"},{"location":"tutorial/extra-models/#multiple-models","text":"Here's a general idea of how the models could look like with their password fields and the places where they are used: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None class UserInDB ( BaseModel ): username : str hashed_password : str email : EmailStr full_name : str = None def fake_password_hasher ( raw_password : str ): return \"supersecret\" + raw_password def fake_save_user ( user_in : UserIn ): hashed_password = fake_password_hasher ( user_in . password ) user_in_db = UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) print ( \"User saved! ..not really\" ) return user_in_db @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user_in : UserIn ): user_saved = fake_save_user ( user_in ) return user_saved","title":"Multiple models"},{"location":"tutorial/extra-models/#about-user_indict","text":"","title":"About **user_in.dict()"},{"location":"tutorial/extra-models/#pydantics-dict","text":"user_in is a Pydantic model of class UserIn . Pydantic models have a .dict() method that returns a dict with the model's data. So, if we create a Pydantic object user_in like: user_in = UserIn ( username = \"john\" , password = \"secret\" , email = \"john.doe@example.com\" ) and then we call: user_dict = user_in . dict () we now have a dict with the data in the variable user_dict (it's a dict instead of a Pydantic model object). And if we call: print ( user_dict ) we would get a Python dict with: { 'username' : 'john' , 'password' : 'secret' , 'email' : 'john.doe@example.com' , 'full_name' : None , }","title":"Pydantic's .dict()"},{"location":"tutorial/extra-models/#unwrapping-a-dict","text":"If we take a dict like user_dict and pass it to a function (or class) with **user_dict , Python will \"unwrap\" it. It will pass the keys and values of the user_dict directly as key-value arguments. So, continuing with the user_dict from above, writing: UserInDB ( ** user_dict ) Would result in something equivalent to: UserInDB ( username = \"john\" , password = \"secret\" , email = \"john.doe@example.com\" , full_name = None , ) Or more exactly, using user_dict directly, with whatever contents it might have in the future: UserInDB ( username = user_dict [ \"username\" ], password = user_dict [ \"password\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], )","title":"Unwrapping a dict"},{"location":"tutorial/extra-models/#a-pydantic-model-from-the-contents-of-another","text":"As in the example above we got user_dict from user_in.dict() , this code: user_dict = user_in . dict () UserInDB ( ** user_dict ) would be equivalent to: UserInDB ( ** user_in . dict ()) ...because user_in.dict() is a dict , and then we make Python \"unwrap\" it by passing it to UserInDB prepended with ** . So, we get a Pydantic model from the data in another Pydantic model.","title":"A Pydantic model from the contents of another"},{"location":"tutorial/extra-models/#unwrapping-a-dict-and-extra-keywords","text":"And then adding the extra keyword argument hashed_password=hashed_password , like in: UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) ...ends up being like: UserInDB ( username = user_dict [ \"username\" ], password = user_dict [ \"password\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], hashed_password = hashed_password , ) Warning The supporting additional functions are just to demo a possible flow of the data, but they of course are not providing any real security.","title":"Unwrapping a dict and extra keywords"},{"location":"tutorial/extra-models/#reduce-duplication","text":"Reducing code duplication is one of the core ideas in FastAPI . As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc. And these models are all sharing a lot of the data and duplicating attribute names and types. We could do better. We can declare a UserBase model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc). All the data conversion, validation, documentation, etc. will still work as normally. That way, we can declare just the differences between the models (with plaintext password , with hashed_password and without password): from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserBase ( BaseModel ): username : str email : EmailStr full_name : str = None class UserIn ( UserBase ): password : str class UserOut ( UserBase ): pass class UserInDB ( UserBase ): hashed_password : str def fake_password_hasher ( raw_password : str ): return \"supersecret\" + raw_password def fake_save_user ( user_in : UserIn ): hashed_password = fake_password_hasher ( user_in . password ) user_in_db = UserInDB ( ** user_in . dict (), hashed_password = hashed_password ) print ( \"User saved! ..not really\" ) return user_in_db @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user_in : UserIn ): user_saved = fake_save_user ( user_in ) return user_saved","title":"Reduce duplication"},{"location":"tutorial/extra-models/#union-or-anyof","text":"You can declare a response to be the Union of two types, that means, that the response would be any of the two. It will be defined in OpenAPI with anyOf . To do that, use the standard Python type hint typing.Union : from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class BaseItem ( BaseModel ): description : str type : str class CarItem ( BaseItem ): type = \"car\" class PlaneItem ( BaseItem ): type = \"plane\" size : int items = { \"item1\" : { \"description\" : \"All my friends drive a low rider\" , \"type\" : \"car\" }, \"item2\" : { \"description\" : \"Music is my aeroplane, it's my aeroplane\" , \"type\" : \"plane\" , \"size\" : 5 , }, } @app . get ( \"/items/ {item_id} \" , response_model = Union [ PlaneItem , CarItem ]) async def read_item ( item_id : str ): return items [ item_id ]","title":"Union or anyOf"},{"location":"tutorial/extra-models/#list-of-models","text":"The same way, you can declare responses of lists of objects. For that, use the standard Python typing.List : from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str items = [ { \"name\" : \"Foo\" , \"description\" : \"There comes my hero\" }, { \"name\" : \"Red\" , \"description\" : \"It's my aeroplane\" }, ] @app . get ( \"/items/\" , response_model = List [ Item ]) async def read_items (): return items","title":"List of models"},{"location":"tutorial/extra-models/#response-with-arbitrary-dict","text":"You can also declare a response using a plain arbitrary dict , declaring just the type of the keys and values, without using a Pydantic model. This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand. In this case, you can use typing.Dict : from typing import Dict from fastapi import FastAPI app = FastAPI () @app . get ( \"/keyword-weights/\" , response_model = Dict [ str , float ]) async def read_keyword_weights (): return { \"foo\" : 2.3 , \"bar\" : 3.4 }","title":"Response with arbitrary dict"},{"location":"tutorial/extra-models/#recap","text":"Use multiple Pydantic models and inherit freely for each case. You don't need to have a single data model per entity if that entity must be able to have different \"states\". As the case with the user \"entity\" with a state including password , password_hash and no password.","title":"Recap"},{"location":"tutorial/first-steps/","text":"The simplest FastAPI file could look like this: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } Copy that to a file main.py . Run the live server: uvicorn main:app --reload Note The command uvicorn main:app refers to: main : the file main.py (the Python \"module\"). app : the object created inside of main.py with the line app = FastAPI() . --reload : make the server restart after code changes. Only use for development. You will see an output like: INFO: Started reloader process [17961] INFO: Started server process [17962] INFO: Waiting for application startup. INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) That last line shows the URL where your app is being served, in your local machine. Check it \u00b6 Open your browser at http://127.0.0.1:8000 . You will see the JSON response as: { \"message\" : \"Hello World\" } Interactive API docs \u00b6 Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ): Alternative API docs \u00b6 And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ): OpenAPI \u00b6 FastAPI generates a \"schema\" with all your API using the OpenAPI standard for defining APIs. \"Schema\" \u00b6 A \"schema\" is a definition or description of something. Not the code that implements it, but just the abstract description. API \"schema\" \u00b6 In this case, OpenAPI is a specification that dictates how to define a schema of your API. This OpenAPI schema would include your API paths, the possible parameters they take, etc. Data \"schema\" \u00b6 The term \"schema\" might also refer to the shape of some data, like a JSON content. In that case, it would mean the JSON attributes, and data types they have, etc. OpenAPI and JSON Schema \u00b6 OpenAPI defines an API schema for your API. And that schema includes definitions (or \"schemas\") of the data sent and received by your API using JSON Schema , the standard for JSON data schemas. Check the openapi.json \u00b6 If you are curious about how the raw OpenAPI schema looks like, it is just an automatically generated JSON with the descriptions of all your API. You can see it directly at: http://127.0.0.1:8000/openapi.json . It will show a JSON starting with something like: { \"openapi\" : \"3.0.2\" , \"info\" : { \"title\" : \"FastAPI\" , \"version\" : \"0.1.0\" }, \"paths\" : { \"/items/\" : { \"get\" : { \"responses\" : { \"200\" : { \"description\" : \"Successful Response\" , \"content\" : { \"application/json\" : { ... What is OpenAPI for \u00b6 This OpenAPI schema is what powers the 2 interactive documentation systems included. And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with FastAPI . You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications. Recap, step by step \u00b6 Step 1: import FastAPI \u00b6 from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } FastAPI is a Python class that provides all the functionality for your API. Technical Details FastAPI is a class that inherits directly from Starlette . You can use all the Starlette functionality with FastAPI too. Step 2: create a FastAPI \"instance\" \u00b6 from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } Here the app variable will be an \"instance\" of the class FastAPI . This will be the main point of interaction to create all your API. This app is the same one referred by uvicorn in the command: uvicorn main:app --reload If you create your app like: from fastapi import FastAPI my_awesome_api = FastAPI () @my_awesome_api . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } And put it in a file main.py , then you would call uvicorn like: uvicorn main:my_awesome_api --reload Step 3: create a path operation \u00b6 Path \u00b6 \"Path\" here refers to the last part of the URL starting from the first / . So, in a URL like: https://example.com/items/foo ...the path would be: /items/foo Info A \"path\" is also commonly called an \"endpoint\" or a \"route\". Building an API, the \"path\" is the main way to separate \"concerns\" and \"resources\". Operation \u00b6 \"Operation\" here refers to one of the HTTP \"methods\". One of: POST GET PUT DELETE ...and the more exotic ones: OPTIONS HEAD PATCH TRACE In the HTTP protocol, you can communicate to each path using one (or more) of these \"methods\". When building APIs, you normally use these specific HTTP methods to perform a specific action. Normally you use: POST : to create data. GET : to read data. PUT : to update data. DELETE : to delete data. So, in OpenAPI, each of the HTTP methods is called an \"operation\". We are going to call them \" operations \" too. Define a path operation function \u00b6 from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } The @app.get(\"/\") tells FastAPI that the function right below is in charge of handling requests that go to: the path / using a get operation @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells FastAPI that the function below corresponds to the path / with an operation get . It is the \" path operation decorator \". You can also use the other operations: @app.post() @app.put() @app.delete() And the more exotic ones: @app.options() @app.head() @app.patch() @app.trace() Tip You are free to use each operation (HTTP method) as you wish. FastAPI doesn't enforce any specific meaning. The information here is presented as a guideline, not a requirement. For example, when using GraphQL you normally perform all the actions using only post . Step 4: define the path operation function \u00b6 This is our \" path operation function \": path : is / . operation : is get . function : is the function below the \"decorator\" (below @app.get(\"/\") ). from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } This is a Python function. It will be called by FastAPI whenever it receives a request to the URL \" / \" using GET . In this case, it is an async function. You could also define it as a normal function instead of async def : from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def root (): return { \"message\" : \"Hello World\" } Note If you don't know the difference, check the Async: \"In a hurry?\" . Step 5: return the content \u00b6 from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } You can return a dict , list , singular values as str , int , etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported. Recap \u00b6 Import FastAPI . Create an app instance. Write a path operation decorator (like @app.get(\"/\") ). Write a path operation function (like def root(): ... above). Run the development server (like uvicorn main:app --reload ).","title":"First Steps"},{"location":"tutorial/first-steps/#check-it","text":"Open your browser at http://127.0.0.1:8000 . You will see the JSON response as: { \"message\" : \"Hello World\" }","title":"Check it"},{"location":"tutorial/first-steps/#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"tutorial/first-steps/#alternative-api-docs","text":"And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ):","title":"Alternative API docs"},{"location":"tutorial/first-steps/#openapi","text":"FastAPI generates a \"schema\" with all your API using the OpenAPI standard for defining APIs.","title":"OpenAPI"},{"location":"tutorial/first-steps/#schema","text":"A \"schema\" is a definition or description of something. Not the code that implements it, but just the abstract description.","title":"\"Schema\""},{"location":"tutorial/first-steps/#api-schema","text":"In this case, OpenAPI is a specification that dictates how to define a schema of your API. This OpenAPI schema would include your API paths, the possible parameters they take, etc.","title":"API \"schema\""},{"location":"tutorial/first-steps/#data-schema","text":"The term \"schema\" might also refer to the shape of some data, like a JSON content. In that case, it would mean the JSON attributes, and data types they have, etc.","title":"Data \"schema\""},{"location":"tutorial/first-steps/#openapi-and-json-schema","text":"OpenAPI defines an API schema for your API. And that schema includes definitions (or \"schemas\") of the data sent and received by your API using JSON Schema , the standard for JSON data schemas.","title":"OpenAPI and JSON Schema"},{"location":"tutorial/first-steps/#check-the-openapijson","text":"If you are curious about how the raw OpenAPI schema looks like, it is just an automatically generated JSON with the descriptions of all your API. You can see it directly at: http://127.0.0.1:8000/openapi.json . It will show a JSON starting with something like: { \"openapi\" : \"3.0.2\" , \"info\" : { \"title\" : \"FastAPI\" , \"version\" : \"0.1.0\" }, \"paths\" : { \"/items/\" : { \"get\" : { \"responses\" : { \"200\" : { \"description\" : \"Successful Response\" , \"content\" : { \"application/json\" : { ...","title":"Check the openapi.json"},{"location":"tutorial/first-steps/#what-is-openapi-for","text":"This OpenAPI schema is what powers the 2 interactive documentation systems included. And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with FastAPI . You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.","title":"What is OpenAPI for"},{"location":"tutorial/first-steps/#recap-step-by-step","text":"","title":"Recap, step by step"},{"location":"tutorial/first-steps/#step-1-import-fastapi","text":"from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } FastAPI is a Python class that provides all the functionality for your API. Technical Details FastAPI is a class that inherits directly from Starlette . You can use all the Starlette functionality with FastAPI too.","title":"Step 1: import FastAPI"},{"location":"tutorial/first-steps/#step-2-create-a-fastapi-instance","text":"from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } Here the app variable will be an \"instance\" of the class FastAPI . This will be the main point of interaction to create all your API. This app is the same one referred by uvicorn in the command: uvicorn main:app --reload If you create your app like: from fastapi import FastAPI my_awesome_api = FastAPI () @my_awesome_api . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } And put it in a file main.py , then you would call uvicorn like: uvicorn main:my_awesome_api --reload","title":"Step 2: create a FastAPI \"instance\""},{"location":"tutorial/first-steps/#step-3-create-a-path-operation","text":"","title":"Step 3: create a path operation"},{"location":"tutorial/first-steps/#path","text":"\"Path\" here refers to the last part of the URL starting from the first / . So, in a URL like: https://example.com/items/foo ...the path would be: /items/foo Info A \"path\" is also commonly called an \"endpoint\" or a \"route\". Building an API, the \"path\" is the main way to separate \"concerns\" and \"resources\".","title":"Path"},{"location":"tutorial/first-steps/#operation","text":"\"Operation\" here refers to one of the HTTP \"methods\". One of: POST GET PUT DELETE ...and the more exotic ones: OPTIONS HEAD PATCH TRACE In the HTTP protocol, you can communicate to each path using one (or more) of these \"methods\". When building APIs, you normally use these specific HTTP methods to perform a specific action. Normally you use: POST : to create data. GET : to read data. PUT : to update data. DELETE : to delete data. So, in OpenAPI, each of the HTTP methods is called an \"operation\". We are going to call them \" operations \" too.","title":"Operation"},{"location":"tutorial/first-steps/#define-a-path-operation-function","text":"from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } The @app.get(\"/\") tells FastAPI that the function right below is in charge of handling requests that go to: the path / using a get operation @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells FastAPI that the function below corresponds to the path / with an operation get . It is the \" path operation decorator \". You can also use the other operations: @app.post() @app.put() @app.delete() And the more exotic ones: @app.options() @app.head() @app.patch() @app.trace() Tip You are free to use each operation (HTTP method) as you wish. FastAPI doesn't enforce any specific meaning. The information here is presented as a guideline, not a requirement. For example, when using GraphQL you normally perform all the actions using only post .","title":"Define a path operation function"},{"location":"tutorial/first-steps/#step-4-define-the-path-operation-function","text":"This is our \" path operation function \": path : is / . operation : is get . function : is the function below the \"decorator\" (below @app.get(\"/\") ). from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } This is a Python function. It will be called by FastAPI whenever it receives a request to the URL \" / \" using GET . In this case, it is an async function. You could also define it as a normal function instead of async def : from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def root (): return { \"message\" : \"Hello World\" } Note If you don't know the difference, check the Async: \"In a hurry?\" .","title":"Step 4: define the path operation function"},{"location":"tutorial/first-steps/#step-5-return-the-content","text":"from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Hello World\" } You can return a dict , list , singular values as str , int , etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.","title":"Step 5: return the content"},{"location":"tutorial/first-steps/#recap","text":"Import FastAPI . Create an app instance. Write a path operation decorator (like @app.get(\"/\") ). Write a path operation function (like def root(): ... above). Run the development server (like uvicorn main:app --reload ).","title":"Recap"},{"location":"tutorial/handling-errors/","text":"There are many situations in where you need to notify an error to a client that is using your API. This client could be a browser with a frontend, a code from someone else, an IoT device, etc. You could need to tell the client that: The client doesn't have enough privileges for that operation. The client doesn't have access to that resource. The item the client was trying to access doesn't exist. etc. In these cases, you would normally return an HTTP status code in the range of 400 (from 400 to 499). This is similar to the 200 HTTP status codes (from 200 to 299). Those \"200\" status codes mean that somehow there was a \"success\" in the request. The status codes in the 400 range mean that there was an error from the client. Remember all those \"404 Not Found\" errors (and jokes)? Use HTTPException \u00b6 To return HTTP responses with errors to the client you use HTTPException . Import HTTPException \u00b6 from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return { \"item\" : items [ item_id ]} Raise an HTTPException in your code \u00b6 HTTPException is a normal Python exception with additional data relevant for APIs. Because it's a Python exception, you don't return it, you raise it. This also means that if you are inside a utility function that you are calling inside of your path operation function , and you raise the HTTPException from inside of that utility function, it won't run the rest of the code in the path operation function , it will terminate that request right away and send the HTTP error from the HTTPException to the client. The benefit of raising an exception over return ing a value will be more evident in the section about Dependencies and Security. In this example, when the client request an item by an ID that doesn't exist, raise an exception with a status code of 404 : from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return { \"item\" : items [ item_id ]} The resulting response \u00b6 If the client requests http://example.com/items/foo (an item_id \"foo\" ), he will receive an HTTP status code of 200, and a JSON response of: { \"item\" : \"The Foo Wrestlers\" } But if the client requests http://example.com/items/bar (a non-existent item_id \"bar\" ), he will receive an HTTP status code of 404 (the \"not found\" error), and a JSON response of: { \"detail\" : \"Item not found\" } Tip When raising an HTTPException , you can pass any value that can be converted to JSON as the parameter detail , not only str . You could pass a dict , a list , etc. They are handled automatically by FastAPI and converted to JSON. Add custom headers \u00b6 There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security. You probably won't need to use it directly in your code. But in case you needed it for an advanced scenario, you can add custom headers: from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items-header/ {item_id} \" ) async def read_item_header ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" , headers = { \"X-Error\" : \"There goes my error\" }, ) return { \"item\" : items [ item_id ]} Install custom exception handlers \u00b6 You can add custom exception handlers with the same exception utilities from Starlette . Let's say you have a custom exception UnicornException that you (or a library you use) might raise . And you want to handle this exception globally with FastAPI. You could add a custom exception handler with @app.exception_handler() : from fastapi import FastAPI from starlette.requests import Request from starlette.responses import JSONResponse class UnicornException ( Exception ): def __init__ ( self , name : str ): self . name = name app = FastAPI () @app . exception_handler ( UnicornException ) async def unicorn_exception_handler ( request : Request , exc : UnicornException ): return JSONResponse ( status_code = 418 , content = { \"message\" : f \"Oops! {exc.name} did something. There goes a rainbow...\" }, ) @app . get ( \"/unicorns/ {name} \" ) async def read_unicorn ( name : str ): if name == \"yolo\" : raise UnicornException ( name = name ) return { \"unicorn_name\" : name } Here, if you request /unicorns/yolo , the path operation will raise a UnicornException . But it will be handled by the unicorn_exception_handler . So, you will receive a clean error, with an HTTP status code of 418 and a JSON content of: { \"message\" : \"Oops! yolo did something. There goes a rainbow...\" } Override the default exception handlers \u00b6 FastAPI has some default exception handlers. These handlers are in charge or returning the default JSON responses when you raise an HTTPException and when the request has invalid data. You can override these exception handlers with your own. Override request validation exceptions \u00b6 When a request contains invalid data, FastAPI internally raises a RequestValidationError . And it also includes a default exception handler for it. To override it, import the RequestValidationError and use it with @app.exception_handler(RequestValidationError) to decorate the exception handler. The exception handler will receive a Request and the exception. from fastapi import FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.responses import PlainTextResponse app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def http_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc . detail ), status_code = exc . status_code ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc ), status_code = 400 ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id } Now, if you go to /items/foo , instead of getting the default JSON error with: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } you will get a text version, with: 1 validation error path -> item_id value is not a valid integer (type=type_error.integer) RequestValidationError vs ValidationError \u00b6 Warning These are technical details that you might skip if it's not important for you now. RequestValidationError is a sub-class of Pydantic's ValidationError . FastAPI uses it so that, if you use a Pydantic model in response_model , and your data has an error, you will see the error in your log. But the client/user will not see it. Instead, the client will receive an \"Internal Server Error\" with a HTTP status code 500 . It should be this way because if you have a Pydantic ValidationError in your response or anywhere in your code (not in the client's request ), it's actually a bug in your code. And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability. Override the HTTPException error handler \u00b6 The same way, you can override the HTTPException handler. For example, you could want to return a plain text response instead of JSON for these errors: from fastapi import FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.responses import PlainTextResponse app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def http_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc . detail ), status_code = exc . status_code ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc ), status_code = 400 ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id } Use the RequestValidationError body \u00b6 The RequestValidationError contains the body it received with invalid data. You could use it while developing your app to log the body and debug it, return it to the user, etc. from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from fastapi.exceptions import RequestValidationError from pydantic import BaseModel from starlette import status from starlette.requests import Request from starlette.responses import JSONResponse app = FastAPI () @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request : Request , exc : RequestValidationError ): return JSONResponse ( status_code = status . HTTP_422_UNPROCESSABLE_ENTITY , content = jsonable_encoder ({ \"detail\" : exc . errors (), \"body\" : exc . body }), ) class Item ( BaseModel ): title : str size : int @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item Now try sending an invalid item like: { \"title\" : \"towel\" , \"size\" : \"XL\" } You will receive a response telling you that the data is invalid containing the received body: { \"detail\" : [ { \"loc\" : [ \"body\" , \"item\" , \"size\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ], \"body\" : { \"title\" : \"towel\" , \"size\" : \"XL\" } } FastAPI's HTTPException vs Starlette's HTTPException \u00b6 FastAPI has its own HTTPException . And FastAPI 's HTTPException error class inherits from Starlette's HTTPException error class. The only difference, is that FastAPI 's HTTPException allows you to add headers to be included in the response. This is needed/used internally for OAuth 2.0 and some security utilities. So, you can keep raising FastAPI 's HTTPException as normally in your code. But when you register an exception handler, you should register it for Starlette's HTTPException . This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises an HTTPException , your handler will be able to catch and handle it. In this example, to be able to have both HTTPException s in the same code, Starlette's exceptions is renamed to StarletteHTTPException : from starlette.exceptions import HTTPException as StarletteHTTPException Re-use FastAPI 's exception handlers \u00b6 You could also just want to use the exception somehow, but then use the same default exception handlers from FastAPI . You can import and re-use the default exception handlers from fastapi.exception_handlers : from fastapi import FastAPI , HTTPException from fastapi.exception_handlers import ( http_exception_handler , request_validation_exception_handler , ) from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def custom_http_exception_handler ( request , exc ): print ( f \"OMG! An HTTP error!: {exc} \" ) return await http_exception_handler ( request , exc ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): print ( f \"OMG! The client sent invalid data!: {exc} \" ) return await request_validation_exception_handler ( request , exc ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id } In this example, you are just print ing the error with a very expressive message. But you get the idea, you can use the exception and then just re-use the default exception handlers.","title":"Handling Errors"},{"location":"tutorial/handling-errors/#use-httpexception","text":"To return HTTP responses with errors to the client you use HTTPException .","title":"Use HTTPException"},{"location":"tutorial/handling-errors/#import-httpexception","text":"from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return { \"item\" : items [ item_id ]}","title":"Import HTTPException"},{"location":"tutorial/handling-errors/#raise-an-httpexception-in-your-code","text":"HTTPException is a normal Python exception with additional data relevant for APIs. Because it's a Python exception, you don't return it, you raise it. This also means that if you are inside a utility function that you are calling inside of your path operation function , and you raise the HTTPException from inside of that utility function, it won't run the rest of the code in the path operation function , it will terminate that request right away and send the HTTP error from the HTTPException to the client. The benefit of raising an exception over return ing a value will be more evident in the section about Dependencies and Security. In this example, when the client request an item by an ID that doesn't exist, raise an exception with a status code of 404 : from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return { \"item\" : items [ item_id ]}","title":"Raise an HTTPException in your code"},{"location":"tutorial/handling-errors/#the-resulting-response","text":"If the client requests http://example.com/items/foo (an item_id \"foo\" ), he will receive an HTTP status code of 200, and a JSON response of: { \"item\" : \"The Foo Wrestlers\" } But if the client requests http://example.com/items/bar (a non-existent item_id \"bar\" ), he will receive an HTTP status code of 404 (the \"not found\" error), and a JSON response of: { \"detail\" : \"Item not found\" } Tip When raising an HTTPException , you can pass any value that can be converted to JSON as the parameter detail , not only str . You could pass a dict , a list , etc. They are handled automatically by FastAPI and converted to JSON.","title":"The resulting response"},{"location":"tutorial/handling-errors/#add-custom-headers","text":"There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security. You probably won't need to use it directly in your code. But in case you needed it for an advanced scenario, you can add custom headers: from fastapi import FastAPI , HTTPException app = FastAPI () items = { \"foo\" : \"The Foo Wrestlers\" } @app . get ( \"/items-header/ {item_id} \" ) async def read_item_header ( item_id : str ): if item_id not in items : raise HTTPException ( status_code = 404 , detail = \"Item not found\" , headers = { \"X-Error\" : \"There goes my error\" }, ) return { \"item\" : items [ item_id ]}","title":"Add custom headers"},{"location":"tutorial/handling-errors/#install-custom-exception-handlers","text":"You can add custom exception handlers with the same exception utilities from Starlette . Let's say you have a custom exception UnicornException that you (or a library you use) might raise . And you want to handle this exception globally with FastAPI. You could add a custom exception handler with @app.exception_handler() : from fastapi import FastAPI from starlette.requests import Request from starlette.responses import JSONResponse class UnicornException ( Exception ): def __init__ ( self , name : str ): self . name = name app = FastAPI () @app . exception_handler ( UnicornException ) async def unicorn_exception_handler ( request : Request , exc : UnicornException ): return JSONResponse ( status_code = 418 , content = { \"message\" : f \"Oops! {exc.name} did something. There goes a rainbow...\" }, ) @app . get ( \"/unicorns/ {name} \" ) async def read_unicorn ( name : str ): if name == \"yolo\" : raise UnicornException ( name = name ) return { \"unicorn_name\" : name } Here, if you request /unicorns/yolo , the path operation will raise a UnicornException . But it will be handled by the unicorn_exception_handler . So, you will receive a clean error, with an HTTP status code of 418 and a JSON content of: { \"message\" : \"Oops! yolo did something. There goes a rainbow...\" }","title":"Install custom exception handlers"},{"location":"tutorial/handling-errors/#override-the-default-exception-handlers","text":"FastAPI has some default exception handlers. These handlers are in charge or returning the default JSON responses when you raise an HTTPException and when the request has invalid data. You can override these exception handlers with your own.","title":"Override the default exception handlers"},{"location":"tutorial/handling-errors/#override-request-validation-exceptions","text":"When a request contains invalid data, FastAPI internally raises a RequestValidationError . And it also includes a default exception handler for it. To override it, import the RequestValidationError and use it with @app.exception_handler(RequestValidationError) to decorate the exception handler. The exception handler will receive a Request and the exception. from fastapi import FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.responses import PlainTextResponse app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def http_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc . detail ), status_code = exc . status_code ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc ), status_code = 400 ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id } Now, if you go to /items/foo , instead of getting the default JSON error with: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } you will get a text version, with: 1 validation error path -> item_id value is not a valid integer (type=type_error.integer)","title":"Override request validation exceptions"},{"location":"tutorial/handling-errors/#requestvalidationerror-vs-validationerror","text":"Warning These are technical details that you might skip if it's not important for you now. RequestValidationError is a sub-class of Pydantic's ValidationError . FastAPI uses it so that, if you use a Pydantic model in response_model , and your data has an error, you will see the error in your log. But the client/user will not see it. Instead, the client will receive an \"Internal Server Error\" with a HTTP status code 500 . It should be this way because if you have a Pydantic ValidationError in your response or anywhere in your code (not in the client's request ), it's actually a bug in your code. And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.","title":"RequestValidationError vs ValidationError"},{"location":"tutorial/handling-errors/#override-the-httpexception-error-handler","text":"The same way, you can override the HTTPException handler. For example, you could want to return a plain text response instead of JSON for these errors: from fastapi import FastAPI , HTTPException from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.responses import PlainTextResponse app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def http_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc . detail ), status_code = exc . status_code ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): return PlainTextResponse ( str ( exc ), status_code = 400 ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id }","title":"Override the HTTPException error handler"},{"location":"tutorial/handling-errors/#use-the-requestvalidationerror-body","text":"The RequestValidationError contains the body it received with invalid data. You could use it while developing your app to log the body and debug it, return it to the user, etc. from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from fastapi.exceptions import RequestValidationError from pydantic import BaseModel from starlette import status from starlette.requests import Request from starlette.responses import JSONResponse app = FastAPI () @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request : Request , exc : RequestValidationError ): return JSONResponse ( status_code = status . HTTP_422_UNPROCESSABLE_ENTITY , content = jsonable_encoder ({ \"detail\" : exc . errors (), \"body\" : exc . body }), ) class Item ( BaseModel ): title : str size : int @app . post ( \"/items/\" ) async def create_item ( item : Item ): return item Now try sending an invalid item like: { \"title\" : \"towel\" , \"size\" : \"XL\" } You will receive a response telling you that the data is invalid containing the received body: { \"detail\" : [ { \"loc\" : [ \"body\" , \"item\" , \"size\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ], \"body\" : { \"title\" : \"towel\" , \"size\" : \"XL\" } }","title":"Use the RequestValidationError body"},{"location":"tutorial/handling-errors/#fastapis-httpexception-vs-starlettes-httpexception","text":"FastAPI has its own HTTPException . And FastAPI 's HTTPException error class inherits from Starlette's HTTPException error class. The only difference, is that FastAPI 's HTTPException allows you to add headers to be included in the response. This is needed/used internally for OAuth 2.0 and some security utilities. So, you can keep raising FastAPI 's HTTPException as normally in your code. But when you register an exception handler, you should register it for Starlette's HTTPException . This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises an HTTPException , your handler will be able to catch and handle it. In this example, to be able to have both HTTPException s in the same code, Starlette's exceptions is renamed to StarletteHTTPException : from starlette.exceptions import HTTPException as StarletteHTTPException","title":"FastAPI's HTTPException vs Starlette's HTTPException"},{"location":"tutorial/handling-errors/#re-use-fastapis-exception-handlers","text":"You could also just want to use the exception somehow, but then use the same default exception handlers from FastAPI . You can import and re-use the default exception handlers from fastapi.exception_handlers : from fastapi import FastAPI , HTTPException from fastapi.exception_handlers import ( http_exception_handler , request_validation_exception_handler , ) from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI () @app . exception_handler ( StarletteHTTPException ) async def custom_http_exception_handler ( request , exc ): print ( f \"OMG! An HTTP error!: {exc} \" ) return await http_exception_handler ( request , exc ) @app . exception_handler ( RequestValidationError ) async def validation_exception_handler ( request , exc ): print ( f \"OMG! The client sent invalid data!: {exc} \" ) return await request_validation_exception_handler ( request , exc ) @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): if item_id == 3 : raise HTTPException ( status_code = 418 , detail = \"Nope! I don't like 3.\" ) return { \"item_id\" : item_id } In this example, you are just print ing the error with a very expressive message. But you get the idea, you can use the exception and then just re-use the default exception handlers.","title":"Re-use FastAPI's exception handlers"},{"location":"tutorial/header-params/","text":"You can define Header parameters the same way you define Query , Path and Cookie parameters. Import Header \u00b6 First import Header : from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , user_agent : str = Header ( None )): return { \"User-Agent\" : user_agent } Declare Header parameters \u00b6 Then declare the header parameters using the same structure as with Path , Query and Cookie . The first value is the default value, you can pass all the extra validation or annotation parameters: from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , user_agent : str = Header ( None )): return { \"User-Agent\" : user_agent } Technical Details Header is a \"sister\" class of Path , Query and Cookie . It also inherits from the same common Param class. But remember that when you import Query , Path , Header , and others from fastapi , those are actually functions that return special classes. Info To declare headers, you need to use Header , because otherwise the parameters would be interpreted as query parameters. Automatic conversion \u00b6 Header has a little extra functionality on top of what Path , Query and Cookie provide. Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" ( - ). But a variable like user-agent is invalid in Python. So, by default, Header will convert the parameter names characters from underscore ( _ ) to hyphen ( - ) to extract and document the headers. Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake_case\"). So, you can use user_agent as you normally would in Python code, instead of needing to capitalize the first letters as User_Agent or something similar. If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert_underscores of Header to False : from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , strange_header : str = Header ( None , convert_underscores = False )): return { \"strange_header\" : strange_header } Warning Before setting convert_underscores to False , bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores. Duplicate headers \u00b6 It is possible to receive duplicate headers. That means, the same header with multiple values. You can define those cases using a list in the type declaration. You will receive all the values from the duplicate header as a Python list . For example, to declare a header of X-Token that can appear more than once, you can write: from typing import List from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( x_token : List [ str ] = Header ( None )): return { \"X-Token values\" : x_token } If you communicate with that path operation sending two HTTP headers like: X-Token: foo X-Token: bar The response would be like: { \"X-Token values\" : [ \"bar\" , \"foo\" ] } Recap \u00b6 Declare headers with Header , using the same common pattern as Query , Path and Cookie . And don't worry about underscores in your variables, FastAPI will take care of converting them.","title":"Header Parameters"},{"location":"tutorial/header-params/#import-header","text":"First import Header : from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , user_agent : str = Header ( None )): return { \"User-Agent\" : user_agent }","title":"Import Header"},{"location":"tutorial/header-params/#declare-header-parameters","text":"Then declare the header parameters using the same structure as with Path , Query and Cookie . The first value is the default value, you can pass all the extra validation or annotation parameters: from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , user_agent : str = Header ( None )): return { \"User-Agent\" : user_agent } Technical Details Header is a \"sister\" class of Path , Query and Cookie . It also inherits from the same common Param class. But remember that when you import Query , Path , Header , and others from fastapi , those are actually functions that return special classes. Info To declare headers, you need to use Header , because otherwise the parameters would be interpreted as query parameters.","title":"Declare Header parameters"},{"location":"tutorial/header-params/#automatic-conversion","text":"Header has a little extra functionality on top of what Path , Query and Cookie provide. Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" ( - ). But a variable like user-agent is invalid in Python. So, by default, Header will convert the parameter names characters from underscore ( _ ) to hyphen ( - ) to extract and document the headers. Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake_case\"). So, you can use user_agent as you normally would in Python code, instead of needing to capitalize the first letters as User_Agent or something similar. If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert_underscores of Header to False : from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( * , strange_header : str = Header ( None , convert_underscores = False )): return { \"strange_header\" : strange_header } Warning Before setting convert_underscores to False , bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.","title":"Automatic conversion"},{"location":"tutorial/header-params/#duplicate-headers","text":"It is possible to receive duplicate headers. That means, the same header with multiple values. You can define those cases using a list in the type declaration. You will receive all the values from the duplicate header as a Python list . For example, to declare a header of X-Token that can appear more than once, you can write: from typing import List from fastapi import FastAPI , Header app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( x_token : List [ str ] = Header ( None )): return { \"X-Token values\" : x_token } If you communicate with that path operation sending two HTTP headers like: X-Token: foo X-Token: bar The response would be like: { \"X-Token values\" : [ \"bar\" , \"foo\" ] }","title":"Duplicate headers"},{"location":"tutorial/header-params/#recap","text":"Declare headers with Header , using the same common pattern as Query , Path and Cookie . And don't worry about underscores in your variables, FastAPI will take care of converting them.","title":"Recap"},{"location":"tutorial/middleware/","text":"You can add middleware to FastAPI applications. A \"middleware\" is a function that works with every request before it is processed by any specific path operation . And also with every response before returning it. It takes each request that comes to your application. It can then do something to that request or run any needed code. Then it passes the request to be processed by the rest of the application (by some path operation ). It then takes the response generated by the application (by some path operation ). It can do something to that response or run any needed code. Then it returns the response . Create a middleware \u00b6 To create a middleware you use the decorator @app.middleware(\"http\") on top of a function. The middleware function receives: The request . A function call_next that will receive the request as a parameter. This function will pass the request to the corresponding path operation . Then it returns the response generated by the corresponding path operation . You can then modify further the response before returning it. import time from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . middleware ( \"http\" ) async def add_process_time_header ( request : Request , call_next ): start_time = time . time () response = await call_next ( request ) process_time = time . time () - start_time response . headers [ \"X-Process-Time\" ] = str ( process_time ) return response Tip Have in mind that custom proprietary headers can be added using the 'X-' prefix . But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations ( CORS (Cross-Origin Resource Sharing) ) using the parameter expose_headers documented in Starlette's CORS docs . Before and after the response \u00b6 You can add code to be run with the request , before any path operation receives it. And also after the response is generated, before returning it. For example, you could add a custom header X-Process-Time containing the time in seconds that it took to process the request and generate a response: import time from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . middleware ( \"http\" ) async def add_process_time_header ( request : Request , call_next ): start_time = time . time () response = await call_next ( request ) process_time = time . time () - start_time response . headers [ \"X-Process-Time\" ] = str ( process_time ) return response Starlette's Middleware \u00b6 You can also add any other Starlette Middleware . These are classes instead of plain functions. Including: CORSMiddleware (described in the next section). GZipMiddleware . SentryMiddleware . ...and others.","title":"Middleware"},{"location":"tutorial/middleware/#create-a-middleware","text":"To create a middleware you use the decorator @app.middleware(\"http\") on top of a function. The middleware function receives: The request . A function call_next that will receive the request as a parameter. This function will pass the request to the corresponding path operation . Then it returns the response generated by the corresponding path operation . You can then modify further the response before returning it. import time from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . middleware ( \"http\" ) async def add_process_time_header ( request : Request , call_next ): start_time = time . time () response = await call_next ( request ) process_time = time . time () - start_time response . headers [ \"X-Process-Time\" ] = str ( process_time ) return response Tip Have in mind that custom proprietary headers can be added using the 'X-' prefix . But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations ( CORS (Cross-Origin Resource Sharing) ) using the parameter expose_headers documented in Starlette's CORS docs .","title":"Create a middleware"},{"location":"tutorial/middleware/#before-and-after-the-response","text":"You can add code to be run with the request , before any path operation receives it. And also after the response is generated, before returning it. For example, you could add a custom header X-Process-Time containing the time in seconds that it took to process the request and generate a response: import time from fastapi import FastAPI from starlette.requests import Request app = FastAPI () @app . middleware ( \"http\" ) async def add_process_time_header ( request : Request , call_next ): start_time = time . time () response = await call_next ( request ) process_time = time . time () - start_time response . headers [ \"X-Process-Time\" ] = str ( process_time ) return response","title":"Before and after the response"},{"location":"tutorial/middleware/#starlettes-middleware","text":"You can also add any other Starlette Middleware . These are classes instead of plain functions. Including: CORSMiddleware (described in the next section). GZipMiddleware . SentryMiddleware . ...and others.","title":"Starlette's Middleware"},{"location":"tutorial/path-operation-configuration/","text":"There are several parameters that you can pass to your path operation decorator to configure it. Warning Notice that these parameters are passed directly to the path operation decorator , not to your path operation function . Response Status Code \u00b6 You can define the (HTTP) status_code to be used in the response of your path operation . You can pass directly the int code, like 404 . But if you don't remember what each number code is for, you can use the shortcut constants from starlette : from typing import Set from fastapi import FastAPI from pydantic import BaseModel from starlette.status import HTTP_201_CREATED app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , status_code = HTTP_201_CREATED ) async def create_item ( * , item : Item ): return item That status code will be used in the response and will be added to the OpenAPI schema. Tags \u00b6 You can add tags to your path operation , pass the parameter tags with a list of str (commonly just one str ): from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , tags = [ \"items\" ]) async def create_item ( * , item : Item ): return item @app . get ( \"/items/\" , tags = [ \"items\" ]) async def read_items (): return [{ \"name\" : \"Foo\" , \"price\" : 42 }] @app . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"johndoe\" }] They will be added to the OpenAPI schema and used by the automatic documentation interfaces: Summary and description \u00b6 You can add a summary and description : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" , description = \"Create an item with all the information, name, description, price, tax and a set of unique tags\" , ) async def create_item ( * , item : Item ): return item Description from docstring \u00b6 As descriptions tend to be long and cover multiple lines, you can declare the path operation description in the function docstring and FastAPI will read it from there. You can write Markdown in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation). from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \"\"\" return item It will be used in the interactive docs: Response description \u00b6 You can specify the response description with the parameter response_description : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" , response_description = \"The created item\" , ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \"\"\" return item Info Notice that response_description refers specifically to the response, the description refers to the path operation in general. Check OpenAPI specifies that each path operation requires a response description. So, if you don't provide one, FastAPI will automatically generate one of \"Successful response\". Deprecate a path operation \u00b6 If you need to mark a path operation as deprecated , but without removing it, pass the parameter deprecated : from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , tags = [ \"items\" ]) async def read_items (): return [{ \"name\" : \"Foo\" , \"price\" : 42 }] @app . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"johndoe\" }] @app . get ( \"/elements/\" , tags = [ \"items\" ], deprecated = True ) async def read_elements (): return [{ \"item_id\" : \"Foo\" }] It will be clearly marked as deprecated in the interactive docs: Check how deprecated and non-deprecated path operations look like: Recap \u00b6 You can configure and add metadata for your path operations easily by passing parameters to the path operation decorators .","title":"Path Operation Configuration"},{"location":"tutorial/path-operation-configuration/#response-status-code","text":"You can define the (HTTP) status_code to be used in the response of your path operation . You can pass directly the int code, like 404 . But if you don't remember what each number code is for, you can use the shortcut constants from starlette : from typing import Set from fastapi import FastAPI from pydantic import BaseModel from starlette.status import HTTP_201_CREATED app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , status_code = HTTP_201_CREATED ) async def create_item ( * , item : Item ): return item That status code will be used in the response and will be added to the OpenAPI schema.","title":"Response Status Code"},{"location":"tutorial/path-operation-configuration/#tags","text":"You can add tags to your path operation , pass the parameter tags with a list of str (commonly just one str ): from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , tags = [ \"items\" ]) async def create_item ( * , item : Item ): return item @app . get ( \"/items/\" , tags = [ \"items\" ]) async def read_items (): return [{ \"name\" : \"Foo\" , \"price\" : 42 }] @app . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"johndoe\" }] They will be added to the OpenAPI schema and used by the automatic documentation interfaces:","title":"Tags"},{"location":"tutorial/path-operation-configuration/#summary-and-description","text":"You can add a summary and description : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" , description = \"Create an item with all the information, name, description, price, tax and a set of unique tags\" , ) async def create_item ( * , item : Item ): return item","title":"Summary and description"},{"location":"tutorial/path-operation-configuration/#description-from-docstring","text":"As descriptions tend to be long and cover multiple lines, you can declare the path operation description in the function docstring and FastAPI will read it from there. You can write Markdown in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation). from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \"\"\" return item It will be used in the interactive docs:","title":"Description from docstring"},{"location":"tutorial/path-operation-configuration/#response-description","text":"You can specify the response description with the parameter response_description : from typing import Set from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : Set [ str ] = [] @app . post ( \"/items/\" , response_model = Item , summary = \"Create an item\" , response_description = \"The created item\" , ) async def create_item ( * , item : Item ): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \"\"\" return item Info Notice that response_description refers specifically to the response, the description refers to the path operation in general. Check OpenAPI specifies that each path operation requires a response description. So, if you don't provide one, FastAPI will automatically generate one of \"Successful response\".","title":"Response description"},{"location":"tutorial/path-operation-configuration/#deprecate-a-path-operation","text":"If you need to mark a path operation as deprecated , but without removing it, pass the parameter deprecated : from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" , tags = [ \"items\" ]) async def read_items (): return [{ \"name\" : \"Foo\" , \"price\" : 42 }] @app . get ( \"/users/\" , tags = [ \"users\" ]) async def read_users (): return [{ \"username\" : \"johndoe\" }] @app . get ( \"/elements/\" , tags = [ \"items\" ], deprecated = True ) async def read_elements (): return [{ \"item_id\" : \"Foo\" }] It will be clearly marked as deprecated in the interactive docs: Check how deprecated and non-deprecated path operations look like:","title":"Deprecate a path operation"},{"location":"tutorial/path-operation-configuration/#recap","text":"You can configure and add metadata for your path operations easily by passing parameters to the path operation decorators .","title":"Recap"},{"location":"tutorial/path-params-numeric-validations/","text":"The same way you can declare more validations and metadata for query parameters with Query , you can declare the same type of validations and metadata for path parameters with Path . Import Path \u00b6 First, import Path from fastapi : from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str = Query ( None , alias = \"item-query\" ), ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Declare metadata \u00b6 You can declare all the same parameters as for Query . For example, to declare a title metadata value for the path parameter item_id you can type: from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str = Query ( None , alias = \"item-query\" ), ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Note A path parameter is always required as it has to be part of the path. So, you should declare it with ... to mark it as required. Nevertheless, even if you declared it with None or set a default value, it would not affect anything, it would still be always required. Order the parameters as you need \u00b6 Let's say that you want to declare the query parameter q as a required str . And you don't need to declare anything else for that parameter, so you don't really need to use Query . But you still need to use Path for the item_id path parameter. Python will complain if you put a value with a \"default\" before a value that doesn't have a \"default\". But you can re-order them, and have the value without a default (the query parameter q ) first. It doesn't matter for FastAPI . It will detect the parameters by their names, types and default declarations ( Query , Path , etc), it doesn't care about the order. So, you can declare your function as: from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( q : str , item_id : int = Path ( ... , title = \"The ID of the item to get\" ) ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Order the parameters as you need, tricks \u00b6 If you want to declare the q query parameter without a Query nor any default value, and the path parameter item_id using Path , and have them in a different order, Python has a little special syntax for that. Pass * , as the first parameter of the function. Python won't do anything with that * , but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as kwargs . Even if they don't have a default value. from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Number validations: greater than or equal \u00b6 With Query and Path (and other's you'll see later) you can declare string constraints, but also number constraints. Here, with ge=1 , item_id will need to be an integer number \" g reater than or e qual\" to 1 . from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 1 ), q : str ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Number validations: greater than and less than or equal \u00b6 The same applies for: gt : g reater t han le : l ess than or e qual from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , gt = 0 , le = 1000 ), q : str , ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Number validations: floats, greater than and less than \u00b6 Number validations also work for float values. Here's where it becomes important to be able to declare gt and not just ge . As with it you can require, for example, that a value must be greater than 0 , even if it is less than 1 . So, 0.5 would be a valid value. But 0.0 or 0 would not. And the same for lt . from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 0 , le = 1000 ), q : str , size : float = Query ( ... , gt = 0 , lt = 10.5 ) ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Recap \u00b6 With Query , Path (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with Query Parameters and String Validations . And you can also declare numeric validations: gt : g reater t han ge : g reater than or e qual lt : l ess t han le : l ess than or e qual Info Query , Path and others you will see later subclasses of a common Param class (that you don't need to use). And all of them share the same all these same parameters of additional validation and metadata you have seen. Technical Details When you import Query , Path and others from fastapi , they are actually functions. That when called, return instances of classes of the same name. So, you import Query , which is a function. And when you call it, it returns an instance of a class also named Query . These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types. That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.","title":"Path Parameters and Numeric Validations"},{"location":"tutorial/path-params-numeric-validations/#import-path","text":"First, import Path from fastapi : from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str = Query ( None , alias = \"item-query\" ), ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Import Path"},{"location":"tutorial/path-params-numeric-validations/#declare-metadata","text":"You can declare all the same parameters as for Query . For example, to declare a title metadata value for the path parameter item_id you can type: from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str = Query ( None , alias = \"item-query\" ), ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results Note A path parameter is always required as it has to be part of the path. So, you should declare it with ... to mark it as required. Nevertheless, even if you declared it with None or set a default value, it would not affect anything, it would still be always required.","title":"Declare metadata"},{"location":"tutorial/path-params-numeric-validations/#order-the-parameters-as-you-need","text":"Let's say that you want to declare the query parameter q as a required str . And you don't need to declare anything else for that parameter, so you don't really need to use Query . But you still need to use Path for the item_id path parameter. Python will complain if you put a value with a \"default\" before a value that doesn't have a \"default\". But you can re-order them, and have the value without a default (the query parameter q ) first. It doesn't matter for FastAPI . It will detect the parameters by their names, types and default declarations ( Query , Path , etc), it doesn't care about the order. So, you can declare your function as: from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( q : str , item_id : int = Path ( ... , title = \"The ID of the item to get\" ) ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Order the parameters as you need"},{"location":"tutorial/path-params-numeric-validations/#order-the-parameters-as-you-need-tricks","text":"If you want to declare the q query parameter without a Query nor any default value, and the path parameter item_id using Path , and have them in a different order, Python has a little special syntax for that. Pass * , as the first parameter of the function. Python won't do anything with that * , but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as kwargs . Even if they don't have a default value. from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" ), q : str ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Order the parameters as you need, tricks"},{"location":"tutorial/path-params-numeric-validations/#number-validations-greater-than-or-equal","text":"With Query and Path (and other's you'll see later) you can declare string constraints, but also number constraints. Here, with ge=1 , item_id will need to be an integer number \" g reater than or e qual\" to 1 . from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 1 ), q : str ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Number validations: greater than or equal"},{"location":"tutorial/path-params-numeric-validations/#number-validations-greater-than-and-less-than-or-equal","text":"The same applies for: gt : g reater t han le : l ess than or e qual from fastapi import FastAPI , Path app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , gt = 0 , le = 1000 ), q : str , ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Number validations: greater than and less than or equal"},{"location":"tutorial/path-params-numeric-validations/#number-validations-floats-greater-than-and-less-than","text":"Number validations also work for float values. Here's where it becomes important to be able to declare gt and not just ge . As with it you can require, for example, that a value must be greater than 0 , even if it is less than 1 . So, 0.5 would be a valid value. But 0.0 or 0 would not. And the same for lt . from fastapi import FastAPI , Path , Query app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_items ( * , item_id : int = Path ( ... , title = \"The ID of the item to get\" , ge = 0 , le = 1000 ), q : str , size : float = Query ( ... , gt = 0 , lt = 10.5 ) ): results = { \"item_id\" : item_id } if q : results . update ({ \"q\" : q }) return results","title":"Number validations: floats, greater than and less than"},{"location":"tutorial/path-params-numeric-validations/#recap","text":"With Query , Path (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with Query Parameters and String Validations . And you can also declare numeric validations: gt : g reater t han ge : g reater than or e qual lt : l ess t han le : l ess than or e qual Info Query , Path and others you will see later subclasses of a common Param class (that you don't need to use). And all of them share the same all these same parameters of additional validation and metadata you have seen. Technical Details When you import Query , Path and others from fastapi , they are actually functions. That when called, return instances of classes of the same name. So, you import Query , which is a function. And when you call it, it returns an instance of a class also named Query . These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types. That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.","title":"Recap"},{"location":"tutorial/path-params/","text":"You can declare path \"parameters\" or \"variables\" with the same syntax used by Python format strings: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id ): return { \"item_id\" : item_id } The value of the path parameter item_id will be passed to your function as the argument item_id . So, if you run this example and go to http://127.0.0.1:8000/items/foo , you will see a response of: { \"item_id\" : \"foo\" } Path parameters with types \u00b6 You can declare the type of a path parameter in the function, using standard Python type annotations: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . Check This will give you editor support inside of your function, with error checks, completion, etc. Data conversion \u00b6 If you run this example and open your browser at http://127.0.0.1:8000/items/3 , you will see a response of: { \"item_id\" : 3 } Check Notice that the value your function received (and returned) is 3 , as a Python int , not a string \"3\" . So, with that type declaration, FastAPI gives you automatic request \"parsing\" . Data validation \u00b6 But if you go to the browser at http://127.0.0.1:8000/items/foo , you will see a nice HTTP error of: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } because the path parameter item_id had a value of \"foo\" , which is not an int . The same error would appear if you provided a float instead of an int, as in: http://127.0.0.1:8000/items/4.2 Check So, with the same Python type declaration, FastAPI gives you data validation. Notice that the error also clearly states exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API. Documentation \u00b6 And when you open your browser at http://127.0.0.1:8000/docs , you will see an automatic, interactive, API documentation like: Check Again, just with that same Python type declaration, FastAPI gives you automatic, interactive documentation (integrating Swagger UI). Notice that the path parameter is declared to be an integer. Standards-based benefits, alternative documentation \u00b6 And because the generated schema is from the OpenAPI standard, there are many compatible tools. Because of this, FastAPI itself provides an alternative API documentation (using ReDoc): The same way, there are many compatible tools. Including code generation tools for many languages. Pydantic \u00b6 All the data validation is performed under the hood by Pydantic , so you get all the benefits from it. And you know you are in good hands. You can use the same type declarations with str , float , bool and many other complex data types. Several of these are explored in the next chapters of the tutorial. Order matters \u00b6 When creating path operations , you can find situations where you have a fixed path. Like /users/me , let's say that it's to get data about the current user. And then you can also have a path /users/{user_id} to get data about a specific user by some user ID. Because path operations are evaluated in order, you need to make sure that the path for /users/me is declared before the one for /users/{user_id} : from fastapi import FastAPI app = FastAPI () @app . get ( \"/users/me\" ) async def read_user_me (): return { \"user_id\" : \"the current user\" } @app . get ( \"/users/ {user_id} \" ) async def read_user ( user_id : str ): return { \"user_id\" : user_id } Otherwise, the path for /users/{user_id} would match also for /users/me , \"thinking\" that it's receiving a parameter user_id with a value of \"me\" . Predefined values \u00b6 If you have a path operation that receives a path parameter , but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum . Create an Enum class \u00b6 Import Enum and create a sub-class that inherits from str and from Enum . By inheriting from str the API docs will be able to know that the values must be of type string and will be able to render correctly. And create class attributes with fixed values, those fixed values will be the available valid values: from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Info Enumerations (or enums) are available in Python since version 3.4. Tip If you are wondering, \"AlexNet\", \"ResNet\", and \"LeNet\" are just names of Machine Learning models . Declare a path parameter \u00b6 Then create a path parameter with a type annotation using the enum class you created ( ModelName ): from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Check the docs \u00b6 Because the available values for the path parameter are specified, the interactive docs can show them nicely: Working with Python enumerations \u00b6 The value of the path parameter will be an enumeration member . Compare enumeration members \u00b6 You can compare it with the enumeration member in your created enum ModelName : from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Get the enumeration value \u00b6 You can get the actual value (a str in this case) using model_name.value , or in general, your_enum_member.value : from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Tip You could also access the value \"lenet\" with ModelName.lenet.value . Return enumeration members \u00b6 You can return enum members from your path operation , even nested in a JSON body (e.g. a dict ). They will be converted to their corresponding values before returning them to the client: from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Path parameters containing paths \u00b6 Let's say you have a path operation with a path /files/{file_path} . But you need file_path itself to contain a path , like home/johndoe/myfile.txt . So, the URL for that file would be something like: /files/home/johndoe/myfile.txt . OpenAPI support \u00b6 OpenAPI doesn't support a way to declare a path parameter to contain a path inside, as that could lead to scenarios that are difficult to test and define. Nevertheless, you can still do it in FastAPI , using one of the internal tools from Starlette. And the docs would still work, although not adding any documentation telling that the parameter should contain a path. Path convertor \u00b6 Using an option directly from Starlette you can declare a path parameter containing a path using a URL like: /files/{file_path:path} In this case, the name of the parameter is file_path , and the last part, :path , tells it that the parameter should match any path . So, you can use it with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/files/{file_path:path}\" ) async def read_user_me ( file_path : str ): return { \"file_path\" : file_path } Tip You could need the parameter to contain /home/johndoe/myfile.txt , with a leading slash ( / ). In that case, the URL would be: /files//home/johndoe/myfile.txt , with a double slash ( // ) between files and home . Recap \u00b6 With FastAPI , by using short, intuitive and standard Python type declarations, you get: Editor support: error checks, autocompletion, etc. Data \" parsing \" Data validation API annotation and automatic documentation And you only have to declare them once. That's probably the main visible advantage of FastAPI compared to alternative frameworks (apart from the raw performance).","title":"Path Parameters"},{"location":"tutorial/path-params/#path-parameters-with-types","text":"You can declare the type of a path parameter in the function, using standard Python type annotations: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . Check This will give you editor support inside of your function, with error checks, completion, etc.","title":"Path parameters with types"},{"location":"tutorial/path-params/#data-conversion","text":"If you run this example and open your browser at http://127.0.0.1:8000/items/3 , you will see a response of: { \"item_id\" : 3 } Check Notice that the value your function received (and returned) is 3 , as a Python int , not a string \"3\" . So, with that type declaration, FastAPI gives you automatic request \"parsing\" .","title":"Data conversion"},{"location":"tutorial/path-params/#data-validation","text":"But if you go to the browser at http://127.0.0.1:8000/items/foo , you will see a nice HTTP error of: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } because the path parameter item_id had a value of \"foo\" , which is not an int . The same error would appear if you provided a float instead of an int, as in: http://127.0.0.1:8000/items/4.2 Check So, with the same Python type declaration, FastAPI gives you data validation. Notice that the error also clearly states exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API.","title":"Data validation"},{"location":"tutorial/path-params/#documentation","text":"And when you open your browser at http://127.0.0.1:8000/docs , you will see an automatic, interactive, API documentation like: Check Again, just with that same Python type declaration, FastAPI gives you automatic, interactive documentation (integrating Swagger UI). Notice that the path parameter is declared to be an integer.","title":"Documentation"},{"location":"tutorial/path-params/#standards-based-benefits-alternative-documentation","text":"And because the generated schema is from the OpenAPI standard, there are many compatible tools. Because of this, FastAPI itself provides an alternative API documentation (using ReDoc): The same way, there are many compatible tools. Including code generation tools for many languages.","title":"Standards-based benefits, alternative documentation"},{"location":"tutorial/path-params/#pydantic","text":"All the data validation is performed under the hood by Pydantic , so you get all the benefits from it. And you know you are in good hands. You can use the same type declarations with str , float , bool and many other complex data types. Several of these are explored in the next chapters of the tutorial.","title":"Pydantic"},{"location":"tutorial/path-params/#order-matters","text":"When creating path operations , you can find situations where you have a fixed path. Like /users/me , let's say that it's to get data about the current user. And then you can also have a path /users/{user_id} to get data about a specific user by some user ID. Because path operations are evaluated in order, you need to make sure that the path for /users/me is declared before the one for /users/{user_id} : from fastapi import FastAPI app = FastAPI () @app . get ( \"/users/me\" ) async def read_user_me (): return { \"user_id\" : \"the current user\" } @app . get ( \"/users/ {user_id} \" ) async def read_user ( user_id : str ): return { \"user_id\" : user_id } Otherwise, the path for /users/{user_id} would match also for /users/me , \"thinking\" that it's receiving a parameter user_id with a value of \"me\" .","title":"Order matters"},{"location":"tutorial/path-params/#predefined-values","text":"If you have a path operation that receives a path parameter , but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum .","title":"Predefined values"},{"location":"tutorial/path-params/#create-an-enum-class","text":"Import Enum and create a sub-class that inherits from str and from Enum . By inheriting from str the API docs will be able to know that the values must be of type string and will be able to render correctly. And create class attributes with fixed values, those fixed values will be the available valid values: from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Info Enumerations (or enums) are available in Python since version 3.4. Tip If you are wondering, \"AlexNet\", \"ResNet\", and \"LeNet\" are just names of Machine Learning models .","title":"Create an Enum class"},{"location":"tutorial/path-params/#declare-a-path-parameter","text":"Then create a path parameter with a type annotation using the enum class you created ( ModelName ): from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" }","title":"Declare a path parameter"},{"location":"tutorial/path-params/#check-the-docs","text":"Because the available values for the path parameter are specified, the interactive docs can show them nicely:","title":"Check the docs"},{"location":"tutorial/path-params/#working-with-python-enumerations","text":"The value of the path parameter will be an enumeration member .","title":"Working with Python enumerations"},{"location":"tutorial/path-params/#compare-enumeration-members","text":"You can compare it with the enumeration member in your created enum ModelName : from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" }","title":"Compare enumeration members"},{"location":"tutorial/path-params/#get-the-enumeration-value","text":"You can get the actual value (a str in this case) using model_name.value , or in general, your_enum_member.value : from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Tip You could also access the value \"lenet\" with ModelName.lenet.value .","title":"Get the enumeration value"},{"location":"tutorial/path-params/#return-enumeration-members","text":"You can return enum members from your path operation , even nested in a JSON body (e.g. a dict ). They will be converted to their corresponding values before returning them to the client: from enum import Enum from fastapi import FastAPI class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI () @app . get ( \"/model/ {model_name} \" ) async def get_model ( model_name : ModelName ): if model_name == ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" }","title":"Return enumeration members"},{"location":"tutorial/path-params/#path-parameters-containing-paths","text":"Let's say you have a path operation with a path /files/{file_path} . But you need file_path itself to contain a path , like home/johndoe/myfile.txt . So, the URL for that file would be something like: /files/home/johndoe/myfile.txt .","title":"Path parameters containing paths"},{"location":"tutorial/path-params/#openapi-support","text":"OpenAPI doesn't support a way to declare a path parameter to contain a path inside, as that could lead to scenarios that are difficult to test and define. Nevertheless, you can still do it in FastAPI , using one of the internal tools from Starlette. And the docs would still work, although not adding any documentation telling that the parameter should contain a path.","title":"OpenAPI support"},{"location":"tutorial/path-params/#path-convertor","text":"Using an option directly from Starlette you can declare a path parameter containing a path using a URL like: /files/{file_path:path} In this case, the name of the parameter is file_path , and the last part, :path , tells it that the parameter should match any path . So, you can use it with: from fastapi import FastAPI app = FastAPI () @app . get ( \"/files/{file_path:path}\" ) async def read_user_me ( file_path : str ): return { \"file_path\" : file_path } Tip You could need the parameter to contain /home/johndoe/myfile.txt , with a leading slash ( / ). In that case, the URL would be: /files//home/johndoe/myfile.txt , with a double slash ( // ) between files and home .","title":"Path convertor"},{"location":"tutorial/path-params/#recap","text":"With FastAPI , by using short, intuitive and standard Python type declarations, you get: Editor support: error checks, autocompletion, etc. Data \" parsing \" Data validation API annotation and automatic documentation And you only have to declare them once. That's probably the main visible advantage of FastAPI compared to alternative frameworks (apart from the raw performance).","title":"Recap"},{"location":"tutorial/query-params-str-validations/","text":"FastAPI allows you to declare additional information and validation for your parameters. Let's take this application as example: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = None ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results The query parameter q is of type str , and by default is None , so it is optional. Additional validation \u00b6 We are going to enforce that even though q is optional, whenever it is provided, it doesn't exceed a length of 50 characters . Import Query \u00b6 To achieve that, first import Query from fastapi : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Use Query as the default value \u00b6 And now use it as the default value of your parameter, setting the parameter max_length to 50: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results As we have to replace the default value None with Query(None) , the first parameter to Query serves the same purpose of defining that default value. So: q : str = Query ( None ) ...makes the parameter optional, the same as: q : str = None But it declares it explicitly as being a query parameter. And then, we can pass more parameters to Query . In this case, the max_length parameter that applies to strings: q : str = Query ( None , max_length = 50 ) This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema path operation . Add more validations \u00b6 You can also add a parameter min_length : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , min_length = 3 , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Add regular expressions \u00b6 You can define a regular expression that the parameter should match: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , min_length = 3 , max_length = 50 , regex = \"^fixedquery$\" ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results This specific regular expression checks that the received parameter value: ^ : starts with the following characters, doesn't have characters before. fixedquery : has the exact value fixedquery . $ : ends there, doesn't have any more characters after fixedquery . If you feel lost with all these \"regular expression\" ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet. But whenever you need them and go and learn them, know that you can already use them directly in FastAPI . Default values \u00b6 The same way that you can pass None as the first argument to be used as the default value, you can pass other values. Let's say that you want to declare the q query parameter to have a min_length of 3 , and to have a default value of \"fixedquery\" : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( \"fixedquery\" , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Note Having a default value also makes the parameter optional. Make it required \u00b6 When we don't need to declare more validations or metadata, we can make the q query parameter required just by not declaring a default value, like: q : str instead of: q : str = None But we are now declaring it with Query , for example like: q : str = Query ( None , min_length = 3 ) So, when you need to declare a value as required while using Query , you can use ... as the first argument: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( ... , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . This will let FastAPI know that this parameter is required. Query parameter list / multiple values \u00b6 When you define a query parameter explicitly with Query you can also declare it to receive a list of values, or said in other way, to receive multiple values. For example, to declare a query parameter q that can appear multiple times in the URL, you can write: from typing import List from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : List [ str ] = Query ( None )): query_items = { \"q\" : q } return query_items Then, with a URL like: http://localhost:8000/items/?q=foo&q=bar you would receive the multiple q query parameters' values ( foo and bar ) in a Python list inside your path operation function , in the function parameter q . So, the response to that URL would be: { \"q\" : [ \"foo\" , \"bar\" ] } Tip To declare a query parameter with a type of list , like in the example above, you need to explicitly use Query , otherwise it would be interpreted as a request body. The interactive API docs will update accordingly, to allow multiple values: Query parameter list / multiple values with defaults \u00b6 And you can also define a default list of values if none are provided: from typing import List from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : List [ str ] = Query ([ \"foo\" , \"bar\" ])): query_items = { \"q\" : q } return query_items If you go to: http://localhost:8000/items/ the default of q will be: [\"foo\", \"bar\"] and your response will be: { \"q\" : [ \"foo\" , \"bar\" ] } Using list \u00b6 You can also use list directly instead of List[str] : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : list = Query ( None )): query_items = { \"q\" : q } return query_items Note Have in mind that in this case, FastAPI won't check the contents of the list. For example, List[int] would check (and document) that the contents of the list are integers. But list alone wouldn't. Declare more metadata \u00b6 You can add more information about the parameter. That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools. Note Have in mind that different tools might have different levels of OpenAPI support. Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development. You can add a title : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , title = \"Query string\" , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results And a description : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , title = \"Query string\" , description = \"Query string for the items to search in the database that have a good match\" , min_length = 3 , ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Alias parameters \u00b6 Imagine that you want the parameter to be item-query . Like in: http://127.0.0.1:8000/items/?item-query=foobaritems But item-query is not a valid Python variable name. The closest would be item_query . But you still need it to be exactly item-query ... Then you can declare an alias , and that alias is what will be used to find the parameter value: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , alias = \"item-query\" )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Deprecating parameters \u00b6 Now let's say you don't like this parameter anymore. You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated . Then pass the parameter deprecated=True to Query : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , alias = \"item-query\" , title = \"Query string\" , description = \"Query string for the items to search in the database that have a good match\" , min_length = 3 , max_length = 50 , regex = \"^fixedquery$\" , deprecated = True , ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results The docs will show it like this: Recap \u00b6 You can declare additional validations and metadata for your parameters. Generic validations and metadata: alias title description deprecated Validations specific for strings: min_length max_length regex In these examples you saw how to declare validations for str values. See the next chapters to see how to declare validations for other types, like numbers.","title":"Query Parameters and String Validations"},{"location":"tutorial/query-params-str-validations/#additional-validation","text":"We are going to enforce that even though q is optional, whenever it is provided, it doesn't exceed a length of 50 characters .","title":"Additional validation"},{"location":"tutorial/query-params-str-validations/#import-query","text":"To achieve that, first import Query from fastapi : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results","title":"Import Query"},{"location":"tutorial/query-params-str-validations/#use-query-as-the-default-value","text":"And now use it as the default value of your parameter, setting the parameter max_length to 50: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results As we have to replace the default value None with Query(None) , the first parameter to Query serves the same purpose of defining that default value. So: q : str = Query ( None ) ...makes the parameter optional, the same as: q : str = None But it declares it explicitly as being a query parameter. And then, we can pass more parameters to Query . In this case, the max_length parameter that applies to strings: q : str = Query ( None , max_length = 50 ) This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema path operation .","title":"Use Query as the default value"},{"location":"tutorial/query-params-str-validations/#add-more-validations","text":"You can also add a parameter min_length : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , min_length = 3 , max_length = 50 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results","title":"Add more validations"},{"location":"tutorial/query-params-str-validations/#add-regular-expressions","text":"You can define a regular expression that the parameter should match: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , min_length = 3 , max_length = 50 , regex = \"^fixedquery$\" ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results This specific regular expression checks that the received parameter value: ^ : starts with the following characters, doesn't have characters before. fixedquery : has the exact value fixedquery . $ : ends there, doesn't have any more characters after fixedquery . If you feel lost with all these \"regular expression\" ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet. But whenever you need them and go and learn them, know that you can already use them directly in FastAPI .","title":"Add regular expressions"},{"location":"tutorial/query-params-str-validations/#default-values","text":"The same way that you can pass None as the first argument to be used as the default value, you can pass other values. Let's say that you want to declare the q query parameter to have a min_length of 3 , and to have a default value of \"fixedquery\" : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( \"fixedquery\" , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Note Having a default value also makes the parameter optional.","title":"Default values"},{"location":"tutorial/query-params-str-validations/#make-it-required","text":"When we don't need to declare more validations or metadata, we can make the q query parameter required just by not declaring a default value, like: q : str instead of: q : str = None But we are now declaring it with Query , for example like: q : str = Query ( None , min_length = 3 ) So, when you need to declare a value as required while using Query , you can use ... as the first argument: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( ... , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . This will let FastAPI know that this parameter is required.","title":"Make it required"},{"location":"tutorial/query-params-str-validations/#query-parameter-list-multiple-values","text":"When you define a query parameter explicitly with Query you can also declare it to receive a list of values, or said in other way, to receive multiple values. For example, to declare a query parameter q that can appear multiple times in the URL, you can write: from typing import List from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : List [ str ] = Query ( None )): query_items = { \"q\" : q } return query_items Then, with a URL like: http://localhost:8000/items/?q=foo&q=bar you would receive the multiple q query parameters' values ( foo and bar ) in a Python list inside your path operation function , in the function parameter q . So, the response to that URL would be: { \"q\" : [ \"foo\" , \"bar\" ] } Tip To declare a query parameter with a type of list , like in the example above, you need to explicitly use Query , otherwise it would be interpreted as a request body. The interactive API docs will update accordingly, to allow multiple values:","title":"Query parameter list / multiple values"},{"location":"tutorial/query-params-str-validations/#query-parameter-list-multiple-values-with-defaults","text":"And you can also define a default list of values if none are provided: from typing import List from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : List [ str ] = Query ([ \"foo\" , \"bar\" ])): query_items = { \"q\" : q } return query_items If you go to: http://localhost:8000/items/ the default of q will be: [\"foo\", \"bar\"] and your response will be: { \"q\" : [ \"foo\" , \"bar\" ] }","title":"Query parameter list / multiple values with defaults"},{"location":"tutorial/query-params-str-validations/#using-list","text":"You can also use list directly instead of List[str] : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : list = Query ( None )): query_items = { \"q\" : q } return query_items Note Have in mind that in this case, FastAPI won't check the contents of the list. For example, List[int] would check (and document) that the contents of the list are integers. But list alone wouldn't.","title":"Using list"},{"location":"tutorial/query-params-str-validations/#declare-more-metadata","text":"You can add more information about the parameter. That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools. Note Have in mind that different tools might have different levels of OpenAPI support. Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development. You can add a title : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , title = \"Query string\" , min_length = 3 )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results And a description : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , title = \"Query string\" , description = \"Query string for the items to search in the database that have a good match\" , min_length = 3 , ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results","title":"Declare more metadata"},{"location":"tutorial/query-params-str-validations/#alias-parameters","text":"Imagine that you want the parameter to be item-query . Like in: http://127.0.0.1:8000/items/?item-query=foobaritems But item-query is not a valid Python variable name. The closest would be item_query . But you still need it to be exactly item-query ... Then you can declare an alias , and that alias is what will be used to find the parameter value: from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , alias = \"item-query\" )): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results","title":"Alias parameters"},{"location":"tutorial/query-params-str-validations/#deprecating-parameters","text":"Now let's say you don't like this parameter anymore. You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated . Then pass the parameter deprecated=True to Query : from fastapi import FastAPI , Query app = FastAPI () @app . get ( \"/items/\" ) async def read_items ( q : str = Query ( None , alias = \"item-query\" , title = \"Query string\" , description = \"Query string for the items to search in the database that have a good match\" , min_length = 3 , max_length = 50 , regex = \"^fixedquery$\" , deprecated = True , ) ): results = { \"items\" : [{ \"item_id\" : \"Foo\" }, { \"item_id\" : \"Bar\" }]} if q : results . update ({ \"q\" : q }) return results The docs will show it like this:","title":"Deprecating parameters"},{"location":"tutorial/query-params-str-validations/#recap","text":"You can declare additional validations and metadata for your parameters. Generic validations and metadata: alias title description deprecated Validations specific for strings: min_length max_length regex In these examples you saw how to declare validations for str values. See the next chapters to see how to declare validations for other types, like numbers.","title":"Recap"},{"location":"tutorial/query-params/","text":"When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. from fastapi import FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @app . get ( \"/items/\" ) async def read_item ( skip : int = 0 , limit : int = 10 ): return fake_items_db [ skip : skip + limit ] The query is the set of key-value pairs that go after the ? in a URL, separated by & characters. For example, in the url: http://127.0.0.1:8000/items/?skip=0&limit=10 ...the query parameters are: skip : with a value of 0 limit : with a value of 10 As they are part of the URL, they are \"naturally\" strings. But when you declare them with Python types (in the example above, as int ), they are converted to that type and validated against it. All the same process that applied for path parameters also applies for query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Defaults \u00b6 As query parameters are not a fixed part of a path, they can be optional and can have default values. In the example above they have default values of skip=0 and limit=10 . So, going to the URL: http://127.0.0.1:8000/items/ would be the same as going to: http://127.0.0.1:8000/items/?skip=0&limit=10 But if you go to, for example: http://127.0.0.1:8000/items/?skip=20 The parameter values in your function will be: skip=20 : because you set it in the URL limit=10 : because that was the default value Optional parameters \u00b6 The same way, you can declare optional query parameters, by setting their default to None : from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str , q : str = None ): if q : return { \"item_id\" : item_id , \"q\" : q } return { \"item_id\" : item_id } In this case, the function parameter q will be optional, and will be None by default. Check Also notice that FastAPI is smart enough to notice that the path parameter item_id is a path parameter and q is not, so, it's a query parameter. Query parameter type conversion \u00b6 You can also declare bool types, and they will be converted: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str , q : str = None , short : bool = False ): item = { \"item_id\" : item_id } if q : item . update ({ \"q\" : q }) if not short : item . update ( { \"description\" : \"This is an amazing item that has a long description\" } ) return item In this case, if you go to: http://127.0.0.1:8000/items/foo?short=1 or http://127.0.0.1:8000/items/foo?short=True or http://127.0.0.1:8000/items/foo?short=true or http://127.0.0.1:8000/items/foo?short=on or http://127.0.0.1:8000/items/foo?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter short with a bool value of True . Otherwise as False . Multiple path and query parameters \u00b6 You can declare multiple path parameters and query parameters at the same time, FastAPI knows which is which. And you don't have to declare them in any specific order. They will be detected by name: from fastapi import FastAPI app = FastAPI () @app . get ( \"/users/ {user_id} /items/ {item_id} \" ) async def read_user_item ( user_id : int , item_id : str , q : str = None , short : bool = False ): item = { \"item_id\" : item_id , \"owner_id\" : user_id } if q : item . update ({ \"q\" : q }) if not short : item . update ( { \"description\" : \"This is an amazing item that has a long description\" } ) return item Required query parameters \u00b6 When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as None . But when you want to make a query parameter required, you can just not declare any default value: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , needy : str ): item = { \"item_id\" : item_id , \"needy\" : needy } return item Here the query parameter needy is a required query parameter of type str . If you open in your browser a URL like: http://127.0.0.1:8000/items/foo-item ...without adding the required parameter needy , you will see an error like: { \"detail\" : [ { \"loc\" : [ \"query\" , \"needy\" ], \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] } As needy is a required parameter, you would need to set it in the URL: http://127.0.0.1:8000/items/foo-item?needy=sooooneedy ...this would work: { \"item_id\" : \"foo-item\" , \"needy\" : \"sooooneedy\" } And of course, you can define some parameters as required, some as having a default value, and some entirely optional: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , needy : str , skip : int = 0 , limit : int = None ): item = { \"item_id\" : item_id , \"needy\" : needy , \"skip\" : skip , \"limit\" : limit } return item In this case, there are 3 query parameters: needy , a required str . skip , an int with a default value of 0 . limit , an optional int . Tip You could also use Enum s the same way as with Path Parameters . Optional type declarations \u00b6 Warning This might be an advanced use case. You might want to skip it. If you are using mypy it could complain with type declarations like: limit : int = None With an error like: Incompatible types in assignment (expression has type \"None\", variable has type \"int\") In those cases you can use Optional to tell mypy that the value could be None , like: from typing import Optional limit : Optional [ int ] = None In a path operation that could look like: from typing import Optional from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , limit : Optional [ int ] = None ): item = { \"item_id\" : item_id , \"limit\" : limit } return item","title":"Query Parameters"},{"location":"tutorial/query-params/#defaults","text":"As query parameters are not a fixed part of a path, they can be optional and can have default values. In the example above they have default values of skip=0 and limit=10 . So, going to the URL: http://127.0.0.1:8000/items/ would be the same as going to: http://127.0.0.1:8000/items/?skip=0&limit=10 But if you go to, for example: http://127.0.0.1:8000/items/?skip=20 The parameter values in your function will be: skip=20 : because you set it in the URL limit=10 : because that was the default value","title":"Defaults"},{"location":"tutorial/query-params/#optional-parameters","text":"The same way, you can declare optional query parameters, by setting their default to None : from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str , q : str = None ): if q : return { \"item_id\" : item_id , \"q\" : q } return { \"item_id\" : item_id } In this case, the function parameter q will be optional, and will be None by default. Check Also notice that FastAPI is smart enough to notice that the path parameter item_id is a path parameter and q is not, so, it's a query parameter.","title":"Optional parameters"},{"location":"tutorial/query-params/#query-parameter-type-conversion","text":"You can also declare bool types, and they will be converted: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_item ( item_id : str , q : str = None , short : bool = False ): item = { \"item_id\" : item_id } if q : item . update ({ \"q\" : q }) if not short : item . update ( { \"description\" : \"This is an amazing item that has a long description\" } ) return item In this case, if you go to: http://127.0.0.1:8000/items/foo?short=1 or http://127.0.0.1:8000/items/foo?short=True or http://127.0.0.1:8000/items/foo?short=true or http://127.0.0.1:8000/items/foo?short=on or http://127.0.0.1:8000/items/foo?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter short with a bool value of True . Otherwise as False .","title":"Query parameter type conversion"},{"location":"tutorial/query-params/#multiple-path-and-query-parameters","text":"You can declare multiple path parameters and query parameters at the same time, FastAPI knows which is which. And you don't have to declare them in any specific order. They will be detected by name: from fastapi import FastAPI app = FastAPI () @app . get ( \"/users/ {user_id} /items/ {item_id} \" ) async def read_user_item ( user_id : int , item_id : str , q : str = None , short : bool = False ): item = { \"item_id\" : item_id , \"owner_id\" : user_id } if q : item . update ({ \"q\" : q }) if not short : item . update ( { \"description\" : \"This is an amazing item that has a long description\" } ) return item","title":"Multiple path and query parameters"},{"location":"tutorial/query-params/#required-query-parameters","text":"When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as None . But when you want to make a query parameter required, you can just not declare any default value: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , needy : str ): item = { \"item_id\" : item_id , \"needy\" : needy } return item Here the query parameter needy is a required query parameter of type str . If you open in your browser a URL like: http://127.0.0.1:8000/items/foo-item ...without adding the required parameter needy , you will see an error like: { \"detail\" : [ { \"loc\" : [ \"query\" , \"needy\" ], \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] } As needy is a required parameter, you would need to set it in the URL: http://127.0.0.1:8000/items/foo-item?needy=sooooneedy ...this would work: { \"item_id\" : \"foo-item\" , \"needy\" : \"sooooneedy\" } And of course, you can define some parameters as required, some as having a default value, and some entirely optional: from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , needy : str , skip : int = 0 , limit : int = None ): item = { \"item_id\" : item_id , \"needy\" : needy , \"skip\" : skip , \"limit\" : limit } return item In this case, there are 3 query parameters: needy , a required str . skip , an int with a default value of 0 . limit , an optional int . Tip You could also use Enum s the same way as with Path Parameters .","title":"Required query parameters"},{"location":"tutorial/query-params/#optional-type-declarations","text":"Warning This might be an advanced use case. You might want to skip it. If you are using mypy it could complain with type declarations like: limit : int = None With an error like: Incompatible types in assignment (expression has type \"None\", variable has type \"int\") In those cases you can use Optional to tell mypy that the value could be None , like: from typing import Optional limit : Optional [ int ] = None In a path operation that could look like: from typing import Optional from fastapi import FastAPI app = FastAPI () @app . get ( \"/items/ {item_id} \" ) async def read_user_item ( item_id : str , limit : Optional [ int ] = None ): item = { \"item_id\" : item_id , \"limit\" : limit } return item","title":"Optional type declarations"},{"location":"tutorial/request-files/","text":"You can define files to be uploaded by the client using File . Info To receive uploaded files, first install python-multipart . E.g. pip install python-multipart . This is because uploaded files are sent as \"form data\". Import File \u00b6 Import File and UploadFile from fastapi : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename } Define File parameters \u00b6 Create file parameters the same way you would for Body or Form : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename } Info File is a class that inherits directly from Form . But remember that when you import Query , Path , File and others from fastapi , those are actually functions that return special classes. Tip To declare File bodies, you need to use File , because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters. The files will be uploaded as \"form data\". If you declare the type of your path operation function parameter as bytes , FastAPI will read the file for you and you will receive the contents as bytes . Have in mind that this means that the whole contents will be stored in memory. This will work well for small files. But there are several cases in where you might benefit from using UploadFile . File parameters with UploadFile \u00b6 Define a File parameter with a type of UploadFile : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename } Using UploadFile has several advantages over bytes : It uses a \"spooled\" file: A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk. This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory. You can get metadata from the uploaded file. It has a file-like async interface. It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object. UploadFile \u00b6 UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). write(data) : Writes data ( str or bytes ) to the file. read(size) : Reads size ( int ) bytes/characters of the file. seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. This is especially useful if you run await myfile.read() once and then need to read the contents again. close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, inside of an async path operation function you can get the contents with: contents = await myfile . read () If you are inside of a normal def path operation function , you can access the UploadFile.file directly, for example: contents = myfile . file . read () async Technical Details When you use the async methods, FastAPI runs the file methods in a threadpool and awaits for them. Starlette Technical Details FastAPI 's UploadFile inherits directly from Starlette 's UploadFile , but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI. What is \"Form Data\" \u00b6 The way HTML forms ( <form></form> ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded when it doesn't include files. But when the form includes files, it is encoded as multipart/form-data . If you use File , FastAPI will know it has to get the files from the correct part of the body. If you want to read more about these encodings and form fields, head to the MDN web docs for POST . Warning You can declare multiple File and Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol. Multiple file uploads \u00b6 It's possible to upload several files at the same time. They would be associated to the same \"form field\" sent using \"form data\". To use that, declare a List of bytes or UploadFile : from typing import List from fastapi import FastAPI , File , UploadFile from starlette.responses import HTMLResponse app = FastAPI () @app . post ( \"/files/\" ) async def create_files ( files : List [ bytes ] = File ( ... )): return { \"file_sizes\" : [ len ( file ) for file in files ]} @app . post ( \"/uploadfiles/\" ) async def create_upload_files ( files : List [ UploadFile ] = File ( ... )): return { \"filenames\" : [ file . filename for file in files ]} @app . get ( \"/\" ) async def main (): content = \"\"\" <body> <form action=\"/files/\" enctype=\"multipart/form-data\" method=\"post\"> <input name=\"files\" type=\"file\" multiple> <input type=\"submit\"> </form> <form action=\"/uploadfiles/\" enctype=\"multipart/form-data\" method=\"post\"> <input name=\"files\" type=\"file\" multiple> <input type=\"submit\"> </form> </body> \"\"\" return HTMLResponse ( content = content ) You will receive, as declared, a list of bytes or UploadFile s. Note Notice that, as of 2019-04-14, Swagger UI doesn't support multiple file uploads in the same form field. For more information, check #4276 and #3641 . Nevertheless, FastAPI is already compatible with it, using the standard OpenAPI. So, whenever Swagger UI supports multi-file uploads, or any other tools that supports OpenAPI, they will be compatible with FastAPI . Recap \u00b6 Use File to declare files to be uploaded as input parameters (as form data).","title":"Request Files"},{"location":"tutorial/request-files/#import-file","text":"Import File and UploadFile from fastapi : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename }","title":"Import File"},{"location":"tutorial/request-files/#define-file-parameters","text":"Create file parameters the same way you would for Body or Form : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename } Info File is a class that inherits directly from Form . But remember that when you import Query , Path , File and others from fastapi , those are actually functions that return special classes. Tip To declare File bodies, you need to use File , because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters. The files will be uploaded as \"form data\". If you declare the type of your path operation function parameter as bytes , FastAPI will read the file for you and you will receive the contents as bytes . Have in mind that this means that the whole contents will be stored in memory. This will work well for small files. But there are several cases in where you might benefit from using UploadFile .","title":"Define File parameters"},{"location":"tutorial/request-files/#file-parameters-with-uploadfile","text":"Define a File parameter with a type of UploadFile : from fastapi import FastAPI , File , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... )): return { \"file_size\" : len ( file )} @app . post ( \"/uploadfile/\" ) async def create_upload_file ( file : UploadFile = File ( ... )): return { \"filename\" : file . filename } Using UploadFile has several advantages over bytes : It uses a \"spooled\" file: A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk. This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory. You can get metadata from the uploaded file. It has a file-like async interface. It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object.","title":"File parameters with UploadFile"},{"location":"tutorial/request-files/#uploadfile","text":"UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). write(data) : Writes data ( str or bytes ) to the file. read(size) : Reads size ( int ) bytes/characters of the file. seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. This is especially useful if you run await myfile.read() once and then need to read the contents again. close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, inside of an async path operation function you can get the contents with: contents = await myfile . read () If you are inside of a normal def path operation function , you can access the UploadFile.file directly, for example: contents = myfile . file . read () async Technical Details When you use the async methods, FastAPI runs the file methods in a threadpool and awaits for them. Starlette Technical Details FastAPI 's UploadFile inherits directly from Starlette 's UploadFile , but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI.","title":"UploadFile"},{"location":"tutorial/request-files/#what-is-form-data","text":"The way HTML forms ( <form></form> ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded when it doesn't include files. But when the form includes files, it is encoded as multipart/form-data . If you use File , FastAPI will know it has to get the files from the correct part of the body. If you want to read more about these encodings and form fields, head to the MDN web docs for POST . Warning You can declare multiple File and Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol.","title":"What is \"Form Data\""},{"location":"tutorial/request-files/#multiple-file-uploads","text":"It's possible to upload several files at the same time. They would be associated to the same \"form field\" sent using \"form data\". To use that, declare a List of bytes or UploadFile : from typing import List from fastapi import FastAPI , File , UploadFile from starlette.responses import HTMLResponse app = FastAPI () @app . post ( \"/files/\" ) async def create_files ( files : List [ bytes ] = File ( ... )): return { \"file_sizes\" : [ len ( file ) for file in files ]} @app . post ( \"/uploadfiles/\" ) async def create_upload_files ( files : List [ UploadFile ] = File ( ... )): return { \"filenames\" : [ file . filename for file in files ]} @app . get ( \"/\" ) async def main (): content = \"\"\" <body> <form action=\"/files/\" enctype=\"multipart/form-data\" method=\"post\"> <input name=\"files\" type=\"file\" multiple> <input type=\"submit\"> </form> <form action=\"/uploadfiles/\" enctype=\"multipart/form-data\" method=\"post\"> <input name=\"files\" type=\"file\" multiple> <input type=\"submit\"> </form> </body> \"\"\" return HTMLResponse ( content = content ) You will receive, as declared, a list of bytes or UploadFile s. Note Notice that, as of 2019-04-14, Swagger UI doesn't support multiple file uploads in the same form field. For more information, check #4276 and #3641 . Nevertheless, FastAPI is already compatible with it, using the standard OpenAPI. So, whenever Swagger UI supports multi-file uploads, or any other tools that supports OpenAPI, they will be compatible with FastAPI .","title":"Multiple file uploads"},{"location":"tutorial/request-files/#recap","text":"Use File to declare files to be uploaded as input parameters (as form data).","title":"Recap"},{"location":"tutorial/request-forms-and-files/","text":"You can define files and form fields at the same time using File and Form . Info To receive uploaded files and/or form data, first install python-multipart . E.g. pip install python-multipart . Import File and Form \u00b6 from fastapi import FastAPI , File , Form , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... ), fileb : UploadFile = File ( ... ), token : str = Form ( ... ) ): return { \"file_size\" : len ( file ), \"token\" : token , \"fileb_content_type\" : fileb . content_type , } Define File and Form parameters \u00b6 Create file and form parameters the same way you would for Body or Query : from fastapi import FastAPI , File , Form , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... ), fileb : UploadFile = File ( ... ), token : str = Form ( ... ) ): return { \"file_size\" : len ( file ), \"token\" : token , \"fileb_content_type\" : fileb . content_type , } The files and form fields will be uploaded as form data and you will receive the files and form fields. And you can declare some of the files as bytes and some as UploadFile . Warning You can declare multiple File and Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol. Recap \u00b6 Use File and Form together when you need to receive data and files in the same request.","title":"Request Forms and Files"},{"location":"tutorial/request-forms-and-files/#import-file-and-form","text":"from fastapi import FastAPI , File , Form , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... ), fileb : UploadFile = File ( ... ), token : str = Form ( ... ) ): return { \"file_size\" : len ( file ), \"token\" : token , \"fileb_content_type\" : fileb . content_type , }","title":"Import File and Form"},{"location":"tutorial/request-forms-and-files/#define-file-and-form-parameters","text":"Create file and form parameters the same way you would for Body or Query : from fastapi import FastAPI , File , Form , UploadFile app = FastAPI () @app . post ( \"/files/\" ) async def create_file ( file : bytes = File ( ... ), fileb : UploadFile = File ( ... ), token : str = Form ( ... ) ): return { \"file_size\" : len ( file ), \"token\" : token , \"fileb_content_type\" : fileb . content_type , } The files and form fields will be uploaded as form data and you will receive the files and form fields. And you can declare some of the files as bytes and some as UploadFile . Warning You can declare multiple File and Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol.","title":"Define File and Form parameters"},{"location":"tutorial/request-forms-and-files/#recap","text":"Use File and Form together when you need to receive data and files in the same request.","title":"Recap"},{"location":"tutorial/request-forms/","text":"When you need to receive form fields instead of JSON, you can use Form . Info To use forms, first install python-multipart . E.g. pip install python-multipart . Import Form \u00b6 Import Form from fastapi : from fastapi import FastAPI , Form app = FastAPI () @app . post ( \"/login/\" ) async def login ( * , username : str = Form ( ... ), password : str = Form ( ... )): return { \"username\" : username } Define Form parameters \u00b6 Create form parameters the same way you would for Body or Query : from fastapi import FastAPI , Form app = FastAPI () @app . post ( \"/login/\" ) async def login ( * , username : str = Form ( ... ), password : str = Form ( ... )): return { \"username\" : username } For example, in one of the ways the OAuth2 specification can be used (called \"password flow\") it is required to send a username and password as form fields. The spec requires the fields to be exactly named username and password , and to be sent as form fields, not JSON. With Form you can declare the same metadata and validation as with Body (and Query , Path , Cookie ). Info Form is a class that inherits directly from Body . Tip To declare form bodies, you need to use Form explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters. About \"Form Fields\" \u00b6 The way HTML forms ( <form></form> ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded . But when the form includes files, it is encoded as multipart/form-data . You'll read about handling files in the next chapter. If you want to read more about these encodings and form fields, head to the MDN web docs for POST . Warning You can declare multiple Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using application/x-www-form-urlencoded instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol. Recap \u00b6 Use Form to declare form data input parameters.","title":"Form Data"},{"location":"tutorial/request-forms/#import-form","text":"Import Form from fastapi : from fastapi import FastAPI , Form app = FastAPI () @app . post ( \"/login/\" ) async def login ( * , username : str = Form ( ... ), password : str = Form ( ... )): return { \"username\" : username }","title":"Import Form"},{"location":"tutorial/request-forms/#define-form-parameters","text":"Create form parameters the same way you would for Body or Query : from fastapi import FastAPI , Form app = FastAPI () @app . post ( \"/login/\" ) async def login ( * , username : str = Form ( ... ), password : str = Form ( ... )): return { \"username\" : username } For example, in one of the ways the OAuth2 specification can be used (called \"password flow\") it is required to send a username and password as form fields. The spec requires the fields to be exactly named username and password , and to be sent as form fields, not JSON. With Form you can declare the same metadata and validation as with Body (and Query , Path , Cookie ). Info Form is a class that inherits directly from Body . Tip To declare form bodies, you need to use Form explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.","title":"Define Form parameters"},{"location":"tutorial/request-forms/#about-form-fields","text":"The way HTML forms ( <form></form> ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded . But when the form includes files, it is encoded as multipart/form-data . You'll read about handling files in the next chapter. If you want to read more about these encodings and form fields, head to the MDN web docs for POST . Warning You can declare multiple Form parameters in a path operation , but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using application/x-www-form-urlencoded instead of application/json . This is not a limitation of FastAPI , it's part of the HTTP protocol.","title":"About \"Form Fields\""},{"location":"tutorial/request-forms/#recap","text":"Use Form to declare form data input parameters.","title":"Recap"},{"location":"tutorial/response-model/","text":"You can declare the model used for the response with the parameter response_model in any of the path operations : @app.get() @app.post() @app.put() @app.delete() etc. from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = None tags : List [ str ] = [] @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): return item Note Notice that response_model is a parameter of the \"decorator\" method ( get , post , etc). Not of your path operation function , like all the parameters and body. It receives the same type you would declare for a Pydantic model attribute, so, it can be a Pydantic model, but it can also be, e.g. a list of Pydantic models, like List[Item] . FastAPI will use this response_model to: Convert the output data to its type declaration. Validate the data. Add a JSON Schema for the response, in the OpenAPI path operation . Will be used by the automatic documentation systems. But most importantly: Will limit the output data to that of the model. We'll see how that's important below. Technical Details The response model is declared in this parameter instead of as a function return type annotation, because the path function may not actually return that response model but rather return a dict , database object or some other model, and then use the response_model to perform the field limiting and serialization. Return the same input data \u00b6 Here we are declaring a UserIn model, it will contain a plaintext password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None # Don't do this in production! @app . post ( \"/user/\" , response_model = UserIn ) async def create_user ( * , user : UserIn ): return user And we are using this model to declare our input and the same model to declare our output: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None # Don't do this in production! @app . post ( \"/user/\" , response_model = UserIn ) async def create_user ( * , user : UserIn ): return user Now, whenever a browser is creating a user with a password, the API will return the same password in the response. In this case, it might not be a problem, because the user himself is sending the password. But if we use the same model for another path operation , we could be sending our user's passwords to every client. Danger Never send the plain password of a user in a response. Add an output model \u00b6 We can instead create an input model with the plaintext password and an output model without it: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user Here, even though our path operation function is returning the same input user that contains the password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user ...we declared the response_model to be our model UserOut , that doesn't include the password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user So, FastAPI will take care of filtering out all the data that is not declared in the output model (using Pydantic). See it in the docs \u00b6 When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema: And both models will be used for the interactive API documentation: Response Model encoding parameters \u00b6 Your response model could have default values, like: from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item , response_model_exclude_unset = True ) async def read_item ( item_id : str ): return items [ item_id ] description: str = None has a default of None . tax: float = 10.5 has a default of 10.5 . tags: List[str] = [] has a default of an empty list: [] . but you might want to omit them from the result if they were not actually stored. For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values. Use the response_model_exclude_unset parameter \u00b6 You can set the path operation decorator parameter response_model_exclude_unset=True : from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item , response_model_exclude_unset = True ) async def read_item ( item_id : str ): return items [ item_id ] and those default values won't be included in the response, only the values actually set. So, if you send a request to that path operation for the item with ID foo , the response (not including default values) will be: { \"name\" : \"Foo\" , \"price\" : 50.2 } Info FastAPI uses Pydantic model's .dict() with its exclude_unset parameter to achieve this. Data with values for fields with defaults \u00b6 But if your data has values for the model's fields with default values, like the item with ID bar : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 } they will be included in the response. Data with the same values as the defaults \u00b6 If the data has the same values as the default ones, like the item with ID baz : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : [] } FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though description , tax , and tags have the same values as the defaults, they were set explicitly (instead of taken from the defaults). So, they will be included in the JSON response. Tip Notice that the default values can be anything, not only None . They can be a list ( [] ), a float of 10.5 , etc. response_model_include and response_model_exclude \u00b6 You can also use the path operation decorator parameters response_model_include and response_model_exclude . They take a set of str with the name of the attributes to include (omitting the rest) or to exclude (including the rest). This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output. Tip But it is still recommended to use the ideas above, using multiple classes, instead of these parameters. This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use response_model_include or response_model_exclude to omit some attributes. from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The Bar fighters\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : \"There goes my baz\" , \"price\" : 50.2 , \"tax\" : 10.5 , }, } @app . get ( \"/items/ {item_id} /name\" , response_model = Item , response_model_include = { \"name\" , \"description\" }, ) async def read_item_name ( item_id : str ): return items [ item_id ] @app . get ( \"/items/ {item_id} /public\" , response_model = Item , response_model_exclude = { \"tax\" }) async def read_item_public_data ( item_id : str ): return items [ item_id ] Tip The syntax {\"name\", \"description\"} creates a set with those two values. It is equivalent to set([\"name\", \"description\"]) . Using list s instead of set s \u00b6 If you forget to use a set and use a list or tuple instead, FastAPI will still convert it to a set and it will work correctly: from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The Bar fighters\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : \"There goes my baz\" , \"price\" : 50.2 , \"tax\" : 10.5 , }, } @app . get ( \"/items/ {item_id} /name\" , response_model = Item , response_model_include = [ \"name\" , \"description\" ], ) async def read_item_name ( item_id : str ): return items [ item_id ] @app . get ( \"/items/ {item_id} /public\" , response_model = Item , response_model_exclude = [ \"tax\" ]) async def read_item_public_data ( item_id : str ): return items [ item_id ] Recap \u00b6 Use the path operation decorator's parameter response_model to define response models and especially to ensure private data is filtered out. Use response_model_exclude_unset to return only the values explicitly set.","title":"Response Model"},{"location":"tutorial/response-model/#return-the-same-input-data","text":"Here we are declaring a UserIn model, it will contain a plaintext password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None # Don't do this in production! @app . post ( \"/user/\" , response_model = UserIn ) async def create_user ( * , user : UserIn ): return user And we are using this model to declare our input and the same model to declare our output: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None # Don't do this in production! @app . post ( \"/user/\" , response_model = UserIn ) async def create_user ( * , user : UserIn ): return user Now, whenever a browser is creating a user with a password, the API will return the same password in the response. In this case, it might not be a problem, because the user himself is sending the password. But if we use the same model for another path operation , we could be sending our user's passwords to every client. Danger Never send the plain password of a user in a response.","title":"Return the same input data"},{"location":"tutorial/response-model/#add-an-output-model","text":"We can instead create an input model with the plaintext password and an output model without it: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user Here, even though our path operation function is returning the same input user that contains the password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user ...we declared the response_model to be our model UserOut , that doesn't include the password: from fastapi import FastAPI from pydantic import BaseModel , EmailStr app = FastAPI () class UserIn ( BaseModel ): username : str password : str email : EmailStr full_name : str = None class UserOut ( BaseModel ): username : str email : EmailStr full_name : str = None @app . post ( \"/user/\" , response_model = UserOut ) async def create_user ( * , user : UserIn ): return user So, FastAPI will take care of filtering out all the data that is not declared in the output model (using Pydantic).","title":"Add an output model"},{"location":"tutorial/response-model/#see-it-in-the-docs","text":"When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema: And both models will be used for the interactive API documentation:","title":"See it in the docs"},{"location":"tutorial/response-model/#response-model-encoding-parameters","text":"Your response model could have default values, like: from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item , response_model_exclude_unset = True ) async def read_item ( item_id : str ): return items [ item_id ] description: str = None has a default of None . tax: float = 10.5 has a default of 10.5 . tags: List[str] = [] has a default of an empty list: [] . but you might want to omit them from the result if they were not actually stored. For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.","title":"Response Model encoding parameters"},{"location":"tutorial/response-model/#use-the-response_model_exclude_unset-parameter","text":"You can set the path operation decorator parameter response_model_exclude_unset=True : from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 tags : List [ str ] = [] items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : []}, } @app . get ( \"/items/ {item_id} \" , response_model = Item , response_model_exclude_unset = True ) async def read_item ( item_id : str ): return items [ item_id ] and those default values won't be included in the response, only the values actually set. So, if you send a request to that path operation for the item with ID foo , the response (not including default values) will be: { \"name\" : \"Foo\" , \"price\" : 50.2 } Info FastAPI uses Pydantic model's .dict() with its exclude_unset parameter to achieve this.","title":"Use the response_model_exclude_unset parameter"},{"location":"tutorial/response-model/#data-with-values-for-fields-with-defaults","text":"But if your data has values for the model's fields with default values, like the item with ID bar : { \"name\" : \"Bar\" , \"description\" : \"The bartenders\" , \"price\" : 62 , \"tax\" : 20.2 } they will be included in the response.","title":"Data with values for fields with defaults"},{"location":"tutorial/response-model/#data-with-the-same-values-as-the-defaults","text":"If the data has the same values as the default ones, like the item with ID baz : { \"name\" : \"Baz\" , \"description\" : None , \"price\" : 50.2 , \"tax\" : 10.5 , \"tags\" : [] } FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though description , tax , and tags have the same values as the defaults, they were set explicitly (instead of taken from the defaults). So, they will be included in the JSON response. Tip Notice that the default values can be anything, not only None . They can be a list ( [] ), a float of 10.5 , etc.","title":"Data with the same values as the defaults"},{"location":"tutorial/response-model/#response_model_include-and-response_model_exclude","text":"You can also use the path operation decorator parameters response_model_include and response_model_exclude . They take a set of str with the name of the attributes to include (omitting the rest) or to exclude (including the rest). This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output. Tip But it is still recommended to use the ideas above, using multiple classes, instead of these parameters. This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use response_model_include or response_model_exclude to omit some attributes. from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The Bar fighters\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : \"There goes my baz\" , \"price\" : 50.2 , \"tax\" : 10.5 , }, } @app . get ( \"/items/ {item_id} /name\" , response_model = Item , response_model_include = { \"name\" , \"description\" }, ) async def read_item_name ( item_id : str ): return items [ item_id ] @app . get ( \"/items/ {item_id} /public\" , response_model = Item , response_model_exclude = { \"tax\" }) async def read_item_public_data ( item_id : str ): return items [ item_id ] Tip The syntax {\"name\", \"description\"} creates a set with those two values. It is equivalent to set([\"name\", \"description\"]) .","title":"response_model_include and response_model_exclude"},{"location":"tutorial/response-model/#using-lists-instead-of-sets","text":"If you forget to use a set and use a list or tuple instead, FastAPI will still convert it to a set and it will work correctly: from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str description : str = None price : float tax : float = 10.5 items = { \"foo\" : { \"name\" : \"Foo\" , \"price\" : 50.2 }, \"bar\" : { \"name\" : \"Bar\" , \"description\" : \"The Bar fighters\" , \"price\" : 62 , \"tax\" : 20.2 }, \"baz\" : { \"name\" : \"Baz\" , \"description\" : \"There goes my baz\" , \"price\" : 50.2 , \"tax\" : 10.5 , }, } @app . get ( \"/items/ {item_id} /name\" , response_model = Item , response_model_include = [ \"name\" , \"description\" ], ) async def read_item_name ( item_id : str ): return items [ item_id ] @app . get ( \"/items/ {item_id} /public\" , response_model = Item , response_model_exclude = [ \"tax\" ]) async def read_item_public_data ( item_id : str ): return items [ item_id ]","title":"Using lists instead of sets"},{"location":"tutorial/response-model/#recap","text":"Use the path operation decorator's parameter response_model to define response models and especially to ensure private data is filtered out. Use response_model_exclude_unset to return only the values explicitly set.","title":"Recap"},{"location":"tutorial/response-status-code/","text":"The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter status_code in any of the path operations : @app.get() @app.post() @app.put() @app.delete() etc. from fastapi import FastAPI app = FastAPI () @app . post ( \"/items/\" , status_code = 201 ) async def create_item ( name : str ): return { \"name\" : name } Note Notice that status_code is a parameter of the \"decorator\" method ( get , post , etc). Not of your path operation function , like all the parameters and body. The status_code parameter receives a number with the HTTP status code. It will: Return that status code in the response. Document it as such in the OpenAPI schema (and so, in the user interfaces): Note Some response codes (see the next section) indicate that the response does not have a body. FastAPI knows this, and will produce OpenAPI docs that state there is no response body. About HTTP status codes \u00b6 Note If you already know what HTTP status codes are, skip to the next section. In HTTP, you send a numeric status code of 3 digits as part of the response. These status codes have a name associated to recognize them, but the important part is the number. In short: 100 and above are for \"Information\". You rarely use them directly. Responses with these status codes cannot have a body. 200 and above are for \"Successful\" responses. These are the ones you would use the most. 200 is the default status code, which means everything was \"OK\". Another example would be 201 , \"Created\". It is commonly used after creating a new record in the database. A special case is 204 , \"No Content\". This response is used when there is no content to return to the client, and so the response must not have a body. 300 and above are for \"Redirection\". Responses with these status codes may or may not have a body, except for 304 , \"Not Modified\", which must not have one. 400 and above are for \"Client error\" responses. These are the second type you would probably use the most. An example is 404 , for a \"Not Found\" response. For generic errors from the client, you can just use 400 . 500 and above are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes. Tip To know more about each status code and which code is for what, check the MDN documentation about HTTP status codes . Shortcut to remember the names \u00b6 Let's see the previous example again: from fastapi import FastAPI app = FastAPI () @app . post ( \"/items/\" , status_code = 201 ) async def create_item ( name : str ): return { \"name\" : name } 201 is the status code for \"Created\". But you don't have to memorize what each of these codes mean. You can use the convenience variables from starlette.status . from fastapi import FastAPI from starlette.status import HTTP_201_CREATED app = FastAPI () @app . post ( \"/items/\" , status_code = HTTP_201_CREATED ) async def create_item ( name : str ): return { \"name\" : name } They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them: Changing the default \u00b6 Later, in the Advanced User Guide , you will see how to return a different status code than the default you are declaring here.","title":"Response Status Code"},{"location":"tutorial/response-status-code/#about-http-status-codes","text":"Note If you already know what HTTP status codes are, skip to the next section. In HTTP, you send a numeric status code of 3 digits as part of the response. These status codes have a name associated to recognize them, but the important part is the number. In short: 100 and above are for \"Information\". You rarely use them directly. Responses with these status codes cannot have a body. 200 and above are for \"Successful\" responses. These are the ones you would use the most. 200 is the default status code, which means everything was \"OK\". Another example would be 201 , \"Created\". It is commonly used after creating a new record in the database. A special case is 204 , \"No Content\". This response is used when there is no content to return to the client, and so the response must not have a body. 300 and above are for \"Redirection\". Responses with these status codes may or may not have a body, except for 304 , \"Not Modified\", which must not have one. 400 and above are for \"Client error\" responses. These are the second type you would probably use the most. An example is 404 , for a \"Not Found\" response. For generic errors from the client, you can just use 400 . 500 and above are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes. Tip To know more about each status code and which code is for what, check the MDN documentation about HTTP status codes .","title":"About HTTP status codes"},{"location":"tutorial/response-status-code/#shortcut-to-remember-the-names","text":"Let's see the previous example again: from fastapi import FastAPI app = FastAPI () @app . post ( \"/items/\" , status_code = 201 ) async def create_item ( name : str ): return { \"name\" : name } 201 is the status code for \"Created\". But you don't have to memorize what each of these codes mean. You can use the convenience variables from starlette.status . from fastapi import FastAPI from starlette.status import HTTP_201_CREATED app = FastAPI () @app . post ( \"/items/\" , status_code = HTTP_201_CREATED ) async def create_item ( name : str ): return { \"name\" : name } They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:","title":"Shortcut to remember the names"},{"location":"tutorial/response-status-code/#changing-the-default","text":"Later, in the Advanced User Guide , you will see how to return a different status code than the default you are declaring here.","title":"Changing the default"},{"location":"tutorial/sql-databases/","text":"FastAPI doesn't require you to use a SQL (relational) database. But you can use any relational database that you want. Here we'll see an example using SQLAlchemy . You can easily adapt it to any database supported by SQLAlchemy, like: PostgreSQL MySQL SQLite Oracle Microsoft SQL Server, etc. In this example, we'll use SQLite , because it uses a single file and Python has integrated support. So, you can copy this example and run it as is. Later, for your production application, you might want to use a database server like PostgreSQL . Tip There is an official project generator with FastAPI and PostgreSQL , all based on Docker , including a frontend and more tools: https://github.com/tiangolo/full-stack-fastapi-postgresql Note Notice that most of the code is the standard SQLAlchemy code you would use with any framework. The FastAPI specific code is as small as always. ORMs \u00b6 FastAPI works with any database and any style of library to talk to the database. A common pattern is to use an \"ORM\": an \"object-relational mapping\" library. An ORM has tools to convert (\" map \") between objects in code and database tables (\" relations \"). With an ORM, you normally create a class that represents a table in a SQL database, each attribute of the class represents a column, with a name and a type. For example a class Pet could represent a SQL table pets . And each instance object of that class represents a row in the database. For example an object orion_cat (an instance of Pet ) could have an attribute orion_cat.type , for the column type . And the value of that attribute could be, e.g. \"cat\" . These ORMs also have tools to make the connections or relations between tables or entities. This way, you could also have an attribute orion_cat.owner and the owner would contain the data for this pet's owner, taken from the table owners . So, orion_cat.owner.name could be the name (from the name column in the owners table) of this pet's owner. It could have a value like \"Arquilian\" . And the ORM will do all the work to get the information from the corresponding table owners when you try to access it from your pet object. Common ORMs are for example: Django-ORM (part of the Django framework), SQLAlchemy ORM (part of SQLAlchemy, independent of framework) and Peewee (independent of framework), among others. Here we will see how to work with SQLAlchemy ORM . In a similar way you could use any other ORM. Tip There's an equivalent article using Peewee here in the docs. File structure \u00b6 For these examples, let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this: . \u2514\u2500\u2500 sql_app \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 crud.py \u251c\u2500\u2500 database.py \u251c\u2500\u2500 main.py \u251c\u2500\u2500 models.py \u2514\u2500\u2500 schemas.py The file __init__.py is just an empty file, but it tells Python that sql_app with all its modules (Python files) is a package. Now let's see what each file/module does. Create the SQLAlchemy parts \u00b6 Let's refer to the file sql_app/database.py . Import the SQLAlchemy parts \u00b6 from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () Create a database URL for SQLAlchemy \u00b6 from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () In this example, we are \"connecting\" to a SQLite database (opening a file with the SQLite database). The file will be located at the same directory in the file test.db . That's why the last part is ./test.db . If you were using a PostgreSQL database instead, you would just have to uncomment the line: SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" ...and adapt it with your database data and credentials (equivalently for MySQL, MariaDB or any other). Tip This is the main line that you would have to modify if you wanted to use a different database. Create the SQLAlchemy engine \u00b6 The first step is to create a SQLAlchemy \"engine\". We will later use this engine in other places. from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () Note \u00b6 The argument: connect_args = { \"check_same_thread\" : False } ...is needed only for SQLite . It's not needed for other databases. Technical Details By default SQLite will only allow one thread to communicate with it, assuming that each thread would handle an independent request. This is to prevent accidentally sharing the same connection for different things (for different requests). But in FastAPI, using normal functions ( def ) more than one thread could interact with the database for the same request, so we need to make SQLite know that it should allow that with connect_args={\"check_same_thread\": False} . Also, we will make sure each request gets its own database connection session in a dependency, so there's no need for that default mechanism. Create a SessionLocal class \u00b6 Each instance of the SessionLocal class will be a database session. The class itself is not a database session yet. But once we create an instance of the SessionLocal class, this instance will be the actual database session. We name it SessionLocal to distinguish it from the Session we are importing from SQLAlchemy. We will use Session (the one imported from SQLAlchemy) later. To create the SessionLocal class, use the function sessionmaker : from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () Create a Base class \u00b6 Now we will use the function declarative_base() that returns a class. Later we will inherit from this class to create each of the database models or classes (the ORM models): from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () Create the database models \u00b6 Let's now see the file sql_app/models.py . Create SQLAlchemy models from the Base class \u00b6 We will use this Base class we created before to create the SQLAlchemy models. Tip SQLAlchemy uses the term \" model \" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \" model \" to refer to something different, the data validation, conversion, and documentation classes and instances. Import Base from database (the file database.py from above). Create classes that inherit from it. These classes are the SQLAlchemy models. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" ) The __tablename__ attribute tells SQLAlchemy the name of the table to use in the database for each of these models. Create model attributes/columns \u00b6 Now create all the model (class) attributes. Each of these attributes represents a column in its corresponding database table. We use Column from SQLAlchemy as the default value. And we pass a SQLAlchemy class \"type\", as Integer , String , and Boolean , that defines the type in the database, as an argument. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" ) Create the relationships \u00b6 Now create the relationships. For this, we use relationship provided by SQLAlchemy ORM. This will become, more or less, a \"magic\" attribute that will contain the values from other tables related to this one. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" ) When accessing the attribute items in a User , as in my_user.items , it will have a list of Item SQLAlchemy models (from the items table) that have a foreign key pointing to this record in the users table. When you access my_user.items , SQLAlchemy will actually go and fetch the items from the database in the items table and populate them here. And when accessing the attribute owner in an Item , it will contain a User SQLAlchemy model from the users table. It will use the owner_id attribute/column with its foreign key to know which record to get from the users table. Create the Pydantic models \u00b6 Now let's check the file sql_app/schemas.py . Tip To avoid confusion between the SQLAlchemy models and the Pydantic models , we will have the file models.py with the SQLAlchemy models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both. Create initial Pydantic models / schemas \u00b6 Create an ItemBase and UserBase Pydantic models (or let's say \"schemas\") to have common attributes while creating or reading data. And create an ItemCreate and UserCreate that inherit from them (so they will have the same attributes), plus any additional data (attributes) needed for creation. So, the user will also have a password when creating it. But for security, the password won't be in other Pydantic models , for example, it won't be sent from the API when reading a user. from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True SQLAlchemy style and Pydantic style \u00b6 Notice that SQLAlchemy models define attributes using = , and pass the type as a parameter to Column , like in: name = Column ( String ) while Pydantic models declare the types using : , the new type annotation syntax/type hints: name : str Have it in mind, so you don't get confused when using = and : with them. Create Pydantic models / schemas for reading / returning \u00b6 Now create Pydantic models (schemas) that will be used when reading data, when returning it from the API. For example, before creating an item, we don't know what will be the ID assigned to it, but when reading it (when returning it from the API) we will already know its ID. The same way, when reading a user, we can now declare that items will contain the items that belong to this user. Not only the IDs of those items, but all the data that we defined in the Pydantic model for reading items: Item . from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True Tip Notice that the User , the Pydantic model that will be used when reading a user (returning it from the API) doesn't include the password . Use Pydantic's orm_mode \u00b6 Now, in the Pydantic models for reading, Item and User , add an internal Config class. This Config class is used to provide configurations to Pydantic. In the Config class, set the attribute orm_mode = True . from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True Tip Notice it's assigning a value with = , like: orm_mode = True It doesn't use : as for the type declarations before. This is setting a config value, not declaring a type. Pydantic's orm_mode will tell the Pydantic model to read the data even if it is not a dict , but an ORM model (or any other arbitrary object with attributes). This way, instead of only trying to get the id value from a dict , as in: id = data [ \"id\" ] it will also try to get it from an attribute, as in: id = data . id And with this, the Pydantic model is compatible with ORMs, and you can just declare it in the response_model argument in your path operations . You will be able to return a database model and it will read the data from it. Technical Details about ORM mode \u00b6 SQLAlchemy and many others are by default \"lazy loading\". That means, for example, that they don't fetch the data for relationships from the database unless you try to access the attribute that would contain that data. For example, accessing the attribute items : current_user . items would make SQLAlchemy go to the items table and get the items for this user, but not before. Without orm_mode , if you returned a SQLAlchemy model from your path operation , it wouldn't include the relationship data. Even if you declared those relationships in your Pydantic models. But with ORM mode, as Pydantic itself will try to access the data it needs from attributes (instead of assuming a dict ), you can declare the specific data you want to return and it will be able to go and get it, even from ORMs. CRUD utils \u00b6 Now let's see the file sql_app/crud.py . In this file we will have reusable functions to interact with the data in the database. CRUD comes from: C reate, R ead, U pdate, and D elete. ...although in this example we are only creating and reading. Read data \u00b6 Import Session from sqlalchemy.orm , this will allow you to declare the type of the db parameters and have better type checks and completion in your functions. Import models (the SQLAlchemy models) and schemas (the Pydantic models / schemas). Create utility functions to: Read a single user by ID and by email. Read multiple users. Read a single item. from sqlalchemy.orm import Session from . import models , schemas def get_user ( db : Session , user_id : int ): return db . query ( models . User ) . filter ( models . User . id == user_id ) . first () def get_user_by_email ( db : Session , email : str ): return db . query ( models . User ) . filter ( models . User . email == email ) . first () def get_users ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . User ) . offset ( skip ) . limit ( limit ) . all () def create_user ( db : Session , user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db . add ( db_user ) db . commit () db . refresh ( db_user ) return db_user def get_items ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . Item ) . offset ( skip ) . limit ( limit ) . all () def create_user_item ( db : Session , item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db . add ( db_item ) db . commit () db . refresh ( db_item ) return db_item Tip By creating functions that are only dedicated to interacting with the database (get a user or an item) independent of your path operation function , you can more easily reuse them in multiple parts and also add unit tests for them. Create data \u00b6 Now create utility functions to create data. The steps are: Create a SQLAlchemy model instance with your data. add that instance object to your database session. commit the changes to the database (so that they are saved). refresh your instance (so that it contains any new data from the database, like the generated ID). from sqlalchemy.orm import Session from . import models , schemas def get_user ( db : Session , user_id : int ): return db . query ( models . User ) . filter ( models . User . id == user_id ) . first () def get_user_by_email ( db : Session , email : str ): return db . query ( models . User ) . filter ( models . User . email == email ) . first () def get_users ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . User ) . offset ( skip ) . limit ( limit ) . all () def create_user ( db : Session , user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db . add ( db_user ) db . commit () db . refresh ( db_user ) return db_user def get_items ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . Item ) . offset ( skip ) . limit ( limit ) . all () def create_user_item ( db : Session , item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db . add ( db_item ) db . commit () db . refresh ( db_item ) return db_item Tip The SQLAlchemy model for User contains a hashed_password that should contain a secure hashed version of the password. But as what the API client provides is the original password, you need to extract it and generate the hashed password in your application. And then pass the hashed_password argument with the value to save. Warning This example is not secure, the password is not hashed. In a real life application you would need to hash the password and never save them in plaintext. For more details, go back to the Security section in the tutorial. Here we are focusing only on the tools and mechanics of databases. Tip Instead of passing each of the keyword arguments to Item and reading each one of them from the Pydantic model , we are generating a dict with the Pydantic model 's data with: item.dict() and then we are passing the dict 's key-value pairs as the keyword arguments to the SQLAlchemy Item , with: Item(**item.dict()) And then we pass the extra keyword argument owner_id that is not provided by the Pydantic model , with: Item(**item.dict(), owner_id=user_id) Main FastAPI app \u00b6 And now in the file sql_app/main.py let's integrate and use all the other parts we created before. Create the database tables \u00b6 In a very simplistic way create the database tables: from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Alembic Note \u00b6 Normally you would probably initialize your database (create tables, etc) with Alembic . And you would also use Alembic for \"migrations\" (that's its main job). A \"migration\" is the set of steps needed whenever you change the structure of your SQLAlchemy models, add a new attribute, etc. to replicate those changes in the database, add a new column, a new table, etc. Create a dependency \u00b6 Info For this to work, you need to use Python 3.7 or above, or in Python 3.6 , install the \"backports\": pip install async-exit-stack async-generator This installs async-exit-stack and async-generator . You can also use the alternative method with a \"middleware\" explained at the end. Now use the SessionLocal class we created in the sql_app/databases.py file to create a dependency. We need to have an independent database session/connection ( SessionLocal ) per request, use the same session through all the request and then close it after the request is finished. And then a new session will be created for the next request. For that, we will create a new dependency with yield , as explained before in the section about Dependencies with yield . Our dependency will create a new SQLAlchemy SessionLocal that will be used in a single request, and then close it once the request is finished. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request. But you can't raise another exception from the exit code (after yield ). See more in Dependencies with yield and HTTPException And then, when using the dependency in a path operation function , we declare it with the type Session we imported directly from SQLAlchemy. This will then give us better editor support inside the path operation function , because the editor will know that the db parameter is of type Session : from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Technical Details The parameter db is actually of type SessionLocal , but this class (created with sessionmaker() ) is a \"proxy\" of a SQLAlchemy Session , so, the editor doesn't really know what methods are provided. But by declaring the type as Session , the editor now can know the available methods ( .add() , .query() , .commit() , etc) and can provide better support (like completion). The type declaration doesn't affect the actual object. Create your FastAPI path operations \u00b6 Now, finally, here's the standard FastAPI path operations code. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items We are creating the database session before each request in the dependency with yield , and then closing it afterwards. And then we can create the required dependency in the path operation function , to get that session directly. With that, we can just call crud.get_user directly from inside of the path operation function and use that session. Tip Notice that the values you return are SQLAlchemy models, or lists of SQLAlchemy models. But as all the path operations have a response_model with Pydantic models / schemas using orm_mode , the data declared in your Pydantic models will be extracted from them and returned to the client, with all the normal filtering and validation. Tip Also notice that there are response_models that have standard Python types like List[schemas.Item] . But as the content/parameter of that List is a Pydantic model with orm_mode , the data will be retrieved and returned to the client as normally, without problems. About def vs async def \u00b6 Here we are using SQLAlchemy code inside of the path operation function and in the dependency, and, in turn, it will go and communicate with an external database. That could potentially require some \"waiting\". But as SQLAlchemy doesn't have compatibility for using await directly, as would be with something like: user = await db . query ( User ) . first () ...and instead we are using: user = db . query ( User ) . first () Then we should declare the path operation functions and the dependency without async def , just with a normal def , as: @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) ... Very Technical Details If you are curious and have a deep technical knowledge, you can check the very technical details of how this async def vs def is handled in the Async docs. Migrations \u00b6 Because we are using SQLAlchemy directly and we don't require any kind of plug-in for it to work with FastAPI , we could integrate database migrations with Alembic directly. And as the code related to SQLAlchemy and the SQLAlchemy models lives in separate independent files, you would even be able to perform the migrations with Alembic without having to install FastAPI, Pydantic, or anything else. The same way, you would be able to use the same SQLAlchemy models and utilities in other parts of your code that are not related to FastAPI . For example, in a background task worker with Celery , RQ , or ARQ . Review all the files \u00b6 Remember you should have a directory named my_super_project that contains a sub-directory called sql_app . sql_app should have the following files: sql_app/__init__.py : is an empty file. sql_app/database.py : ```Python hl_lines=\"\" from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" \u00b6 engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative_base() * `sql_app/models.py`: ```Python hl_lines=\"\" from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): __tablename__ = \"users\" id = Column(Integer, primary_key=True, index=True) email = Column(String, unique=True, index=True) hashed_password = Column(String) is_active = Column(Boolean, default=True) items = relationship(\"Item\", back_populates=\"owner\") class Item(Base): __tablename__ = \"items\" id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back_populates=\"items\") sql_app/schemas.py : ```Python hl_lines=\"\" from typing import List from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True * `sql_app/crud.py`: Python hl_lines=\"\" from sqlalchemy.orm import Session from . import models, schemas def get_user(db: Session, user_id: int): return db.query(models.User).filter(models.User.id == user_id).first() def get_user_by_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def create_user(db: Session, user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db.add(db_user) db.commit() db.refresh(db_user) return db_user def get_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db.add(db_item) db.commit() db.refresh(db_item) return db_item ``` sql_app/main.py : ```Python hl_lines=\"\" from typing import List from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create_all(bind=engine) app = FastAPI() Dependency \u00b6 def get_db(): try: db = SessionLocal() yield db finally: db.close() @app.post(\"/users/\", response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): db_user = crud.get_user_by_email(db, email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(db=db, user=user) @app.get(\"/users/\", response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): users = crud.get_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user_id}\", response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)): db_user = crud.get_user(db, user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post(\"/users/{user_id}/items/\", response_model=schemas.Item) def create_item_for_user( user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ): return crud.create_user_item(db=db, item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): items = crud.get_items(db, skip=skip, limit=limit) return items ## Check it You can copy this code and use it as is. !!! info In fact, the code shown here is part of the tests. As most of the code in these docs. Then you can run it with Uvicorn: ```bash uvicorn sql_app.main:app --reload And then, you can open your browser at http://127.0.0.1:8000/docs . And you will be able to interact with your FastAPI application, reading data from a real database: Interact with the database directly \u00b6 If you want to explore the SQLite database (file) directly, independently of FastAPI, to debug its contents, add tables, columns, records, modify data, etc. you can use DB Browser for SQLite . It will look like this: You can also use an online SQLite browser like SQLite Viewer or ExtendsClass . Alternative DB session with middleware \u00b6 If you can't use dependencies with yield -- for example, if you are not using Python 3.7 and can't install the \"backports\" mentioned above for Python 3.6 -- you can set up the session in a \"middleware\" in a similar way. A \"middleware\" is basically a function that is always executed for each request, with some code executed before, and some code executed after the endpoint function. Create a middleware \u00b6 The middleware we'll add (just a function) will create a new SQLAlchemy SessionLocal for each request, add it to the request and then close it once the request is finished. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from starlette.requests import Request from starlette.responses import Response from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () @app . middleware ( \"http\" ) async def db_session_middleware ( request : Request , call_next ): response = Response ( \"Internal server error\" , status_code = 500 ) try : request . state . db = SessionLocal () response = await call_next ( request ) finally : request . state . db . close () return response # Dependency def get_db ( request : Request ): return request . state . db @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request. About request.state \u00b6 request.state is a property of each Starlette Request object . It is there to store arbitrary objects attached to the request itself, like the database session in this case. For us in this case, it helps us ensure a single database session is used through all the request, and then closed afterwards (in the middleware). Dependencies with yield or middleware \u00b6 Adding a middleware here is similar to what a dependency with yield does, with some differences: It requires more code and is a bit more complex. The middleware has to be an async function. If there is code in it that has to \"wait\" for the network, it could \"block\" your application there and degrade performance a bit. Although it's probably not very problematic here with the way SQLAlchemy works. But if you added more code to the middleware that had a lot of I/O waiting, it could then be problematic. A middleware is run for every request. So, a connection will be created for every request. Even when the path operation that handles that request didn't need the DB. Tip It's probably better to use dependencies with yield when they are enough for the use case. Info Dependencies with yield were added recently to FastAPI . A previous version of this tutorial only had the examples with a middleware and there are probably several applications using the middleware for database session management.","title":"SQL (Relational) Databases"},{"location":"tutorial/sql-databases/#orms","text":"FastAPI works with any database and any style of library to talk to the database. A common pattern is to use an \"ORM\": an \"object-relational mapping\" library. An ORM has tools to convert (\" map \") between objects in code and database tables (\" relations \"). With an ORM, you normally create a class that represents a table in a SQL database, each attribute of the class represents a column, with a name and a type. For example a class Pet could represent a SQL table pets . And each instance object of that class represents a row in the database. For example an object orion_cat (an instance of Pet ) could have an attribute orion_cat.type , for the column type . And the value of that attribute could be, e.g. \"cat\" . These ORMs also have tools to make the connections or relations between tables or entities. This way, you could also have an attribute orion_cat.owner and the owner would contain the data for this pet's owner, taken from the table owners . So, orion_cat.owner.name could be the name (from the name column in the owners table) of this pet's owner. It could have a value like \"Arquilian\" . And the ORM will do all the work to get the information from the corresponding table owners when you try to access it from your pet object. Common ORMs are for example: Django-ORM (part of the Django framework), SQLAlchemy ORM (part of SQLAlchemy, independent of framework) and Peewee (independent of framework), among others. Here we will see how to work with SQLAlchemy ORM . In a similar way you could use any other ORM. Tip There's an equivalent article using Peewee here in the docs.","title":"ORMs"},{"location":"tutorial/sql-databases/#file-structure","text":"For these examples, let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this: . \u2514\u2500\u2500 sql_app \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 crud.py \u251c\u2500\u2500 database.py \u251c\u2500\u2500 main.py \u251c\u2500\u2500 models.py \u2514\u2500\u2500 schemas.py The file __init__.py is just an empty file, but it tells Python that sql_app with all its modules (Python files) is a package. Now let's see what each file/module does.","title":"File structure"},{"location":"tutorial/sql-databases/#create-the-sqlalchemy-parts","text":"Let's refer to the file sql_app/database.py .","title":"Create the SQLAlchemy parts"},{"location":"tutorial/sql-databases/#import-the-sqlalchemy-parts","text":"from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base ()","title":"Import the SQLAlchemy parts"},{"location":"tutorial/sql-databases/#create-a-database-url-for-sqlalchemy","text":"from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base () In this example, we are \"connecting\" to a SQLite database (opening a file with the SQLite database). The file will be located at the same directory in the file test.db . That's why the last part is ./test.db . If you were using a PostgreSQL database instead, you would just have to uncomment the line: SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" ...and adapt it with your database data and credentials (equivalently for MySQL, MariaDB or any other). Tip This is the main line that you would have to modify if you wanted to use a different database.","title":"Create a database URL for SQLAlchemy"},{"location":"tutorial/sql-databases/#create-the-sqlalchemy-engine","text":"The first step is to create a SQLAlchemy \"engine\". We will later use this engine in other places. from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base ()","title":"Create the SQLAlchemy engine"},{"location":"tutorial/sql-databases/#note","text":"The argument: connect_args = { \"check_same_thread\" : False } ...is needed only for SQLite . It's not needed for other databases. Technical Details By default SQLite will only allow one thread to communicate with it, assuming that each thread would handle an independent request. This is to prevent accidentally sharing the same connection for different things (for different requests). But in FastAPI, using normal functions ( def ) more than one thread could interact with the database for the same request, so we need to make SQLite know that it should allow that with connect_args={\"check_same_thread\": False} . Also, we will make sure each request gets its own database connection session in a dependency, so there's no need for that default mechanism.","title":"Note"},{"location":"tutorial/sql-databases/#create-a-sessionlocal-class","text":"Each instance of the SessionLocal class will be a database session. The class itself is not a database session yet. But once we create an instance of the SessionLocal class, this instance will be the actual database session. We name it SessionLocal to distinguish it from the Session we are importing from SQLAlchemy. We will use Session (the one imported from SQLAlchemy) later. To create the SessionLocal class, use the function sessionmaker : from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base ()","title":"Create a SessionLocal class"},{"location":"tutorial/sql-databases/#create-a-base-class","text":"Now we will use the function declarative_base() that returns a class. Later we will inherit from this class to create each of the database models or classes (the ORM models): from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" # SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\" engine = create_engine ( SQLALCHEMY_DATABASE_URL , connect_args = { \"check_same_thread\" : False } ) SessionLocal = sessionmaker ( autocommit = False , autoflush = False , bind = engine ) Base = declarative_base ()","title":"Create a Base class"},{"location":"tutorial/sql-databases/#create-the-database-models","text":"Let's now see the file sql_app/models.py .","title":"Create the database models"},{"location":"tutorial/sql-databases/#create-sqlalchemy-models-from-the-base-class","text":"We will use this Base class we created before to create the SQLAlchemy models. Tip SQLAlchemy uses the term \" model \" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \" model \" to refer to something different, the data validation, conversion, and documentation classes and instances. Import Base from database (the file database.py from above). Create classes that inherit from it. These classes are the SQLAlchemy models. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" ) The __tablename__ attribute tells SQLAlchemy the name of the table to use in the database for each of these models.","title":"Create SQLAlchemy models from the Base class"},{"location":"tutorial/sql-databases/#create-model-attributescolumns","text":"Now create all the model (class) attributes. Each of these attributes represents a column in its corresponding database table. We use Column from SQLAlchemy as the default value. And we pass a SQLAlchemy class \"type\", as Integer , String , and Boolean , that defines the type in the database, as an argument. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" )","title":"Create model attributes/columns"},{"location":"tutorial/sql-databases/#create-the-relationships","text":"Now create the relationships. For this, we use relationship provided by SQLAlchemy ORM. This will become, more or less, a \"magic\" attribute that will contain the values from other tables related to this one. from sqlalchemy import Boolean , Column , ForeignKey , Integer , String from sqlalchemy.orm import relationship from .database import Base class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , unique = True , index = True ) hashed_password = Column ( String ) is_active = Column ( Boolean , default = True ) items = relationship ( \"Item\" , back_populates = \"owner\" ) class Item ( Base ): __tablename__ = \"items\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String , index = True ) description = Column ( String , index = True ) owner_id = Column ( Integer , ForeignKey ( \"users.id\" )) owner = relationship ( \"User\" , back_populates = \"items\" ) When accessing the attribute items in a User , as in my_user.items , it will have a list of Item SQLAlchemy models (from the items table) that have a foreign key pointing to this record in the users table. When you access my_user.items , SQLAlchemy will actually go and fetch the items from the database in the items table and populate them here. And when accessing the attribute owner in an Item , it will contain a User SQLAlchemy model from the users table. It will use the owner_id attribute/column with its foreign key to know which record to get from the users table.","title":"Create the relationships"},{"location":"tutorial/sql-databases/#create-the-pydantic-models","text":"Now let's check the file sql_app/schemas.py . Tip To avoid confusion between the SQLAlchemy models and the Pydantic models , we will have the file models.py with the SQLAlchemy models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both.","title":"Create the Pydantic models"},{"location":"tutorial/sql-databases/#create-initial-pydantic-models-schemas","text":"Create an ItemBase and UserBase Pydantic models (or let's say \"schemas\") to have common attributes while creating or reading data. And create an ItemCreate and UserCreate that inherit from them (so they will have the same attributes), plus any additional data (attributes) needed for creation. So, the user will also have a password when creating it. But for security, the password won't be in other Pydantic models , for example, it won't be sent from the API when reading a user. from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True","title":"Create initial Pydantic models / schemas"},{"location":"tutorial/sql-databases/#sqlalchemy-style-and-pydantic-style","text":"Notice that SQLAlchemy models define attributes using = , and pass the type as a parameter to Column , like in: name = Column ( String ) while Pydantic models declare the types using : , the new type annotation syntax/type hints: name : str Have it in mind, so you don't get confused when using = and : with them.","title":"SQLAlchemy style and Pydantic style"},{"location":"tutorial/sql-databases/#create-pydantic-models-schemas-for-reading-returning","text":"Now create Pydantic models (schemas) that will be used when reading data, when returning it from the API. For example, before creating an item, we don't know what will be the ID assigned to it, but when reading it (when returning it from the API) we will already know its ID. The same way, when reading a user, we can now declare that items will contain the items that belong to this user. Not only the IDs of those items, but all the data that we defined in the Pydantic model for reading items: Item . from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True Tip Notice that the User , the Pydantic model that will be used when reading a user (returning it from the API) doesn't include the password .","title":"Create Pydantic models / schemas for reading / returning"},{"location":"tutorial/sql-databases/#use-pydantics-orm_mode","text":"Now, in the Pydantic models for reading, Item and User , add an internal Config class. This Config class is used to provide configurations to Pydantic. In the Config class, set the attribute orm_mode = True . from typing import List from pydantic import BaseModel class ItemBase ( BaseModel ): title : str description : str = None class ItemCreate ( ItemBase ): pass class Item ( ItemBase ): id : int owner_id : int class Config : orm_mode = True class UserBase ( BaseModel ): email : str class UserCreate ( UserBase ): password : str class User ( UserBase ): id : int is_active : bool items : List [ Item ] = [] class Config : orm_mode = True Tip Notice it's assigning a value with = , like: orm_mode = True It doesn't use : as for the type declarations before. This is setting a config value, not declaring a type. Pydantic's orm_mode will tell the Pydantic model to read the data even if it is not a dict , but an ORM model (or any other arbitrary object with attributes). This way, instead of only trying to get the id value from a dict , as in: id = data [ \"id\" ] it will also try to get it from an attribute, as in: id = data . id And with this, the Pydantic model is compatible with ORMs, and you can just declare it in the response_model argument in your path operations . You will be able to return a database model and it will read the data from it.","title":"Use Pydantic's orm_mode"},{"location":"tutorial/sql-databases/#technical-details-about-orm-mode","text":"SQLAlchemy and many others are by default \"lazy loading\". That means, for example, that they don't fetch the data for relationships from the database unless you try to access the attribute that would contain that data. For example, accessing the attribute items : current_user . items would make SQLAlchemy go to the items table and get the items for this user, but not before. Without orm_mode , if you returned a SQLAlchemy model from your path operation , it wouldn't include the relationship data. Even if you declared those relationships in your Pydantic models. But with ORM mode, as Pydantic itself will try to access the data it needs from attributes (instead of assuming a dict ), you can declare the specific data you want to return and it will be able to go and get it, even from ORMs.","title":"Technical Details about ORM mode"},{"location":"tutorial/sql-databases/#crud-utils","text":"Now let's see the file sql_app/crud.py . In this file we will have reusable functions to interact with the data in the database. CRUD comes from: C reate, R ead, U pdate, and D elete. ...although in this example we are only creating and reading.","title":"CRUD utils"},{"location":"tutorial/sql-databases/#read-data","text":"Import Session from sqlalchemy.orm , this will allow you to declare the type of the db parameters and have better type checks and completion in your functions. Import models (the SQLAlchemy models) and schemas (the Pydantic models / schemas). Create utility functions to: Read a single user by ID and by email. Read multiple users. Read a single item. from sqlalchemy.orm import Session from . import models , schemas def get_user ( db : Session , user_id : int ): return db . query ( models . User ) . filter ( models . User . id == user_id ) . first () def get_user_by_email ( db : Session , email : str ): return db . query ( models . User ) . filter ( models . User . email == email ) . first () def get_users ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . User ) . offset ( skip ) . limit ( limit ) . all () def create_user ( db : Session , user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db . add ( db_user ) db . commit () db . refresh ( db_user ) return db_user def get_items ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . Item ) . offset ( skip ) . limit ( limit ) . all () def create_user_item ( db : Session , item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db . add ( db_item ) db . commit () db . refresh ( db_item ) return db_item Tip By creating functions that are only dedicated to interacting with the database (get a user or an item) independent of your path operation function , you can more easily reuse them in multiple parts and also add unit tests for them.","title":"Read data"},{"location":"tutorial/sql-databases/#create-data","text":"Now create utility functions to create data. The steps are: Create a SQLAlchemy model instance with your data. add that instance object to your database session. commit the changes to the database (so that they are saved). refresh your instance (so that it contains any new data from the database, like the generated ID). from sqlalchemy.orm import Session from . import models , schemas def get_user ( db : Session , user_id : int ): return db . query ( models . User ) . filter ( models . User . id == user_id ) . first () def get_user_by_email ( db : Session , email : str ): return db . query ( models . User ) . filter ( models . User . email == email ) . first () def get_users ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . User ) . offset ( skip ) . limit ( limit ) . all () def create_user ( db : Session , user : schemas . UserCreate ): fake_hashed_password = user . password + \"notreallyhashed\" db_user = models . User ( email = user . email , hashed_password = fake_hashed_password ) db . add ( db_user ) db . commit () db . refresh ( db_user ) return db_user def get_items ( db : Session , skip : int = 0 , limit : int = 100 ): return db . query ( models . Item ) . offset ( skip ) . limit ( limit ) . all () def create_user_item ( db : Session , item : schemas . ItemCreate , user_id : int ): db_item = models . Item ( ** item . dict (), owner_id = user_id ) db . add ( db_item ) db . commit () db . refresh ( db_item ) return db_item Tip The SQLAlchemy model for User contains a hashed_password that should contain a secure hashed version of the password. But as what the API client provides is the original password, you need to extract it and generate the hashed password in your application. And then pass the hashed_password argument with the value to save. Warning This example is not secure, the password is not hashed. In a real life application you would need to hash the password and never save them in plaintext. For more details, go back to the Security section in the tutorial. Here we are focusing only on the tools and mechanics of databases. Tip Instead of passing each of the keyword arguments to Item and reading each one of them from the Pydantic model , we are generating a dict with the Pydantic model 's data with: item.dict() and then we are passing the dict 's key-value pairs as the keyword arguments to the SQLAlchemy Item , with: Item(**item.dict()) And then we pass the extra keyword argument owner_id that is not provided by the Pydantic model , with: Item(**item.dict(), owner_id=user_id)","title":"Create data"},{"location":"tutorial/sql-databases/#main-fastapi-app","text":"And now in the file sql_app/main.py let's integrate and use all the other parts we created before.","title":"Main FastAPI app"},{"location":"tutorial/sql-databases/#create-the-database-tables","text":"In a very simplistic way create the database tables: from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items","title":"Create the database tables"},{"location":"tutorial/sql-databases/#alembic-note","text":"Normally you would probably initialize your database (create tables, etc) with Alembic . And you would also use Alembic for \"migrations\" (that's its main job). A \"migration\" is the set of steps needed whenever you change the structure of your SQLAlchemy models, add a new attribute, etc. to replicate those changes in the database, add a new column, a new table, etc.","title":"Alembic Note"},{"location":"tutorial/sql-databases/#create-a-dependency","text":"Info For this to work, you need to use Python 3.7 or above, or in Python 3.6 , install the \"backports\": pip install async-exit-stack async-generator This installs async-exit-stack and async-generator . You can also use the alternative method with a \"middleware\" explained at the end. Now use the SessionLocal class we created in the sql_app/databases.py file to create a dependency. We need to have an independent database session/connection ( SessionLocal ) per request, use the same session through all the request and then close it after the request is finished. And then a new session will be created for the next request. For that, we will create a new dependency with yield , as explained before in the section about Dependencies with yield . Our dependency will create a new SQLAlchemy SessionLocal that will be used in a single request, and then close it once the request is finished. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request. But you can't raise another exception from the exit code (after yield ). See more in Dependencies with yield and HTTPException And then, when using the dependency in a path operation function , we declare it with the type Session we imported directly from SQLAlchemy. This will then give us better editor support inside the path operation function , because the editor will know that the db parameter is of type Session : from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Technical Details The parameter db is actually of type SessionLocal , but this class (created with sessionmaker() ) is a \"proxy\" of a SQLAlchemy Session , so, the editor doesn't really know what methods are provided. But by declaring the type as Session , the editor now can know the available methods ( .add() , .query() , .commit() , etc) and can provide better support (like completion). The type declaration doesn't affect the actual object.","title":"Create a dependency"},{"location":"tutorial/sql-databases/#create-your-fastapi-path-operations","text":"Now, finally, here's the standard FastAPI path operations code. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () # Dependency def get_db (): try : db = SessionLocal () yield db finally : db . close () @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items We are creating the database session before each request in the dependency with yield , and then closing it afterwards. And then we can create the required dependency in the path operation function , to get that session directly. With that, we can just call crud.get_user directly from inside of the path operation function and use that session. Tip Notice that the values you return are SQLAlchemy models, or lists of SQLAlchemy models. But as all the path operations have a response_model with Pydantic models / schemas using orm_mode , the data declared in your Pydantic models will be extracted from them and returned to the client, with all the normal filtering and validation. Tip Also notice that there are response_models that have standard Python types like List[schemas.Item] . But as the content/parameter of that List is a Pydantic model with orm_mode , the data will be retrieved and returned to the client as normally, without problems.","title":"Create your FastAPI path operations"},{"location":"tutorial/sql-databases/#about-def-vs-async-def","text":"Here we are using SQLAlchemy code inside of the path operation function and in the dependency, and, in turn, it will go and communicate with an external database. That could potentially require some \"waiting\". But as SQLAlchemy doesn't have compatibility for using await directly, as would be with something like: user = await db . query ( User ) . first () ...and instead we are using: user = db . query ( User ) . first () Then we should declare the path operation functions and the dependency without async def , just with a normal def , as: @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) ... Very Technical Details If you are curious and have a deep technical knowledge, you can check the very technical details of how this async def vs def is handled in the Async docs.","title":"About def vs async def"},{"location":"tutorial/sql-databases/#migrations","text":"Because we are using SQLAlchemy directly and we don't require any kind of plug-in for it to work with FastAPI , we could integrate database migrations with Alembic directly. And as the code related to SQLAlchemy and the SQLAlchemy models lives in separate independent files, you would even be able to perform the migrations with Alembic without having to install FastAPI, Pydantic, or anything else. The same way, you would be able to use the same SQLAlchemy models and utilities in other parts of your code that are not related to FastAPI . For example, in a background task worker with Celery , RQ , or ARQ .","title":"Migrations"},{"location":"tutorial/sql-databases/#review-all-the-files","text":"Remember you should have a directory named my_super_project that contains a sub-directory called sql_app . sql_app should have the following files: sql_app/__init__.py : is an empty file. sql_app/database.py : ```Python hl_lines=\"\" from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"","title":"Review all the files"},{"location":"tutorial/sql-databases/#sqlalchemy_database_url-postgresqluserpasswordpostgresserverdb","text":"engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative_base() * `sql_app/models.py`: ```Python hl_lines=\"\" from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): __tablename__ = \"users\" id = Column(Integer, primary_key=True, index=True) email = Column(String, unique=True, index=True) hashed_password = Column(String) is_active = Column(Boolean, default=True) items = relationship(\"Item\", back_populates=\"owner\") class Item(Base): __tablename__ = \"items\" id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back_populates=\"items\") sql_app/schemas.py : ```Python hl_lines=\"\" from typing import List from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True * `sql_app/crud.py`: Python hl_lines=\"\" from sqlalchemy.orm import Session from . import models, schemas def get_user(db: Session, user_id: int): return db.query(models.User).filter(models.User.id == user_id).first() def get_user_by_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def create_user(db: Session, user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db.add(db_user) db.commit() db.refresh(db_user) return db_user def get_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db.add(db_item) db.commit() db.refresh(db_item) return db_item ``` sql_app/main.py : ```Python hl_lines=\"\" from typing import List from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create_all(bind=engine) app = FastAPI()","title":"SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@postgresserver/db\""},{"location":"tutorial/sql-databases/#dependency","text":"def get_db(): try: db = SessionLocal() yield db finally: db.close() @app.post(\"/users/\", response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): db_user = crud.get_user_by_email(db, email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(db=db, user=user) @app.get(\"/users/\", response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): users = crud.get_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user_id}\", response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)): db_user = crud.get_user(db, user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post(\"/users/{user_id}/items/\", response_model=schemas.Item) def create_item_for_user( user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ): return crud.create_user_item(db=db, item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): items = crud.get_items(db, skip=skip, limit=limit) return items ## Check it You can copy this code and use it as is. !!! info In fact, the code shown here is part of the tests. As most of the code in these docs. Then you can run it with Uvicorn: ```bash uvicorn sql_app.main:app --reload And then, you can open your browser at http://127.0.0.1:8000/docs . And you will be able to interact with your FastAPI application, reading data from a real database:","title":"Dependency"},{"location":"tutorial/sql-databases/#interact-with-the-database-directly","text":"If you want to explore the SQLite database (file) directly, independently of FastAPI, to debug its contents, add tables, columns, records, modify data, etc. you can use DB Browser for SQLite . It will look like this: You can also use an online SQLite browser like SQLite Viewer or ExtendsClass .","title":"Interact with the database directly"},{"location":"tutorial/sql-databases/#alternative-db-session-with-middleware","text":"If you can't use dependencies with yield -- for example, if you are not using Python 3.7 and can't install the \"backports\" mentioned above for Python 3.6 -- you can set up the session in a \"middleware\" in a similar way. A \"middleware\" is basically a function that is always executed for each request, with some code executed before, and some code executed after the endpoint function.","title":"Alternative DB session with middleware"},{"location":"tutorial/sql-databases/#create-a-middleware","text":"The middleware we'll add (just a function) will create a new SQLAlchemy SessionLocal for each request, add it to the request and then close it once the request is finished. from typing import List from fastapi import Depends , FastAPI , HTTPException from sqlalchemy.orm import Session from starlette.requests import Request from starlette.responses import Response from . import crud , models , schemas from .database import SessionLocal , engine models . Base . metadata . create_all ( bind = engine ) app = FastAPI () @app . middleware ( \"http\" ) async def db_session_middleware ( request : Request , call_next ): response = Response ( \"Internal server error\" , status_code = 500 ) try : request . state . db = SessionLocal () response = await call_next ( request ) finally : request . state . db . close () return response # Dependency def get_db ( request : Request ): return request . state . db @app . post ( \"/users/\" , response_model = schemas . User ) def create_user ( user : schemas . UserCreate , db : Session = Depends ( get_db )): db_user = crud . get_user_by_email ( db , email = user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"Email already registered\" ) return crud . create_user ( db = db , user = user ) @app . get ( \"/users/\" , response_model = List [ schemas . User ]) def read_users ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): users = crud . get_users ( db , skip = skip , limit = limit ) return users @app . get ( \"/users/ {user_id} \" , response_model = schemas . User ) def read_user ( user_id : int , db : Session = Depends ( get_db )): db_user = crud . get_user ( db , user_id = user_id ) if db_user is None : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) return db_user @app . post ( \"/users/ {user_id} /items/\" , response_model = schemas . Item ) def create_item_for_user ( user_id : int , item : schemas . ItemCreate , db : Session = Depends ( get_db ) ): return crud . create_user_item ( db = db , item = item , user_id = user_id ) @app . get ( \"/items/\" , response_model = List [ schemas . Item ]) def read_items ( skip : int = 0 , limit : int = 100 , db : Session = Depends ( get_db )): items = crud . get_items ( db , skip = skip , limit = limit ) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request.","title":"Create a middleware"},{"location":"tutorial/sql-databases/#about-requeststate","text":"request.state is a property of each Starlette Request object . It is there to store arbitrary objects attached to the request itself, like the database session in this case. For us in this case, it helps us ensure a single database session is used through all the request, and then closed afterwards (in the middleware).","title":"About request.state"},{"location":"tutorial/sql-databases/#dependencies-with-yield-or-middleware","text":"Adding a middleware here is similar to what a dependency with yield does, with some differences: It requires more code and is a bit more complex. The middleware has to be an async function. If there is code in it that has to \"wait\" for the network, it could \"block\" your application there and degrade performance a bit. Although it's probably not very problematic here with the way SQLAlchemy works. But if you added more code to the middleware that had a lot of I/O waiting, it could then be problematic. A middleware is run for every request. So, a connection will be created for every request. Even when the path operation that handles that request didn't need the DB. Tip It's probably better to use dependencies with yield when they are enough for the use case. Info Dependencies with yield were added recently to FastAPI . A previous version of this tutorial only had the examples with a middleware and there are probably several applications using the middleware for database session management.","title":"Dependencies with yield or middleware"},{"location":"tutorial/static-files/","text":"You can serve static files automatically from a directory using Starlette's Static Files . Install aiofiles \u00b6 First you need to install aiofiles : pip install aiofiles Use StaticFiles \u00b6 Import StaticFiles from Starlette. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from starlette.staticfiles import StaticFiles app = FastAPI () app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" ) What is \"Mounting\" \u00b6 \"Mounting\" means adding a complete \"independent\" application in a specific path, that then takes care of handling all the sub-paths. This is different from using an APIRouter as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc. You can read more about this in the Advanced User Guide . Details \u00b6 The first \"/static\" refers to the sub-path this \"sub-application\" will be \"mounted\" on. So, any path that starts with \"/static\" will be handled by it. The directory=\"static\" refers to the name of the directory that contains your static files. The name=\"static\" gives it a name that can be used internally by FastAPI . All these parameters can be different than \" static \", adjust them with the needs and specific details of your own application. More info \u00b6 For more details and options check Starlette's docs about Static Files .","title":"Static Files"},{"location":"tutorial/static-files/#install-aiofiles","text":"First you need to install aiofiles : pip install aiofiles","title":"Install aiofiles"},{"location":"tutorial/static-files/#use-staticfiles","text":"Import StaticFiles from Starlette. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from starlette.staticfiles import StaticFiles app = FastAPI () app . mount ( \"/static\" , StaticFiles ( directory = \"static\" ), name = \"static\" )","title":"Use StaticFiles"},{"location":"tutorial/static-files/#what-is-mounting","text":"\"Mounting\" means adding a complete \"independent\" application in a specific path, that then takes care of handling all the sub-paths. This is different from using an APIRouter as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc. You can read more about this in the Advanced User Guide .","title":"What is \"Mounting\""},{"location":"tutorial/static-files/#details","text":"The first \"/static\" refers to the sub-path this \"sub-application\" will be \"mounted\" on. So, any path that starts with \"/static\" will be handled by it. The directory=\"static\" refers to the name of the directory that contains your static files. The name=\"static\" gives it a name that can be used internally by FastAPI . All these parameters can be different than \" static \", adjust them with the needs and specific details of your own application.","title":"Details"},{"location":"tutorial/static-files/#more-info","text":"For more details and options check Starlette's docs about Static Files .","title":"More info"},{"location":"tutorial/testing/","text":"Thanks to Starlette's TestClient , testing FastAPI applications is easy and enjoyable. It is based on Requests , so it's very familiar and intuitive. With it, you can use pytest directly with FastAPI . Using TestClient \u00b6 Import TestClient from starlette.testclient . Create a TestClient passing to it your FastAPI . Create functions with a name that starts with test_ (this is standard pytest conventions). Use the TestClient object the same way as you do with requests . Write simple assert statements with the standard Python expressions that you need to check (again, standard pytest ). from fastapi import FastAPI from starlette.testclient import TestClient app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" } client = TestClient ( app ) def test_read_main (): response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" } Tip Notice that the testing functions are normal def , not async def . And the calls to the client are also normal calls, not using await . This allows you to use pytest directly without complications. Separating tests \u00b6 In a real application, you probably would have your tests in a different file. And your FastAPI application might also be composed of several files/modules, etc. FastAPI app file \u00b6 Let's say you have a file main.py with your FastAPI app: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" } Testing file \u00b6 Then you could have a file test_main.py with your tests, and import your app from the main module ( main.py ): from starlette.testclient import TestClient from .main import app client = TestClient ( app ) def test_read_main (): response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" } Testing: extended example \u00b6 Now let's extend this example and add more details to see how to test different parts. Extended FastAPI app file \u00b6 Let's say you have a file main_b.py with your FastAPI app. It has a GET operation that could return an error. It has a POST operation that could return several errors. Both path operations require an X-Token header. from fastapi import FastAPI , Header , HTTPException from pydantic import BaseModel fake_secret_token = \"coneofsilence\" fake_db = { \"foo\" : { \"id\" : \"foo\" , \"title\" : \"Foo\" , \"description\" : \"There goes my hero\" }, \"bar\" : { \"id\" : \"bar\" , \"title\" : \"Bar\" , \"description\" : \"The bartenders\" }, } app = FastAPI () class Item ( BaseModel ): id : str title : str description : str = None @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_main ( item_id : str , x_token : str = Header ( ... )): if x_token != fake_secret_token : raise HTTPException ( status_code = 400 , detail = \"Invalid X-Token header\" ) if item_id not in fake_db : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return fake_db [ item_id ] @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item , x_token : str = Header ( ... )): if x_token != fake_secret_token : raise HTTPException ( status_code = 400 , detail = \"Invalid X-Token header\" ) if item . id in fake_db : raise HTTPException ( status_code = 400 , detail = \"Item already exists\" ) fake_db [ item . id ] = item return item Extended testing file \u00b6 You could then have a test_main_b.py , the same as before, with the extended tests: from starlette.testclient import TestClient from .main_b import app client = TestClient ( app ) def test_read_item (): response = client . get ( \"/items/foo\" , headers = { \"X-Token\" : \"coneofsilence\" }) assert response . status_code == 200 assert response . json () == { \"id\" : \"foo\" , \"title\" : \"Foo\" , \"description\" : \"There goes my hero\" , } def test_read_item_bad_token (): response = client . get ( \"/items/foo\" , headers = { \"X-Token\" : \"hailhydra\" }) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Invalid X-Token header\" } def test_read_inexistent_item (): response = client . get ( \"/items/baz\" , headers = { \"X-Token\" : \"coneofsilence\" }) assert response . status_code == 404 assert response . json () == { \"detail\" : \"Item not found\" } def test_create_item (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"coneofsilence\" }, json = { \"id\" : \"foobar\" , \"title\" : \"Foo Bar\" , \"description\" : \"The Foo Barters\" }, ) assert response . status_code == 200 assert response . json () == { \"id\" : \"foobar\" , \"title\" : \"Foo Bar\" , \"description\" : \"The Foo Barters\" , } def test_create_item_bad_token (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"hailhydra\" }, json = { \"id\" : \"bazz\" , \"title\" : \"Bazz\" , \"description\" : \"Drop the bazz\" }, ) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Invalid X-Token header\" } def test_create_existing_token (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"coneofsilence\" }, json = { \"id\" : \"foo\" , \"title\" : \"The Foo ID Stealers\" , \"description\" : \"There goes my stealer\" , }, ) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Item already exists\" } Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in requests . Then you just do the same in your tests. E.g.: To pass a path or query parameter, add it to the URL itself. To pass a JSON body, pass a Python object (e.g. a dict ) to the parameter json . If you need to send Form Data instead of JSON, use the data parameter instead. To pass headers , use a dict in the headers parameter. For cookies , a dict in the cookies parameter. For more information about how to pass data to the backend (using requests or the TestClient ) check the Requests documentation . Info Note that the TestClient receives data that can be converted to JSON, not Pydantic models. If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the jsonable_encoder descibed in JSON Compatible Encoder . Run it \u00b6 After that, you just need to install pytest : pip install pytest It will detect the files and tests automatically, execute them, and report the results back to you. Run the tests with: pytest","title":"Testing"},{"location":"tutorial/testing/#using-testclient","text":"Import TestClient from starlette.testclient . Create a TestClient passing to it your FastAPI . Create functions with a name that starts with test_ (this is standard pytest conventions). Use the TestClient object the same way as you do with requests . Write simple assert statements with the standard Python expressions that you need to check (again, standard pytest ). from fastapi import FastAPI from starlette.testclient import TestClient app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" } client = TestClient ( app ) def test_read_main (): response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" } Tip Notice that the testing functions are normal def , not async def . And the calls to the client are also normal calls, not using await . This allows you to use pytest directly without complications.","title":"Using TestClient"},{"location":"tutorial/testing/#separating-tests","text":"In a real application, you probably would have your tests in a different file. And your FastAPI application might also be composed of several files/modules, etc.","title":"Separating tests"},{"location":"tutorial/testing/#fastapi-app-file","text":"Let's say you have a file main.py with your FastAPI app: from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def read_main (): return { \"msg\" : \"Hello World\" }","title":"FastAPI app file"},{"location":"tutorial/testing/#testing-file","text":"Then you could have a file test_main.py with your tests, and import your app from the main module ( main.py ): from starlette.testclient import TestClient from .main import app client = TestClient ( app ) def test_read_main (): response = client . get ( \"/\" ) assert response . status_code == 200 assert response . json () == { \"msg\" : \"Hello World\" }","title":"Testing file"},{"location":"tutorial/testing/#testing-extended-example","text":"Now let's extend this example and add more details to see how to test different parts.","title":"Testing: extended example"},{"location":"tutorial/testing/#extended-fastapi-app-file","text":"Let's say you have a file main_b.py with your FastAPI app. It has a GET operation that could return an error. It has a POST operation that could return several errors. Both path operations require an X-Token header. from fastapi import FastAPI , Header , HTTPException from pydantic import BaseModel fake_secret_token = \"coneofsilence\" fake_db = { \"foo\" : { \"id\" : \"foo\" , \"title\" : \"Foo\" , \"description\" : \"There goes my hero\" }, \"bar\" : { \"id\" : \"bar\" , \"title\" : \"Bar\" , \"description\" : \"The bartenders\" }, } app = FastAPI () class Item ( BaseModel ): id : str title : str description : str = None @app . get ( \"/items/ {item_id} \" , response_model = Item ) async def read_main ( item_id : str , x_token : str = Header ( ... )): if x_token != fake_secret_token : raise HTTPException ( status_code = 400 , detail = \"Invalid X-Token header\" ) if item_id not in fake_db : raise HTTPException ( status_code = 404 , detail = \"Item not found\" ) return fake_db [ item_id ] @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item , x_token : str = Header ( ... )): if x_token != fake_secret_token : raise HTTPException ( status_code = 400 , detail = \"Invalid X-Token header\" ) if item . id in fake_db : raise HTTPException ( status_code = 400 , detail = \"Item already exists\" ) fake_db [ item . id ] = item return item","title":"Extended FastAPI app file"},{"location":"tutorial/testing/#extended-testing-file","text":"You could then have a test_main_b.py , the same as before, with the extended tests: from starlette.testclient import TestClient from .main_b import app client = TestClient ( app ) def test_read_item (): response = client . get ( \"/items/foo\" , headers = { \"X-Token\" : \"coneofsilence\" }) assert response . status_code == 200 assert response . json () == { \"id\" : \"foo\" , \"title\" : \"Foo\" , \"description\" : \"There goes my hero\" , } def test_read_item_bad_token (): response = client . get ( \"/items/foo\" , headers = { \"X-Token\" : \"hailhydra\" }) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Invalid X-Token header\" } def test_read_inexistent_item (): response = client . get ( \"/items/baz\" , headers = { \"X-Token\" : \"coneofsilence\" }) assert response . status_code == 404 assert response . json () == { \"detail\" : \"Item not found\" } def test_create_item (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"coneofsilence\" }, json = { \"id\" : \"foobar\" , \"title\" : \"Foo Bar\" , \"description\" : \"The Foo Barters\" }, ) assert response . status_code == 200 assert response . json () == { \"id\" : \"foobar\" , \"title\" : \"Foo Bar\" , \"description\" : \"The Foo Barters\" , } def test_create_item_bad_token (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"hailhydra\" }, json = { \"id\" : \"bazz\" , \"title\" : \"Bazz\" , \"description\" : \"Drop the bazz\" }, ) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Invalid X-Token header\" } def test_create_existing_token (): response = client . post ( \"/items/\" , headers = { \"X-Token\" : \"coneofsilence\" }, json = { \"id\" : \"foo\" , \"title\" : \"The Foo ID Stealers\" , \"description\" : \"There goes my stealer\" , }, ) assert response . status_code == 400 assert response . json () == { \"detail\" : \"Item already exists\" } Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in requests . Then you just do the same in your tests. E.g.: To pass a path or query parameter, add it to the URL itself. To pass a JSON body, pass a Python object (e.g. a dict ) to the parameter json . If you need to send Form Data instead of JSON, use the data parameter instead. To pass headers , use a dict in the headers parameter. For cookies , a dict in the cookies parameter. For more information about how to pass data to the backend (using requests or the TestClient ) check the Requests documentation . Info Note that the TestClient receives data that can be converted to JSON, not Pydantic models. If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the jsonable_encoder descibed in JSON Compatible Encoder .","title":"Extended testing file"},{"location":"tutorial/testing/#run-it","text":"After that, you just need to install pytest : pip install pytest It will detect the files and tests automatically, execute them, and report the results back to you. Run the tests with: pytest","title":"Run it"},{"location":"tutorial/dependencies/","text":"FastAPI has a very powerful but intuitive Dependency Injection system. It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with FastAPI . What is \"Dependency Injection\" \u00b6 \"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions ) to declare things that it requires to work and use: \"dependencies\". And then, that system (in this case FastAPI ) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies). This is very useful when you need to: Have shared logic (the same code logic again and again). Share database connections. Enforce security, authentication, role requirements, etc. And many other things... All these, while minimizing code repetition. First Steps \u00b6 Let's see a very simple example. It will be so simple that it is not very useful, for now. But this way we can focus on how the Dependency Injection system works. Create a dependency, or \"dependable\" \u00b6 Let's first focus on the dependency. It is just a function that can take all the same parameters that a path operation function can take: from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons That's it. 2 lines . And it has the same shape and structure that all your path operation functions . You can think of it as a path operation function without the \"decorator\" (without the @app.get(\"/some-path\") ). And it can return anything you want. In this case, this dependency expects: An optional query parameter q that is a str . An optional query parameter skip that is an int , and by default is 0 . An optional query parameter limit that is an int , and by default is 100 . And then it just returns a dict containing those values. Import Depends \u00b6 from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons Declare the dependency, in the \"dependant\" \u00b6 The same way you use Body , Query , etc. with your path operation function parameters, use Depends with a new parameter: from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons Although you use Depends in the parameters of your function the same way you use Body , Query , etc, Depends works a bit differently. You only give Depends a single parameter. This parameter must be something like a function. And that function takes parameters in the same way that path operation functions do. Tip You'll see what other \"things\", apart from functions, can be used as dependencies in the next chapter. Whenever a new request arrives, FastAPI will take care of: Calling your dependency (\"dependable\") function with the correct parameters. Get the result from your function. Assign that result to the parameter in your path operation function . graph TB common_parameters([\"common_parameters\"]) read_items[\"/items/\"] read_users[\"/users/\"] common_parameters --> read_items common_parameters --> read_users This way you write shared code once and FastAPI takes care of calling it for your path operations . Check Notice that you don't have to create a special class and pass it somewhere to FastAPI to \"register\" it or anything similar. You just pass it to Depends and FastAPI knows how to do the rest. To async or not to async \u00b6 As dependencies will also be called by FastAPI (the same as your path operation functions ), the same rules apply while defining your functions. You can use async def or normal def . And you can declare dependencies with async def inside of normal def path operation functions , or def dependencies inside of async def path operation functions , etc. It doesn't matter. FastAPI will know what to do. Note If you don't know, check the Async: \"In a hurry?\" section about async and await in the docs. Integrated with OpenAPI \u00b6 All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema. So, the interactive docs will have all the information from these dependencies too: Simple usage \u00b6 If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters and use the response. Actually, all (or most) of the web frameworks work in this same way. You never call those functions directly. They are called by your framework (in this case, FastAPI ). With the Dependency Injection system, you can also tell FastAPI that your path operation function also \"depends\" on something else that should be executed before your path operation function , and FastAPI will take care of executing it and \"injecting\" the results. Other common terms for this same idea of \"dependency injection\" are: resources providers services injectables components FastAPI plug-ins \u00b6 Integrations and \"plug-in\"s can be built using the Dependency Injection system. But in fact, there is actually no need to create \"plug-ins\" , as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions . And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally . You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc. FastAPI compatibility \u00b6 The simplicity of the dependency injection system makes FastAPI compatible with: all the relational databases NoSQL databases external packages external APIs authentication and authorization systems API usage monitoring systems response data injection systems etc. Simple and Powerful \u00b6 Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful. You can define dependencies that in turn can define dependencies themselves. In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step. For example, let's say you have 4 API endpoints ( path operations ): /items/public/ /items/private/ /users/{user_id}/activate /items/pro/ then you could add different permission requirements for each of them just with dependencies and sub-dependencies: graph TB current_user([\"current_user\"]) active_user([\"active_user\"]) admin_user([\"admin_user\"]) paying_user([\"paying_user\"]) public[\"/items/public/\"] private[\"/items/private/\"] activate_user[\"/users/{user_id}/activate\"] pro_items[\"/items/pro/\"] current_user --> active_user active_user --> admin_user active_user --> paying_user current_user --> public active_user --> private admin_user --> activate_user paying_user --> pro_items Integrated with OpenAPI \u00b6 All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations . FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.","title":"First Steps"},{"location":"tutorial/dependencies/#what-is-dependency-injection","text":"\"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions ) to declare things that it requires to work and use: \"dependencies\". And then, that system (in this case FastAPI ) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies). This is very useful when you need to: Have shared logic (the same code logic again and again). Share database connections. Enforce security, authentication, role requirements, etc. And many other things... All these, while minimizing code repetition.","title":"What is \"Dependency Injection\""},{"location":"tutorial/dependencies/#first-steps","text":"Let's see a very simple example. It will be so simple that it is not very useful, for now. But this way we can focus on how the Dependency Injection system works.","title":"First Steps"},{"location":"tutorial/dependencies/#create-a-dependency-or-dependable","text":"Let's first focus on the dependency. It is just a function that can take all the same parameters that a path operation function can take: from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons That's it. 2 lines . And it has the same shape and structure that all your path operation functions . You can think of it as a path operation function without the \"decorator\" (without the @app.get(\"/some-path\") ). And it can return anything you want. In this case, this dependency expects: An optional query parameter q that is a str . An optional query parameter skip that is an int , and by default is 0 . An optional query parameter limit that is an int , and by default is 100 . And then it just returns a dict containing those values.","title":"Create a dependency, or \"dependable\""},{"location":"tutorial/dependencies/#import-depends","text":"from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons","title":"Import Depends"},{"location":"tutorial/dependencies/#declare-the-dependency-in-the-dependant","text":"The same way you use Body , Query , etc. with your path operation function parameters, use Depends with a new parameter: from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons Although you use Depends in the parameters of your function the same way you use Body , Query , etc, Depends works a bit differently. You only give Depends a single parameter. This parameter must be something like a function. And that function takes parameters in the same way that path operation functions do. Tip You'll see what other \"things\", apart from functions, can be used as dependencies in the next chapter. Whenever a new request arrives, FastAPI will take care of: Calling your dependency (\"dependable\") function with the correct parameters. Get the result from your function. Assign that result to the parameter in your path operation function . graph TB common_parameters([\"common_parameters\"]) read_items[\"/items/\"] read_users[\"/users/\"] common_parameters --> read_items common_parameters --> read_users This way you write shared code once and FastAPI takes care of calling it for your path operations . Check Notice that you don't have to create a special class and pass it somewhere to FastAPI to \"register\" it or anything similar. You just pass it to Depends and FastAPI knows how to do the rest.","title":"Declare the dependency, in the \"dependant\""},{"location":"tutorial/dependencies/#to-async-or-not-to-async","text":"As dependencies will also be called by FastAPI (the same as your path operation functions ), the same rules apply while defining your functions. You can use async def or normal def . And you can declare dependencies with async def inside of normal def path operation functions , or def dependencies inside of async def path operation functions , etc. It doesn't matter. FastAPI will know what to do. Note If you don't know, check the Async: \"In a hurry?\" section about async and await in the docs.","title":"To async or not to async"},{"location":"tutorial/dependencies/#integrated-with-openapi","text":"All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema. So, the interactive docs will have all the information from these dependencies too:","title":"Integrated with OpenAPI"},{"location":"tutorial/dependencies/#simple-usage","text":"If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters and use the response. Actually, all (or most) of the web frameworks work in this same way. You never call those functions directly. They are called by your framework (in this case, FastAPI ). With the Dependency Injection system, you can also tell FastAPI that your path operation function also \"depends\" on something else that should be executed before your path operation function , and FastAPI will take care of executing it and \"injecting\" the results. Other common terms for this same idea of \"dependency injection\" are: resources providers services injectables components","title":"Simple usage"},{"location":"tutorial/dependencies/#fastapi-plug-ins","text":"Integrations and \"plug-in\"s can be built using the Dependency Injection system. But in fact, there is actually no need to create \"plug-ins\" , as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions . And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally . You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.","title":"FastAPI plug-ins"},{"location":"tutorial/dependencies/#fastapi-compatibility","text":"The simplicity of the dependency injection system makes FastAPI compatible with: all the relational databases NoSQL databases external packages external APIs authentication and authorization systems API usage monitoring systems response data injection systems etc.","title":"FastAPI compatibility"},{"location":"tutorial/dependencies/#simple-and-powerful","text":"Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful. You can define dependencies that in turn can define dependencies themselves. In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step. For example, let's say you have 4 API endpoints ( path operations ): /items/public/ /items/private/ /users/{user_id}/activate /items/pro/ then you could add different permission requirements for each of them just with dependencies and sub-dependencies: graph TB current_user([\"current_user\"]) active_user([\"active_user\"]) admin_user([\"admin_user\"]) paying_user([\"paying_user\"]) public[\"/items/public/\"] private[\"/items/private/\"] activate_user[\"/users/{user_id}/activate\"] pro_items[\"/items/pro/\"] current_user --> active_user active_user --> admin_user active_user --> paying_user current_user --> public active_user --> private admin_user --> activate_user paying_user --> pro_items","title":"Simple and Powerful"},{"location":"tutorial/dependencies/#integrated-with-openapi_1","text":"All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations . FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.","title":"Integrated with OpenAPI"},{"location":"tutorial/dependencies/classes-as-dependencies/","text":"Before diving deeper into the Dependency Injection system, let's upgrade the previous example. A dict from the previous example \u00b6 In the previous example, we were returning a dict from our dependency (\"dependable\"): from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons But then we get a dict in the parameter commons of the path operation function . And we know that editors can't provide a lot of support (like completion) for dict s, because they can't know their keys and value types. We can do better... What makes a dependency \u00b6 Up to now you have seen dependencies declared as functions. But that's not the only way to declare dependencies (although it would probably be the more common). The key factor is that a dependency should be a \"callable\". A \" callable \" in Python is anything that Python can \"call\" like a function. So, if you have an object something (that might not be a function) and you can \"call\" it (execute it) like: something () or something ( some_argument , some_keyword_argument = \"foo\" ) then it is a \"callable\". Classes as dependencies \u00b6 You might notice that to create an instance of a Python class, you use that same syntax. For example: class Cat : def __init__ ( self , name : str ): self . name = name fluffy = Cat ( name = \"Mr Fluffy\" ) In this case, fluffy is an instance of the class Cat . And to create fluffy , you are \"calling\" Cat . So, a Python class is also a callable . Then, in FastAPI , you could use a Python class as a dependency. What FastAPI actually checks is that it is a \"callable\" (function, class or anything else) and the parameters defined. If you pass a \"callable\" as a dependency in FastAPI , it will analyze the parameters for that \"callable\", and process them in the same way as the parameters for a path operation function . Including sub-dependencies. That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters. Then, we can change the dependency \"dependable\" common_parameters from above to the class CommonQueryParameters : from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response Pay attention to the __init__ method used to create the instance of the class: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response ...it has the same parameters as our previous common_parameters : from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons Those parameters are what FastAPI will use to \"solve\" the dependency. In both cases, it will have: an optional q query parameter. a skip query parameter, with a default of 0 . a limit query parameter, with a default of 100 . In both cases the data will be converted, validated, documented on the OpenAPI schema, etc. Use it \u00b6 Now you can declare your dependency using this class. And as when FastAPI calls that class the value that will be passed as commons to your function will be an \"instance\" of the class, you can declare that parameter commons to be of type of the class, CommonQueryParams . from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response Type annotation vs Depends \u00b6 In the code above, you are declaring commons as: commons : CommonQueryParams = Depends ( CommonQueryParams ) The last CommonQueryParams , in: ... = Depends ( CommonQueryParams ) ...is what FastAPI will actually use to know what is the dependency. From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call. In this case, the first CommonQueryParams , in: commons : CommonQueryParams ... ...doesn't have any special meaning for FastAPI . FastAPI won't use it for data conversion, validation, etc. (as it is using the = Depends(CommonQueryParams) for that). You could actually write just: commons = Depends ( CommonQueryParams ) ..as in: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons , and then it can help you with code completion, type checks, etc: Shortcut \u00b6 But you see that we are having some code repetition here, writing CommonQueryParams twice: commons : CommonQueryParams = Depends ( CommonQueryParams ) FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will \"call\" to create an instance of the class itself. For those specific cases, you can do the following: Instead of writing: commons : CommonQueryParams = Depends ( CommonQueryParams ) ...you write: commons : CommonQueryParams = Depends () So, you can declare the dependency as the type of the variable, and use Depends() as the \"default\" value (the value after the = ) for that function's parameter, without any parameter, instead of having to write the full class again inside of Depends(CommonQueryParams) . So, the same example would look like: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ()): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response ...and FastAPI will know what to do. Tip If all that seems more confusing than helpful, disregard it, you don't need it. It is just a shortcut. Because FastAPI cares about helping you minimize code repetition.","title":"Classes as Dependencies"},{"location":"tutorial/dependencies/classes-as-dependencies/#a-dict-from-the-previous-example","text":"In the previous example, we were returning a dict from our dependency (\"dependable\"): from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons But then we get a dict in the parameter commons of the path operation function . And we know that editors can't provide a lot of support (like completion) for dict s, because they can't know their keys and value types. We can do better...","title":"A dict from the previous example"},{"location":"tutorial/dependencies/classes-as-dependencies/#what-makes-a-dependency","text":"Up to now you have seen dependencies declared as functions. But that's not the only way to declare dependencies (although it would probably be the more common). The key factor is that a dependency should be a \"callable\". A \" callable \" in Python is anything that Python can \"call\" like a function. So, if you have an object something (that might not be a function) and you can \"call\" it (execute it) like: something () or something ( some_argument , some_keyword_argument = \"foo\" ) then it is a \"callable\".","title":"What makes a dependency"},{"location":"tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies","text":"You might notice that to create an instance of a Python class, you use that same syntax. For example: class Cat : def __init__ ( self , name : str ): self . name = name fluffy = Cat ( name = \"Mr Fluffy\" ) In this case, fluffy is an instance of the class Cat . And to create fluffy , you are \"calling\" Cat . So, a Python class is also a callable . Then, in FastAPI , you could use a Python class as a dependency. What FastAPI actually checks is that it is a \"callable\" (function, class or anything else) and the parameters defined. If you pass a \"callable\" as a dependency in FastAPI , it will analyze the parameters for that \"callable\", and process them in the same way as the parameters for a path operation function . Including sub-dependencies. That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters. Then, we can change the dependency \"dependable\" common_parameters from above to the class CommonQueryParameters : from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response Pay attention to the __init__ method used to create the instance of the class: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response ...it has the same parameters as our previous common_parameters : from fastapi import Depends , FastAPI app = FastAPI () async def common_parameters ( q : str = None , skip : int = 0 , limit : int = 100 ): return { \"q\" : q , \"skip\" : skip , \"limit\" : limit } @app . get ( \"/items/\" ) async def read_items ( commons : dict = Depends ( common_parameters )): return commons @app . get ( \"/users/\" ) async def read_users ( commons : dict = Depends ( common_parameters )): return commons Those parameters are what FastAPI will use to \"solve\" the dependency. In both cases, it will have: an optional q query parameter. a skip query parameter, with a default of 0 . a limit query parameter, with a default of 100 . In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.","title":"Classes as dependencies"},{"location":"tutorial/dependencies/classes-as-dependencies/#use-it","text":"Now you can declare your dependency using this class. And as when FastAPI calls that class the value that will be passed as commons to your function will be an \"instance\" of the class, you can declare that parameter commons to be of type of the class, CommonQueryParams . from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response","title":"Use it"},{"location":"tutorial/dependencies/classes-as-dependencies/#type-annotation-vs-depends","text":"In the code above, you are declaring commons as: commons : CommonQueryParams = Depends ( CommonQueryParams ) The last CommonQueryParams , in: ... = Depends ( CommonQueryParams ) ...is what FastAPI will actually use to know what is the dependency. From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call. In this case, the first CommonQueryParams , in: commons : CommonQueryParams ... ...doesn't have any special meaning for FastAPI . FastAPI won't use it for data conversion, validation, etc. (as it is using the = Depends(CommonQueryParams) for that). You could actually write just: commons = Depends ( CommonQueryParams ) ..as in: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons = Depends ( CommonQueryParams )): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons , and then it can help you with code completion, type checks, etc:","title":"Type annotation vs Depends"},{"location":"tutorial/dependencies/classes-as-dependencies/#shortcut","text":"But you see that we are having some code repetition here, writing CommonQueryParams twice: commons : CommonQueryParams = Depends ( CommonQueryParams ) FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will \"call\" to create an instance of the class itself. For those specific cases, you can do the following: Instead of writing: commons : CommonQueryParams = Depends ( CommonQueryParams ) ...you write: commons : CommonQueryParams = Depends () So, you can declare the dependency as the type of the variable, and use Depends() as the \"default\" value (the value after the = ) for that function's parameter, without any parameter, instead of having to write the full class again inside of Depends(CommonQueryParams) . So, the same example would look like: from fastapi import Depends , FastAPI app = FastAPI () fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] class CommonQueryParams : def __init__ ( self , q : str = None , skip : int = 0 , limit : int = 100 ): self . q = q self . skip = skip self . limit = limit @app . get ( \"/items/\" ) async def read_items ( commons : CommonQueryParams = Depends ()): response = {} if commons . q : response . update ({ \"q\" : commons . q }) items = fake_items_db [ commons . skip : commons . skip + commons . limit ] response . update ({ \"items\" : items }) return response ...and FastAPI will know what to do. Tip If all that seems more confusing than helpful, disregard it, you don't need it. It is just a shortcut. Because FastAPI cares about helping you minimize code repetition.","title":"Shortcut"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/","text":"In some cases you don't really need the return value of a dependency inside your path operation function . Or the dependency doesn't return a value. But you still need it to be executed/solved. For those cases, instead of declaring a path operation function parameter with Depends , you can add a list of dependencies to the path operation decorator . Add dependencies to the path operation decorator \u00b6 The path operation decorator receives an optional argument dependencies . It should be a list of Depends() : from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }] These dependencies will be executed/solved the same way normal dependencies. But their value (if they return any) won't be passed to your path operation function . Tip Some editors check for unused function parameters, and show them as errors. Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors. It might also help avoiding confusion for new developers that see an un-used parameter in your code and could think it's unnecessary. Dependencies errors and return values \u00b6 You can use the same dependency functions you use normally. Dependency requirements \u00b6 They can declare request requirements (like headers) or other sub-dependencies: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }] Raise exceptions \u00b6 These dependencies can raise exceptions, the same as normal dependencies: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }] Return values \u00b6 And they can return values or not, the values won't be used. So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }] Dependencies for a group of path operations \u00b6 Later, when reading about how to structure bigger applications ( Bigger Applications - Multiple Files ), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations .","title":"Dependencies in path operation decorators"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#add-dependencies-to-the-path-operation-decorator","text":"The path operation decorator receives an optional argument dependencies . It should be a list of Depends() : from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }] These dependencies will be executed/solved the same way normal dependencies. But their value (if they return any) won't be passed to your path operation function . Tip Some editors check for unused function parameters, and show them as errors. Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors. It might also help avoiding confusion for new developers that see an un-used parameter in your code and could think it's unnecessary.","title":"Add dependencies to the path operation decorator"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#dependencies-errors-and-return-values","text":"You can use the same dependency functions you use normally.","title":"Dependencies errors and return values"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#dependency-requirements","text":"They can declare request requirements (like headers) or other sub-dependencies: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }]","title":"Dependency requirements"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#raise-exceptions","text":"These dependencies can raise exceptions, the same as normal dependencies: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }]","title":"Raise exceptions"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#return-values","text":"And they can return values or not, the values won't be used. So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed: from fastapi import Depends , FastAPI , Header , HTTPException app = FastAPI () async def verify_token ( x_token : str = Header ( ... )): if x_token != \"fake-super-secret-token\" : raise HTTPException ( status_code = 400 , detail = \"X-Token header invalid\" ) async def verify_key ( x_key : str = Header ( ... )): if x_key != \"fake-super-secret-key\" : raise HTTPException ( status_code = 400 , detail = \"X-Key header invalid\" ) return x_key @app . get ( \"/items/\" , dependencies = [ Depends ( verify_token ), Depends ( verify_key )]) async def read_items (): return [{ \"item\" : \"Foo\" }, { \"item\" : \"Bar\" }]","title":"Return values"},{"location":"tutorial/dependencies/dependencies-in-path-operation-decorators/#dependencies-for-a-group-of-path-operations","text":"Later, when reading about how to structure bigger applications ( Bigger Applications - Multiple Files ), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations .","title":"Dependencies for a group of path operations"},{"location":"tutorial/dependencies/dependencies-with-yield/","text":"Dependencies with yield \u00b6 FastAPI supports dependencies that do some extra steps after finishing . To do this, use yield instead of return , and write the extra steps after. Tip Make sure to use yield one single time. Info For this to work, you need to use Python 3.7 or above, or in Python 3.6 , install the \"backports\": pip install async-exit-stack async-generator This installs async-exit-stack and async-generator . Technical Details Any function that is valid to use with: @contextlib.contextmanager or @contextlib.asynccontextmanager would be valid to use as a FastAPI dependency. In fact, FastAPI uses those two decorators internally. A database dependency with yield \u00b6 For example, you could use this to create a database session and close it after finishing. Only the code prior to and including the yield statement is executed before sending a response: async def get_db (): db = DBSession () try : yield db finally : db . close () The yielded value is what is injected into path operations and other dependencies: async def get_db (): db = DBSession () try : yield db finally : db . close () The code following the yield statement is executed after the response has been delivered: async def get_db (): db = DBSession () try : yield db finally : db . close () Tip You can use async or normal functions. FastAPI will do the right thing with each, the same as with normal dependencies. A dependency with yield and try \u00b6 If you use a try block in a dependency with yield , you'll receive any exception that was thrown when using the dependency. For example, if some code at some point in the middle, in another dependency or in a path operation , made a database transaction \"rollback\" or create any other error, you will receive the exception in your dependency. So, you can look for that specific exception inside the dependency with except SomeException . In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not. async def get_db (): db = DBSession () try : yield db finally : db . close () Sub-dependencies with yield \u00b6 You can have sub-dependencies and \"trees\" of sub-dependencies of any size and shape, and any or all of them can use yield . FastAPI will make sure that the \"exit code\" in each dependency with yield is run in the correct order. For example, dependency_c can have a dependency on dependency_b , and dependency_b on dependency_a : from fastapi import Depends async def dependency_a (): dep_a = generate_dep_a () try : yield dep_a finally : dep_a . close () async def dependency_b ( dep_a = Depends ( dependency_a )): dep_b = generate_dep_b () try : yield dep_b finally : dep_b . close ( dep_a ) async def dependency_c ( dep_b = Depends ( dependency_b )): dep_c = generate_dep_c () try : yield dep_c finally : dep_c . close ( dep_b ) And all of them can use yield . In this case dependency_c , to execute its exit code, needs the value from dependency_b (here named dep_b ) to still be available. And, in turn, dependency_b needs the value from dependency_a (here named dep_a ) to be available for its exit code. from fastapi import Depends async def dependency_a (): dep_a = generate_dep_a () try : yield dep_a finally : dep_a . close () async def dependency_b ( dep_a = Depends ( dependency_a )): dep_b = generate_dep_b () try : yield dep_b finally : dep_b . close ( dep_a ) async def dependency_c ( dep_b = Depends ( dependency_b )): dep_c = generate_dep_c () try : yield dep_c finally : dep_c . close ( dep_b ) The same way, you could have dependencies with yield and return mixed. And you could have a single dependency that requires several other dependencies with yield , etc. You can have any combinations of dependencies that you want. FastAPI will make sure everything is run in the correct order. Technical Details This works thanks to Python's Context Managers . FastAPI uses them internally to achieve this. Dependencies with yield and HTTPException \u00b6 You saw that you can use dependencies with yield and have try blocks that catch exceptions. It might be tempting to raise an HTTPException or similar in the exit code, after the yield . But it won't work . The exit code in dependencies with yield is executed after Exception Handlers . There's nothing catching exceptions thrown by your dependencies in the exit code (after the yield ). So, if you raise an HTTPException after the yield , the default (or any custom) exception handler that catches HTTPException s and returns an HTTP 400 response won't be there to catch that exception anymore. This is what allows anything set in the dependency (e.g. a DB session) to, for example, be used by background tasks. Background tasks are run after the response has been sent. So there's no way to raise an HTTPException because there's not even a way to change the response that is already sent . But if a background task creates a DB error, at least you can rollback or cleanly close the session in the dependency with yield , and maybe log the error or report it to a remote tracking system. If you have some code that you know could raise an exception, do the most normal/\"Pythonic\" thing and add a try block in that section of the code. If you have custom exceptions that you would like to handle before returning the response and possibly modifying the response, maybe even raising an HTTPException , create a Custom Exception Handler . Tip You can still raise exceptions including HTTPException before the yield . But not after. The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code. sequenceDiagram participant client as Client participant handler as Exception handler participant dep as Dep with yield participant operation as Path Operation participant tasks as Background tasks Note over client,tasks: Can raise exception for dependency, handled after response is sent Note over client,operation: Can raise HTTPException and can change the response client ->> dep: Start request Note over dep: Run code up to yield opt raise dep -->> handler: Raise HTTPException handler -->> client: HTTP error response dep -->> dep: Raise other exception end dep ->> operation: Run dependency, e.g. DB session opt raise operation -->> handler: Raise HTTPException handler -->> client: HTTP error response operation -->> dep: Raise other exception end operation ->> client: Return response to client Note over client,operation: Response is already sent, can't change it anymore opt Tasks operation -->> tasks: Send background tasks end opt Raise other exception tasks -->> dep: Raise other exception end Note over dep: After yield opt Handle other exception dep -->> dep: Handle exception, can't change response. E.g. close DB session. end Info Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation . After one of those responses is sent, no other response can be sent. Tip This diagram shows HTTPException , but you could also raise any other exception for which you create a Custom Exception Handler . And that exception would be handled by that custom exception handler instead of the dependency exit code. But if you raise an exception that is not handled by the exception handlers, it will be handled by the exit code of the dependency. Context Managers \u00b6 What are \"Context Managers\" \u00b6 \"Context Managers\" are any of those Python objects that you can use in a with statement. For example, you can use with to read a file : with open ( \"./somefile.txt\" ) as f : contents = f . read () print ( contents ) Underneath, the open(\"./somefile.txt\") creates an object that is a called a \"Context Manager\". When the with block finishes, it makes sure to close the file, even if there were exceptions. When you create a dependency with yield , FastAPI will internally convert it to a context manager, and combine it with some other related tools. Using context managers in dependencies with yield \u00b6 Warning This is, more or less, an \"advanced\" idea. If you are just starting with FastAPI you might want to skip it for now. In Python, you can create Context Managers by creating a class with two methods: __enter__() and __exit__() . You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function: class MySuperContextManager : def __init__ ( self ): self . db = DBSession () def __enter__ ( self ): return self . db def __exit__ ( self , exc_type , exc_value , traceback ): self . db . close () async def get_db (): with MySuperContextManager () as db : yield db Tip Another way to create a context manager is with: @contextlib.contextmanager or @contextlib.asynccontextmanager using them to decorate a function with a single yield . That's what FastAPI uses internally for dependencies with yield . But you don't have to use the decorators for FastAPI dependencies (and you shouldn't). FastAPI will do it for you internally.","title":"Dependencies with yield"},{"location":"tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield","text":"FastAPI supports dependencies that do some extra steps after finishing . To do this, use yield instead of return , and write the extra steps after. Tip Make sure to use yield one single time. Info For this to work, you need to use Python 3.7 or above, or in Python 3.6 , install the \"backports\": pip install async-exit-stack async-generator This installs async-exit-stack and async-generator . Technical Details Any function that is valid to use with: @contextlib.contextmanager or @contextlib.asynccontextmanager would be valid to use as a FastAPI dependency. In fact, FastAPI uses those two decorators internally.","title":"Dependencies with yield"},{"location":"tutorial/dependencies/dependencies-with-yield/#a-database-dependency-with-yield","text":"For example, you could use this to create a database session and close it after finishing. Only the code prior to and including the yield statement is executed before sending a response: async def get_db (): db = DBSession () try : yield db finally : db . close () The yielded value is what is injected into path operations and other dependencies: async def get_db (): db = DBSession () try : yield db finally : db . close () The code following the yield statement is executed after the response has been delivered: async def get_db (): db = DBSession () try : yield db finally : db . close () Tip You can use async or normal functions. FastAPI will do the right thing with each, the same as with normal dependencies.","title":"A database dependency with yield"},{"location":"tutorial/dependencies/dependencies-with-yield/#a-dependency-with-yield-and-try","text":"If you use a try block in a dependency with yield , you'll receive any exception that was thrown when using the dependency. For example, if some code at some point in the middle, in another dependency or in a path operation , made a database transaction \"rollback\" or create any other error, you will receive the exception in your dependency. So, you can look for that specific exception inside the dependency with except SomeException . In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not. async def get_db (): db = DBSession () try : yield db finally : db . close ()","title":"A dependency with yield and try"},{"location":"tutorial/dependencies/dependencies-with-yield/#sub-dependencies-with-yield","text":"You can have sub-dependencies and \"trees\" of sub-dependencies of any size and shape, and any or all of them can use yield . FastAPI will make sure that the \"exit code\" in each dependency with yield is run in the correct order. For example, dependency_c can have a dependency on dependency_b , and dependency_b on dependency_a : from fastapi import Depends async def dependency_a (): dep_a = generate_dep_a () try : yield dep_a finally : dep_a . close () async def dependency_b ( dep_a = Depends ( dependency_a )): dep_b = generate_dep_b () try : yield dep_b finally : dep_b . close ( dep_a ) async def dependency_c ( dep_b = Depends ( dependency_b )): dep_c = generate_dep_c () try : yield dep_c finally : dep_c . close ( dep_b ) And all of them can use yield . In this case dependency_c , to execute its exit code, needs the value from dependency_b (here named dep_b ) to still be available. And, in turn, dependency_b needs the value from dependency_a (here named dep_a ) to be available for its exit code. from fastapi import Depends async def dependency_a (): dep_a = generate_dep_a () try : yield dep_a finally : dep_a . close () async def dependency_b ( dep_a = Depends ( dependency_a )): dep_b = generate_dep_b () try : yield dep_b finally : dep_b . close ( dep_a ) async def dependency_c ( dep_b = Depends ( dependency_b )): dep_c = generate_dep_c () try : yield dep_c finally : dep_c . close ( dep_b ) The same way, you could have dependencies with yield and return mixed. And you could have a single dependency that requires several other dependencies with yield , etc. You can have any combinations of dependencies that you want. FastAPI will make sure everything is run in the correct order. Technical Details This works thanks to Python's Context Managers . FastAPI uses them internally to achieve this.","title":"Sub-dependencies with yield"},{"location":"tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-httpexception","text":"You saw that you can use dependencies with yield and have try blocks that catch exceptions. It might be tempting to raise an HTTPException or similar in the exit code, after the yield . But it won't work . The exit code in dependencies with yield is executed after Exception Handlers . There's nothing catching exceptions thrown by your dependencies in the exit code (after the yield ). So, if you raise an HTTPException after the yield , the default (or any custom) exception handler that catches HTTPException s and returns an HTTP 400 response won't be there to catch that exception anymore. This is what allows anything set in the dependency (e.g. a DB session) to, for example, be used by background tasks. Background tasks are run after the response has been sent. So there's no way to raise an HTTPException because there's not even a way to change the response that is already sent . But if a background task creates a DB error, at least you can rollback or cleanly close the session in the dependency with yield , and maybe log the error or report it to a remote tracking system. If you have some code that you know could raise an exception, do the most normal/\"Pythonic\" thing and add a try block in that section of the code. If you have custom exceptions that you would like to handle before returning the response and possibly modifying the response, maybe even raising an HTTPException , create a Custom Exception Handler . Tip You can still raise exceptions including HTTPException before the yield . But not after. The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code. sequenceDiagram participant client as Client participant handler as Exception handler participant dep as Dep with yield participant operation as Path Operation participant tasks as Background tasks Note over client,tasks: Can raise exception for dependency, handled after response is sent Note over client,operation: Can raise HTTPException and can change the response client ->> dep: Start request Note over dep: Run code up to yield opt raise dep -->> handler: Raise HTTPException handler -->> client: HTTP error response dep -->> dep: Raise other exception end dep ->> operation: Run dependency, e.g. DB session opt raise operation -->> handler: Raise HTTPException handler -->> client: HTTP error response operation -->> dep: Raise other exception end operation ->> client: Return response to client Note over client,operation: Response is already sent, can't change it anymore opt Tasks operation -->> tasks: Send background tasks end opt Raise other exception tasks -->> dep: Raise other exception end Note over dep: After yield opt Handle other exception dep -->> dep: Handle exception, can't change response. E.g. close DB session. end Info Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation . After one of those responses is sent, no other response can be sent. Tip This diagram shows HTTPException , but you could also raise any other exception for which you create a Custom Exception Handler . And that exception would be handled by that custom exception handler instead of the dependency exit code. But if you raise an exception that is not handled by the exception handlers, it will be handled by the exit code of the dependency.","title":"Dependencies with yield and HTTPException"},{"location":"tutorial/dependencies/dependencies-with-yield/#context-managers","text":"","title":"Context Managers"},{"location":"tutorial/dependencies/dependencies-with-yield/#what-are-context-managers","text":"\"Context Managers\" are any of those Python objects that you can use in a with statement. For example, you can use with to read a file : with open ( \"./somefile.txt\" ) as f : contents = f . read () print ( contents ) Underneath, the open(\"./somefile.txt\") creates an object that is a called a \"Context Manager\". When the with block finishes, it makes sure to close the file, even if there were exceptions. When you create a dependency with yield , FastAPI will internally convert it to a context manager, and combine it with some other related tools.","title":"What are \"Context Managers\""},{"location":"tutorial/dependencies/dependencies-with-yield/#using-context-managers-in-dependencies-with-yield","text":"Warning This is, more or less, an \"advanced\" idea. If you are just starting with FastAPI you might want to skip it for now. In Python, you can create Context Managers by creating a class with two methods: __enter__() and __exit__() . You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function: class MySuperContextManager : def __init__ ( self ): self . db = DBSession () def __enter__ ( self ): return self . db def __exit__ ( self , exc_type , exc_value , traceback ): self . db . close () async def get_db (): with MySuperContextManager () as db : yield db Tip Another way to create a context manager is with: @contextlib.contextmanager or @contextlib.asynccontextmanager using them to decorate a function with a single yield . That's what FastAPI uses internally for dependencies with yield . But you don't have to use the decorators for FastAPI dependencies (and you shouldn't). FastAPI will do it for you internally.","title":"Using context managers in dependencies with yield"},{"location":"tutorial/dependencies/sub-dependencies/","text":"You can create dependencies that have sub-dependencies . They can be as deep as you need them to be. FastAPI will take care of solving them. First dependency \"dependable\" \u00b6 You could create a first dependency (\"dependable\") like: from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } It declares an optional query parameter q as a str , and then it just returns it. This is quite simple (not very useful), but will help us focus on how the sub-dependencies work. Second dependency, \"dependable\" and \"dependant\" \u00b6 Then you can create another dependency function (a \"dependable\") that at the same time declares a dependency of its own (so it is a \"dependant\" too): from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } Let's focus on the parameters declared: Even though this function is a dependency (\"dependable\") itself, it also declares another dependency (it \"depends\" on something else). It depends on the query_extractor , and assigns the value returned by it to the parameter q . It also declares an optional last_query cookie, as a str . Let's imagine that if the user didn't provide any query q , we just use the last query used, that we had saved to a cookie before. Use the dependency \u00b6 Then we can use the dependency with: from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } Info Notice that we are only declaring one dependency in the path operation function , the query_or_cookie_extractor . But FastAPI will know that it has to solve query_extractor first, to pass the results of that to query_or_cookie_extractor while calling it. graph TB query_extractor([\"query_extractor\"]) query_or_cookie_extractor([\"query_or_cookie_extractor\"]) read_query[\"/items/\"] query_extractor --> query_or_cookie_extractor --> read_query Using the same dependency multiple times \u00b6 If one of your dependencies is declared multiple times for the same path operation , for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request. And it will save the returned value in a \"cache\" and pass it to all the \"dependants\" that need it in that specific request, instead of calling the dependency multiple times for the same request. In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the \"cached\" value, you can set the parameter use_cache=False when using Depends : async def needy_dependency ( fresh_value : str = Depends ( get_value , use_cache = False )): return { \"fresh_value\" : fresh_value } Recap \u00b6 Apart from all the fancy words used here, the Dependency Injection system is quite simple. Just functions that look the same as the path operation functions . But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency \"graphs\" (trees). Tip All this might not seem as useful with these simple examples. But you will see how useful it is in the chapters about security . And you will also see the amounts of code it will save you.","title":"Sub-dependencies"},{"location":"tutorial/dependencies/sub-dependencies/#first-dependency-dependable","text":"You could create a first dependency (\"dependable\") like: from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } It declares an optional query parameter q as a str , and then it just returns it. This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.","title":"First dependency \"dependable\""},{"location":"tutorial/dependencies/sub-dependencies/#second-dependency-dependable-and-dependant","text":"Then you can create another dependency function (a \"dependable\") that at the same time declares a dependency of its own (so it is a \"dependant\" too): from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } Let's focus on the parameters declared: Even though this function is a dependency (\"dependable\") itself, it also declares another dependency (it \"depends\" on something else). It depends on the query_extractor , and assigns the value returned by it to the parameter q . It also declares an optional last_query cookie, as a str . Let's imagine that if the user didn't provide any query q , we just use the last query used, that we had saved to a cookie before.","title":"Second dependency, \"dependable\" and \"dependant\""},{"location":"tutorial/dependencies/sub-dependencies/#use-the-dependency","text":"Then we can use the dependency with: from fastapi import Cookie , Depends , FastAPI app = FastAPI () def query_extractor ( q : str = None ): return q def query_or_cookie_extractor ( q : str = Depends ( query_extractor ), last_query : str = Cookie ( None ) ): if not q : return last_query return q @app . get ( \"/items/\" ) async def read_query ( query_or_default : str = Depends ( query_or_cookie_extractor )): return { \"q_or_cookie\" : query_or_default } Info Notice that we are only declaring one dependency in the path operation function , the query_or_cookie_extractor . But FastAPI will know that it has to solve query_extractor first, to pass the results of that to query_or_cookie_extractor while calling it. graph TB query_extractor([\"query_extractor\"]) query_or_cookie_extractor([\"query_or_cookie_extractor\"]) read_query[\"/items/\"] query_extractor --> query_or_cookie_extractor --> read_query","title":"Use the dependency"},{"location":"tutorial/dependencies/sub-dependencies/#using-the-same-dependency-multiple-times","text":"If one of your dependencies is declared multiple times for the same path operation , for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request. And it will save the returned value in a \"cache\" and pass it to all the \"dependants\" that need it in that specific request, instead of calling the dependency multiple times for the same request. In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the \"cached\" value, you can set the parameter use_cache=False when using Depends : async def needy_dependency ( fresh_value : str = Depends ( get_value , use_cache = False )): return { \"fresh_value\" : fresh_value }","title":"Using the same dependency multiple times"},{"location":"tutorial/dependencies/sub-dependencies/#recap","text":"Apart from all the fancy words used here, the Dependency Injection system is quite simple. Just functions that look the same as the path operation functions . But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency \"graphs\" (trees). Tip All this might not seem as useful with these simple examples. But you will see how useful it is in the chapters about security . And you will also see the amounts of code it will save you.","title":"Recap"},{"location":"tutorial/security/","text":"There are many ways to handle security, authentication and authorization. And it normally is a complex and \"difficult\" topic. In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written). FastAPI provides several tools to help you deal with Security easily, rapidly, in a standard way, without having to study and learn all the security specifications. But first, let's check some small concepts. In a hurry? \u00b6 If you don't care about any of these terms and you just need to add security with authentication based on username and password right now , skip to the next chapters. OAuth2 \u00b6 OAuth2 is a specification that defines several ways to handle authentication and authorization. It is quite an extensive specification and covers several complex use cases. It includes ways to authenticate using a \"third party\". That's what all the systems with \"login with Facebook, Google, Twitter, GitHub\" use underneath. OAuth 1 \u00b6 There was an OAuth 1, which is very different from OAuth2, and more complex, as it included directly specifications on how to encrypt the communication. It is not very popular or used nowadays. OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS. Tip In the section about deployment you will see how to set up HTTPS for free, using Traefik and Let's Encrypt. OpenID Connect \u00b6 OpenID Connect is another specification, based on OAuth2 . It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable. For example, Google login uses OpenID Connect (which underneath uses OAuth2). But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2. OpenID (not \"OpenID Connect\") \u00b6 There was also an \"OpenID\" specification. That tried to solve the same thing as OpenID Connect , but was not based on OAuth2. So, it was a complete additional system. It is not very popular or used nowadays. OpenAPI \u00b6 OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation). FastAPI is based on OpenAPI . That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc. OpenAPI has a way to define multiple security \"schemes\". By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems. OpenAPI defines the following security schemes: apiKey : an application specific key that can come from: A query parameter. A header. A cookie. http : standard HTTP authentication systems, including: bearer : a header Authorization with a value of Bearer plus a token. This is inherited from OAuth2. HTTP Basic authentication. HTTP Digest, etc. oauth2 : all the OAuth2 ways to handle security (called \"flows\"). Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc): implicit clientCredentials authorizationCode But there is one specific \"flow\" that can be perfectly used for handling authentication in the same application directly: password : some next chapters will cover examples of this. openIdConnect : has a way to define how to discover OAuth2 authentication data automatically. This automatic discovery is what is defined in the OpenID Connect specification. Tip Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy. The most complex problem is building an authentication/authorization provider like those, but FastAPI gives you the tools to do it easily, while doing the heavy lifting for you. FastAPI utilities \u00b6 FastAPI provides several tools for each of these security schemes in the fastapi.security module that simplify using these security mechanisms. In the next chapters you will see how to add security to your API using those tools provided by FastAPI . And you will also see how it gets automatically integrated into the interactive documentation system.","title":"Security Intro"},{"location":"tutorial/security/#in-a-hurry","text":"If you don't care about any of these terms and you just need to add security with authentication based on username and password right now , skip to the next chapters.","title":"In a hurry?"},{"location":"tutorial/security/#oauth2","text":"OAuth2 is a specification that defines several ways to handle authentication and authorization. It is quite an extensive specification and covers several complex use cases. It includes ways to authenticate using a \"third party\". That's what all the systems with \"login with Facebook, Google, Twitter, GitHub\" use underneath.","title":"OAuth2"},{"location":"tutorial/security/#oauth-1","text":"There was an OAuth 1, which is very different from OAuth2, and more complex, as it included directly specifications on how to encrypt the communication. It is not very popular or used nowadays. OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS. Tip In the section about deployment you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.","title":"OAuth 1"},{"location":"tutorial/security/#openid-connect","text":"OpenID Connect is another specification, based on OAuth2 . It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable. For example, Google login uses OpenID Connect (which underneath uses OAuth2). But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.","title":"OpenID Connect"},{"location":"tutorial/security/#openid-not-openid-connect","text":"There was also an \"OpenID\" specification. That tried to solve the same thing as OpenID Connect , but was not based on OAuth2. So, it was a complete additional system. It is not very popular or used nowadays.","title":"OpenID (not \"OpenID Connect\")"},{"location":"tutorial/security/#openapi","text":"OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation). FastAPI is based on OpenAPI . That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc. OpenAPI has a way to define multiple security \"schemes\". By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems. OpenAPI defines the following security schemes: apiKey : an application specific key that can come from: A query parameter. A header. A cookie. http : standard HTTP authentication systems, including: bearer : a header Authorization with a value of Bearer plus a token. This is inherited from OAuth2. HTTP Basic authentication. HTTP Digest, etc. oauth2 : all the OAuth2 ways to handle security (called \"flows\"). Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc): implicit clientCredentials authorizationCode But there is one specific \"flow\" that can be perfectly used for handling authentication in the same application directly: password : some next chapters will cover examples of this. openIdConnect : has a way to define how to discover OAuth2 authentication data automatically. This automatic discovery is what is defined in the OpenID Connect specification. Tip Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy. The most complex problem is building an authentication/authorization provider like those, but FastAPI gives you the tools to do it easily, while doing the heavy lifting for you.","title":"OpenAPI"},{"location":"tutorial/security/#fastapi-utilities","text":"FastAPI provides several tools for each of these security schemes in the fastapi.security module that simplify using these security mechanisms. In the next chapters you will see how to add security to your API using those tools provided by FastAPI . And you will also see how it gets automatically integrated into the interactive documentation system.","title":"FastAPI utilities"},{"location":"tutorial/security/first-steps/","text":"Let's imagine that you have your backend API in some domain. And you have a frontend in another domain or in a different path of the same domain (or in a mobile application). And you want to have a way for the frontend to authenticate with the backend, using a username and password . We can use OAuth2 to build that with FastAPI . But let's save you the time of reading the full long specification just to find those little pieces of information you need. Let's use the tools provided by FastAPI to handle security. How it looks \u00b6 Let's first just use the code and see how it works, and then we'll come back to understand what's happening. Create main.py \u00b6 Copy the example in a file main.py : from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } Run it \u00b6 Info First install python-multipart . E.g. pip install python-multipart . This is because OAuth2 uses \"form data\" for sending the username and password . Run the example with: uvicorn main:app --reload Check it \u00b6 Go to the interactive docs at: http://127.0.0.1:8000/docs . You will see something like this: Authorize button! You already have a shinny new \"Authorize\" button. And your path operation has a little lock in the top-right corner that you can click. And if you click it, you have a little authorization form to type a username and password (and other optional fields): Note It doesn't matter what you type in the form, it won't work yet. But we'll get there. This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API. It can be used by the frontend team (that can also be yourself). It can be used by third party applications and systems. And it can also be used by yourself, to debug, check and test the same application. The password flow \u00b6 Now let's go back a bit and understand what is all that. The password \"flow\" is one of the ways (\"flows\") defined in OAuth2, to handle security and authentication. OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user. But in this case, the same FastAPI application will handle the API and the authentication. So, let's review it from that simplified point of view: The user types his username and password in the frontend, and hits Enter . The frontend (running in the user's browser) sends that username and password to a specific URL in our API. The API checks that username and password , and responds with a \"token\". A \"token\" is just a string with some content that we can use later to verify this user. Normally, a token is set to expire after some time. So, the user will have to login again at some point later. And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases). The frontend stores that token temporarily somewhere. The user clicks in the frontend to go to another section of the frontend web app. The frontend needs to fetch some more data from the API. But it needs authentication for that specific endpoint. So, to authenticate with our API, it sends a header Authorization with a value of Bearer plus the token. If the token contains foobar , the content of the Authorization header would be: Bearer foobar . FastAPI 's OAuth2PasswordBearer \u00b6 FastAPI provides several tools, at different levels of abstraction, to implement these security features. In this example we are going to use OAuth2 , with the Password flow, using a Bearer token. Info A \"bearer\" token is not the only option. But it's the best one for our use case. And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that suits better your needs. In that case, FastAPI also provides you with the tools to build it. OAuth2PasswordBearer is a class that we create passing a parameter of the URL in where the client (the frontend running in the user's browser) can use to send the username and password and get a token. from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } It doesn't create that endpoint / path operation , but declares that that URL is the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems. Info If you are a very strict \"Pythonista\" you might dislike the style of the parameter name tokenUrl instead of token_url . That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it. The oauth2_scheme variable is an instance of OAuth2PasswordBearer , but it is also a \"callable\". It could be called as: oauth2_scheme ( some , parameters ) So, it can be used with Depends . Use it \u00b6 Now you can pass that oauth2_scheme in a dependency with Depends . from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } This dependency will provide a str that is assigned to the parameter token of the path operation function . FastAPI will know that it can use this dependency to define a \"security scheme\" in the OpenAPI schema (and the automatic API docs). Technical Details FastAPI will know that it can use the class OAuth2PasswordBearer (declared in a dependency) to define the security scheme in OpenAPI because it inherits from fastapi.security.oauth2.OAuth2 , which in turn inherits from fastapi.security.base.SecurityBase . All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from SecurityBase , that's how FastAPI can know how to integrate them in OpenAPI. What it does \u00b6 It will go and look in the request for that Authorization header, check if the value is Bearer plus some token, and will return the token as a str . If it doesn't see an Authorization header, or the value doesn't have a Bearer token, it will respond with a 401 status code error ( UNAUTHORIZED ) directly. You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a str in that token. You can try it already in the interactive docs: We are not verifying the validity of the token yet, but that's a start already. Recap \u00b6 So, in just 3 or 4 extra lines, you already have some primitive form of security.","title":"First Steps"},{"location":"tutorial/security/first-steps/#how-it-looks","text":"Let's first just use the code and see how it works, and then we'll come back to understand what's happening.","title":"How it looks"},{"location":"tutorial/security/first-steps/#create-mainpy","text":"Copy the example in a file main.py : from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token }","title":"Create main.py"},{"location":"tutorial/security/first-steps/#run-it","text":"Info First install python-multipart . E.g. pip install python-multipart . This is because OAuth2 uses \"form data\" for sending the username and password . Run the example with: uvicorn main:app --reload","title":"Run it"},{"location":"tutorial/security/first-steps/#check-it","text":"Go to the interactive docs at: http://127.0.0.1:8000/docs . You will see something like this: Authorize button! You already have a shinny new \"Authorize\" button. And your path operation has a little lock in the top-right corner that you can click. And if you click it, you have a little authorization form to type a username and password (and other optional fields): Note It doesn't matter what you type in the form, it won't work yet. But we'll get there. This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API. It can be used by the frontend team (that can also be yourself). It can be used by third party applications and systems. And it can also be used by yourself, to debug, check and test the same application.","title":"Check it"},{"location":"tutorial/security/first-steps/#the-password-flow","text":"Now let's go back a bit and understand what is all that. The password \"flow\" is one of the ways (\"flows\") defined in OAuth2, to handle security and authentication. OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user. But in this case, the same FastAPI application will handle the API and the authentication. So, let's review it from that simplified point of view: The user types his username and password in the frontend, and hits Enter . The frontend (running in the user's browser) sends that username and password to a specific URL in our API. The API checks that username and password , and responds with a \"token\". A \"token\" is just a string with some content that we can use later to verify this user. Normally, a token is set to expire after some time. So, the user will have to login again at some point later. And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases). The frontend stores that token temporarily somewhere. The user clicks in the frontend to go to another section of the frontend web app. The frontend needs to fetch some more data from the API. But it needs authentication for that specific endpoint. So, to authenticate with our API, it sends a header Authorization with a value of Bearer plus the token. If the token contains foobar , the content of the Authorization header would be: Bearer foobar .","title":"The password flow"},{"location":"tutorial/security/first-steps/#fastapis-oauth2passwordbearer","text":"FastAPI provides several tools, at different levels of abstraction, to implement these security features. In this example we are going to use OAuth2 , with the Password flow, using a Bearer token. Info A \"bearer\" token is not the only option. But it's the best one for our use case. And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that suits better your needs. In that case, FastAPI also provides you with the tools to build it. OAuth2PasswordBearer is a class that we create passing a parameter of the URL in where the client (the frontend running in the user's browser) can use to send the username and password and get a token. from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } It doesn't create that endpoint / path operation , but declares that that URL is the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems. Info If you are a very strict \"Pythonista\" you might dislike the style of the parameter name tokenUrl instead of token_url . That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it. The oauth2_scheme variable is an instance of OAuth2PasswordBearer , but it is also a \"callable\". It could be called as: oauth2_scheme ( some , parameters ) So, it can be used with Depends .","title":"FastAPI's OAuth2PasswordBearer"},{"location":"tutorial/security/first-steps/#use-it","text":"Now you can pass that oauth2_scheme in a dependency with Depends . from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } This dependency will provide a str that is assigned to the parameter token of the path operation function . FastAPI will know that it can use this dependency to define a \"security scheme\" in the OpenAPI schema (and the automatic API docs). Technical Details FastAPI will know that it can use the class OAuth2PasswordBearer (declared in a dependency) to define the security scheme in OpenAPI because it inherits from fastapi.security.oauth2.OAuth2 , which in turn inherits from fastapi.security.base.SecurityBase . All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from SecurityBase , that's how FastAPI can know how to integrate them in OpenAPI.","title":"Use it"},{"location":"tutorial/security/first-steps/#what-it-does","text":"It will go and look in the request for that Authorization header, check if the value is Bearer plus some token, and will return the token as a str . If it doesn't see an Authorization header, or the value doesn't have a Bearer token, it will respond with a 401 status code error ( UNAUTHORIZED ) directly. You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a str in that token. You can try it already in the interactive docs: We are not verifying the validity of the token yet, but that's a start already.","title":"What it does"},{"location":"tutorial/security/first-steps/#recap","text":"So, in just 3 or 4 extra lines, you already have some primitive form of security.","title":"Recap"},{"location":"tutorial/security/get-current-user/","text":"In the previous chapter the security system (which is based on the dependency injection system) was giving the path operation function a token as a str : from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) @app . get ( \"/items/\" ) async def read_items ( token : str = Depends ( oauth2_scheme )): return { \"token\" : token } But that is still not that useful. Let's make it give us the current user. Create a user model \u00b6 First, let's create a Pydantic user model. The same way we use Pydantic to declare bodies, we can use it anywhere else: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Create a get_current_user dependency \u00b6 Let's create a dependency get_current_user . Remember that dependencies can have sub-dependencies? get_current_user will have a dependency with the same oauth2_scheme we created before. The same as we were doing before in the path operation directly, our new dependency get_current_user will receive a token as a str from the sub-dependency oauth2_scheme : from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Get the user \u00b6 get_current_user will use a (fake) utility function we created, that takes a token as a str and returns our Pydantic User model: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Inject the current user \u00b6 So now we can use the same Depends with our get_current_user in the path operation : from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Notice that we declare the type of current_user as the Pydantic model User . This will help us inside of the function with all the completion and type checks. Tip You might remember that request bodies are also declared with Pydantic models. Here FastAPI won't get confused because you are using Depends . Check The way this dependency system is designed allows us to have different dependencies (different \"dependables\") that all return a User model. We are not restricted to having only one dependency that can return that type of data. Other models \u00b6 You can now get the current user directly in the path operation functions and deal with the security mechanisms at the Dependency Injection level, using Depends . And you can use any model or data for the security requirements (in this case, a Pydantic model User ). But you are not restricted to using some specific data model, class or type. Do you want to have an id and email and not have any username in your model? Sure. You can use these same tools. Do you want to just have a str ? Or just a dict ? Or a database class model instance directly? It all works the same way. You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same. Just use any kind of model, any kind of class, any kind of database that you need for your application. FastAPI has you covered with the dependency injection system. Code size \u00b6 This example might seem verbose. Have in mind that we are mixing security, data models utility functions and path operations in the same file. But here's the key point. The security and dependency injection stuff is written once. And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility. But you can have thousands of endpoints ( path operations ) using the same security system. And all of them (or any portion of them that you want) can take the advantage of re-using these dependencies or any other dependencies you create. And all these thousands of path operations can be as small as 3 lines: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Recap \u00b6 You can now get the current user directly in your path operation function . We are already halfway there. We just need to add a path operation for the user/client to actually send the username and password . That comes next.","title":"Get Current User"},{"location":"tutorial/security/get-current-user/#create-a-user-model","text":"First, let's create a Pydantic user model. The same way we use Pydantic to declare bodies, we can use it anywhere else: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user","title":"Create a user model"},{"location":"tutorial/security/get-current-user/#create-a-get_current_user-dependency","text":"Let's create a dependency get_current_user . Remember that dependencies can have sub-dependencies? get_current_user will have a dependency with the same oauth2_scheme we created before. The same as we were doing before in the path operation directly, our new dependency get_current_user will receive a token as a str from the sub-dependency oauth2_scheme : from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user","title":"Create a get_current_user dependency"},{"location":"tutorial/security/get-current-user/#get-the-user","text":"get_current_user will use a (fake) utility function we created, that takes a token as a str and returns our Pydantic User model: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user","title":"Get the user"},{"location":"tutorial/security/get-current-user/#inject-the-current-user","text":"So now we can use the same Depends with our get_current_user in the path operation : from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user Notice that we declare the type of current_user as the Pydantic model User . This will help us inside of the function with all the completion and type checks. Tip You might remember that request bodies are also declared with Pydantic models. Here FastAPI won't get confused because you are using Depends . Check The way this dependency system is designed allows us to have different dependencies (different \"dependables\") that all return a User model. We are not restricted to having only one dependency that can return that type of data.","title":"Inject the current user"},{"location":"tutorial/security/get-current-user/#other-models","text":"You can now get the current user directly in the path operation functions and deal with the security mechanisms at the Dependency Injection level, using Depends . And you can use any model or data for the security requirements (in this case, a Pydantic model User ). But you are not restricted to using some specific data model, class or type. Do you want to have an id and email and not have any username in your model? Sure. You can use these same tools. Do you want to just have a str ? Or just a dict ? Or a database class model instance directly? It all works the same way. You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same. Just use any kind of model, any kind of class, any kind of database that you need for your application. FastAPI has you covered with the dependency injection system.","title":"Other models"},{"location":"tutorial/security/get-current-user/#code-size","text":"This example might seem verbose. Have in mind that we are mixing security, data models utility functions and path operations in the same file. But here's the key point. The security and dependency injection stuff is written once. And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility. But you can have thousands of endpoints ( path operations ) using the same security system. And all of them (or any portion of them that you want) can take the advantage of re-using these dependencies or any other dependencies you create. And all these thousands of path operations can be as small as 3 lines: from typing import Optional from fastapi import Depends , FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI () oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : Optional [ str ] = None full_name : Optional [ str ] = None disabled : Optional [ bool ] = None def fake_decode_token ( token ): return User ( username = token + \"fakedecoded\" , email = \"john@example.com\" , full_name = \"John Doe\" ) async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) return user @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_user )): return current_user","title":"Code size"},{"location":"tutorial/security/get-current-user/#recap","text":"You can now get the current user directly in your path operation function . We are already halfway there. We just need to add a path operation for the user/client to actually send the username and password . That comes next.","title":"Recap"},{"location":"tutorial/security/oauth2-jwt/","text":"Now that we have all the security flow, let's make the application actually secure, using JWT tokens and secure password hashing. This code is something you can actually use in your application, save the password hashes in your database, etc. We are going to start from where we left in the previous chapter and increment it. About JWT \u00b6 JWT means \"JSON Web Tokens\". It's a standard to codify a JSON object in a long dense string without spaces. It looks like this: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c It is not encrypted, so, anyone could recover the information from the contents. But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it. That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know she/he is still signed into your system. And after a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match. If you want to play with JWT tokens and see how they work, check https://jwt.io . Install PyJWT \u00b6 We need to install PyJWT to generate and verify the JWT tokens in Python: pip install pyjwt Password hashing \u00b6 \"Hashing\" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password. Why use password hashing \u00b6 If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous). Install passlib \u00b6 PassLib is a great Python package to handle password hashes. It supports many secure hashing algorithms and utilities to work with them. The recommended algorithm is \"Bcrypt\". So, install PassLib with Bcrypt: pip install passlib [ bcrypt ] Tip With passlib , you could even configure it to be able to read passwords created by Django , a Flask security plug-in or many others. So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database. And your users would be able to login from your Django app or from your FastAPI app, at the same time. Hash and verify the passwords \u00b6 Import the tools we need from passlib . Create a PassLib \"context\". This is what will be used to hash and verify passwords. Tip The PassLib context also has functionality to use different hashing algorithms, including deprecate old ones only to allow verifying them, etc. For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt. And be compatible with all of them at the same time. Create a utility function to hash a password coming from the user. And another utility to verify if a received password matches the hash stored. And another one to authenticate and return a user. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] Note If you check the new (fake) database fake_users_db , you will see how the hashed password looks like now: \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" . Handle JWT tokens \u00b6 Import the modules installed. Create a random secret key that will be used to sign the JWT tokens. To generate a secure random secret key use the command: openssl rand -hex 32 And copy the output to the variable SECRET_KEY (don't use the one in the example). Create a variable ALGORITHM with the algorithm used to sign the JWT token and set it to \"HS256\" . Create a variable for the expiration of the token. Define a Pydantic Model that will be used in the token endpoint for the response. Create a utility function to generate a new access token. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] Update the dependencies \u00b6 Update get_current_user to receive the same token as before, but this time, using JWT tokens. Decode the received token, verify it, and return the current user. If the token is invalid, return an HTTP error right away. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] Update the /token path operation \u00b6 Create a timedelta with the expiration time of the token. Create a real JWT access token and return it. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] Technical details about the JWT \"subject\" sub \u00b6 The JWT specification says that there's a key sub , with the subject of the token. It's optional to use it, but that's where you would put the user's identification, so we are using it here. JWT might be used for other things apart from identifying a user and allowing him to perform operations directly on your API. For example, you could identify a \"car\" or a \"blog post\". Then you could add permissions about that entity, like \"drive\" (for the car) or \"edit\" (for the blog). And then, you could give that JWT token to a user (or bot), and he could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that. Using these ideas, JWT can be used for way more sophisticated scenarios. In those cases, several of those entities could have the same ID, let's say foo (a user foo , a car foo , and a blog post foo ). So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the sub key, e.g. with username: . So, in this example, the value of sub could have been: username:johndoe . The important thing to have in mind is that the sub key should have a unique identifier across the entire application, and it should be a string. Check it \u00b6 Run the server and go to the docs: http://127.0.0.1:8000/docs . You'll see the user interface like: Authorize the application the same way as before. Using the credentials: Username: johndoe Password: secret Check Notice that nowhere in the code is the plaintext password \" secret \", we only have the hashed version. Call the endpoint /users/me/ , you will get the response as: { \"username\" : \"johndoe\" , \"email\" : \"johndoe@example.com\" , \"full_name\" : \"John Doe\" , \"disabled\" : false } If you open the developer tools, you could see how the data sent and only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards: Note Notice the header Authorization , with a value that starts with Bearer . Advanced usage with scopes \u00b6 OAuth2 has the notion of \"scopes\". You can use them to add a specific set of permissions to a JWT token. Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions. You can learn how to use them and how they are integrated into FastAPI later in the Advanced User Guide . Recap \u00b6 With what you have seen up to now, you can set up a secure FastAPI application using standards like OAuth2 and JWT. In almost any framework handling the security becomes a rather complex subject quite quickly. Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath. FastAPI doesn't make any compromise with any database, data model or tool. It gives you all the flexibility to choose the ones that fit your project the best. And you can use directly many well maintained and widely used packages like passlib and pyjwt , because FastAPI doesn't require any complex mechanisms to integrate external packages. But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security. And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way. You can learn more in the Advanced User Guide about how to use OAuth2 \"scopes\", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.","title":"OAuth2 with Password (and hashing), Bearer with JWT tokens"},{"location":"tutorial/security/oauth2-jwt/#about-jwt","text":"JWT means \"JSON Web Tokens\". It's a standard to codify a JSON object in a long dense string without spaces. It looks like this: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c It is not encrypted, so, anyone could recover the information from the contents. But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it. That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know she/he is still signed into your system. And after a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match. If you want to play with JWT tokens and see how they work, check https://jwt.io .","title":"About JWT"},{"location":"tutorial/security/oauth2-jwt/#install-pyjwt","text":"We need to install PyJWT to generate and verify the JWT tokens in Python: pip install pyjwt","title":"Install PyJWT"},{"location":"tutorial/security/oauth2-jwt/#password-hashing","text":"\"Hashing\" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password.","title":"Password hashing"},{"location":"tutorial/security/oauth2-jwt/#why-use-password-hashing","text":"If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).","title":"Why use password hashing"},{"location":"tutorial/security/oauth2-jwt/#install-passlib","text":"PassLib is a great Python package to handle password hashes. It supports many secure hashing algorithms and utilities to work with them. The recommended algorithm is \"Bcrypt\". So, install PassLib with Bcrypt: pip install passlib [ bcrypt ] Tip With passlib , you could even configure it to be able to read passwords created by Django , a Flask security plug-in or many others. So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database. And your users would be able to login from your Django app or from your FastAPI app, at the same time.","title":"Install passlib"},{"location":"tutorial/security/oauth2-jwt/#hash-and-verify-the-passwords","text":"Import the tools we need from passlib . Create a PassLib \"context\". This is what will be used to hash and verify passwords. Tip The PassLib context also has functionality to use different hashing algorithms, including deprecate old ones only to allow verifying them, etc. For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt. And be compatible with all of them at the same time. Create a utility function to hash a password coming from the user. And another utility to verify if a received password matches the hash stored. And another one to authenticate and return a user. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }] Note If you check the new (fake) database fake_users_db , you will see how the hashed password looks like now: \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" .","title":"Hash and verify the passwords"},{"location":"tutorial/security/oauth2-jwt/#handle-jwt-tokens","text":"Import the modules installed. Create a random secret key that will be used to sign the JWT tokens. To generate a secure random secret key use the command: openssl rand -hex 32 And copy the output to the variable SECRET_KEY (don't use the one in the example). Create a variable ALGORITHM with the algorithm used to sign the JWT token and set it to \"HS256\" . Create a variable for the expiration of the token. Define a Pydantic Model that will be used in the token endpoint for the response. Create a utility function to generate a new access token. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }]","title":"Handle JWT tokens"},{"location":"tutorial/security/oauth2-jwt/#update-the-dependencies","text":"Update get_current_user to receive the same token as before, but this time, using JWT tokens. Decode the received token, verify it, and return the current user. If the token is invalid, return an HTTP error right away. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }]","title":"Update the dependencies"},{"location":"tutorial/security/oauth2-jwt/#update-the-token-path-operation","text":"Create a timedelta with the expiration time of the token. Create a real JWT access token and return it. from datetime import datetime , timedelta import jwt from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from jwt import PyJWTError from passlib.context import CryptContext from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\" , \"disabled\" : False , } } class Token ( BaseModel ): access_token : str token_type : str class TokenData ( BaseModel ): username : str = None class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) app = FastAPI () def verify_password ( plain_password , hashed_password ): return pwd_context . verify ( plain_password , hashed_password ) def get_password_hash ( password ): return pwd_context . hash ( password ) def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def authenticate_user ( fake_db , username : str , password : str ): user = get_user ( fake_db , username ) if not user : return False if not verify_password ( password , user . hashed_password ): return False return user def create_access_token ( * , data : dict , expires_delta : timedelta = None ): to_encode = data . copy () if expires_delta : expire = datetime . utcnow () + expires_delta else : expire = datetime . utcnow () + timedelta ( minutes = 15 ) to_encode . update ({ \"exp\" : expire }) encoded_jwt = jwt . encode ( to_encode , SECRET_KEY , algorithm = ALGORITHM ) return encoded_jwt async def get_current_user ( token : str = Depends ( oauth2_scheme )): credentials_exception = HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Could not validate credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) try : payload = jwt . decode ( token , SECRET_KEY , algorithms = [ ALGORITHM ]) username : str = payload . get ( \"sub\" ) if username is None : raise credentials_exception token_data = TokenData ( username = username ) except PyJWTError : raise credentials_exception user = get_user ( fake_users_db , username = token_data . username ) if user is None : raise credentials_exception return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" , response_model = Token ) async def login_for_access_token ( form_data : OAuth2PasswordRequestForm = Depends ()): user = authenticate_user ( fake_users_db , form_data . username , form_data . password ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : user . username }, expires_delta = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } @app . get ( \"/users/me/\" , response_model = User ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user @app . get ( \"/users/me/items/\" ) async def read_own_items ( current_user : User = Depends ( get_current_active_user )): return [{ \"item_id\" : \"Foo\" , \"owner\" : current_user . username }]","title":"Update the /token path operation"},{"location":"tutorial/security/oauth2-jwt/#technical-details-about-the-jwt-subject-sub","text":"The JWT specification says that there's a key sub , with the subject of the token. It's optional to use it, but that's where you would put the user's identification, so we are using it here. JWT might be used for other things apart from identifying a user and allowing him to perform operations directly on your API. For example, you could identify a \"car\" or a \"blog post\". Then you could add permissions about that entity, like \"drive\" (for the car) or \"edit\" (for the blog). And then, you could give that JWT token to a user (or bot), and he could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that. Using these ideas, JWT can be used for way more sophisticated scenarios. In those cases, several of those entities could have the same ID, let's say foo (a user foo , a car foo , and a blog post foo ). So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the sub key, e.g. with username: . So, in this example, the value of sub could have been: username:johndoe . The important thing to have in mind is that the sub key should have a unique identifier across the entire application, and it should be a string.","title":"Technical details about the JWT \"subject\" sub"},{"location":"tutorial/security/oauth2-jwt/#check-it","text":"Run the server and go to the docs: http://127.0.0.1:8000/docs . You'll see the user interface like: Authorize the application the same way as before. Using the credentials: Username: johndoe Password: secret Check Notice that nowhere in the code is the plaintext password \" secret \", we only have the hashed version. Call the endpoint /users/me/ , you will get the response as: { \"username\" : \"johndoe\" , \"email\" : \"johndoe@example.com\" , \"full_name\" : \"John Doe\" , \"disabled\" : false } If you open the developer tools, you could see how the data sent and only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards: Note Notice the header Authorization , with a value that starts with Bearer .","title":"Check it"},{"location":"tutorial/security/oauth2-jwt/#advanced-usage-with-scopes","text":"OAuth2 has the notion of \"scopes\". You can use them to add a specific set of permissions to a JWT token. Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions. You can learn how to use them and how they are integrated into FastAPI later in the Advanced User Guide .","title":"Advanced usage with scopes"},{"location":"tutorial/security/oauth2-jwt/#recap","text":"With what you have seen up to now, you can set up a secure FastAPI application using standards like OAuth2 and JWT. In almost any framework handling the security becomes a rather complex subject quite quickly. Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath. FastAPI doesn't make any compromise with any database, data model or tool. It gives you all the flexibility to choose the ones that fit your project the best. And you can use directly many well maintained and widely used packages like passlib and pyjwt , because FastAPI doesn't require any complex mechanisms to integrate external packages. But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security. And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way. You can learn more in the Advanced User Guide about how to use OAuth2 \"scopes\", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.","title":"Recap"},{"location":"tutorial/security/simple-oauth2/","text":"Now let's build from the previous chapter and add the missing parts to have a complete security flow. Get the username and password \u00b6 We are going to use FastAPI security utilities to get the username and password . OAuth2 specifies that when using the \"password flow\" (that we are using) the client/user must send a username and password fields as form data. And the spec says that the fields have to be named like that. So user-name or email wouldn't work. But don't worry, you can show it as you wish to your final users in the frontend. And your database models can use any other names you want. But for the login path operation , we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system). The spec also states that the username and password must be sent as form data (so, no JSON here). scope \u00b6 The spec also says that the client can send another form field \" scope \". The form field name is scope (in singular), but it is actually a long string with \"scopes\" separated by spaces. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings. Code to get the username and password \u00b6 Now let's use the utilities provided by FastAPI to handle this. OAuth2PasswordRequestForm \u00b6 First, import OAuth2PasswordRequestForm , and use it as a dependency with Depends for the path /token : from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user OAuth2PasswordRequestForm is a class dependency that declares a form body with: The username . The password . An optional scope field as a big string, composed of strings separated by spaces. An optional grant_type . Tip The OAuth2 spec actually requires a field grant_type with a fixed value of password , but OAuth2PasswordRequestForm doesn't enforce it. If you need to enforce it, use OAuth2PasswordRequestFormStrict instead of OAuth2PasswordRequestForm . An optional client_id (we don't need it for our example). An optional client_secret (we don't need it for our example). Info The OAuth2PasswordRequestForm is not a special class for FastAPI as is OAuth2PasswordBearer . OAuth2PasswordBearer makes FastAPI know that it is a security scheme. So it is added that way to OpenAPI. But OAuth2PasswordRequestForm is just a class dependency that you could have written yourself, or you could have declared Form parameters directly. But as it's a common use case, it is provided by FastAPI directly, just to make it easier. Use the form data \u00b6 Tip The instance of the dependency class OAuth2PasswordRequestForm won't have an attribute scope with the long string separated by spaces, instead, it will have a scopes attribute with the actual list of strings for each scope sent. We are not using scopes in this example, but the functionality is there if you need it. Now, get the user data from the (fake) database, using the username from the form field. If there is no such user, we return an error saying \"incorrect username or password\". For the error, we use the exception HTTPException : from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user Check the password \u00b6 At this point we have the user data from our database, but we haven't checked the password. Let's put that data in the Pydantic UserInDB model first. You should never save plaintext passwords, so, we'll use the (fake) password hashing system. If the passwords don't match, we return the same error. Password hashing \u00b6 \"Hashing\" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password. Why use password hashing \u00b6 If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous). from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user About **user_dict \u00b6 UserInDB(**user_dict) means: Pass the keys and values of the user_dict directly as key-value arguments, equivalent to: UserInDB ( username = user_dict [ \"username\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], disabled = user_dict [ \"disabled\" ], hashed_password = user_dict [ \"hashed_password\" ], ) Info For a more complete explanation of **user_dict check back in the documentation for Extra Models . Return the token \u00b6 The response of the token endpoint must be a JSON object. It should have a token_type . In our case, as we are using \"Bearer\" tokens, the token type should be \" bearer \". And it should have an access_token , with a string containing our access token. For this simple example, we are going to just be completely insecure and return the same username as the token. Tip In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens. But for now, let's focus on the specific details we need. from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user Tip By the spec, you should return a JSON with an access_token and a token_type , the same as in this example. This is something that you have to do yourself in your code, and make sure you use those JSON keys. It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications. For the rest, FastAPI handles it for you. Update the dependencies \u00b6 Now we are going to update our dependencies. We want to get the current_user only if this user is active. So, we create an additional dependency get_current_active_user that in turn uses get_current_user as a dependency. Both of these dependencies will just return an HTTP error if the user doesn't exists, or if is inactive. So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active: from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user Info The additional header WWW-Authenticate with value Bearer we are returning here is also part of the spec. Any HTTP (error) status code 401 \"UNAUTHORIZED\" is supposed to also return a WWW-Authenticate header. In the case of bearer tokens (our case), the value of that header should be Bearer . You can actually skip that extra header and it would still work. But it's provided here to be compliant with the specifications. Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future. That's the benefit of standards... See it in action \u00b6 Open the interactive docs: http://127.0.0.1:8000/docs . Authenticate \u00b6 Click the \"Authorize\" button. Use the credentials: User: johndoe Password: secret After authenticating in the system, you will see it like: Get your own user data \u00b6 Now use the operation GET with the path /users/me . You will get your user's data, like: { \"username\" : \"johndoe\" , \"email\" : \"johndoe@example.com\" , \"full_name\" : \"John Doe\" , \"disabled\" : false , \"hashed_password\" : \"fakehashedsecret\" } If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of: { \"detail\" : \"Not authenticated\" } Inactive user \u00b6 Now try with an inactive user, authenticate with: User: alice Password: secret2 And try to use the operation GET with the path /users/me . You will get an \"inactive user\" error, like: { \"detail\" : \"Inactive user\" } Recap \u00b6 You now have the tools to implement a complete security system based on username and password for your API. Using these tools, you can make the security system compatible with any database and with any user or data model. The only detail missing is that it is not actually \"secure\" yet. In the next chapter you'll see how to use a secure password hashing library and JWT tokens.","title":"Simple OAuth2 with Password and Bearer"},{"location":"tutorial/security/simple-oauth2/#get-the-username-and-password","text":"We are going to use FastAPI security utilities to get the username and password . OAuth2 specifies that when using the \"password flow\" (that we are using) the client/user must send a username and password fields as form data. And the spec says that the fields have to be named like that. So user-name or email wouldn't work. But don't worry, you can show it as you wish to your final users in the frontend. And your database models can use any other names you want. But for the login path operation , we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system). The spec also states that the username and password must be sent as form data (so, no JSON here).","title":"Get the username and password"},{"location":"tutorial/security/simple-oauth2/#scope","text":"The spec also says that the client can send another form field \" scope \". The form field name is scope (in singular), but it is actually a long string with \"scopes\" separated by spaces. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings.","title":"scope"},{"location":"tutorial/security/simple-oauth2/#code-to-get-the-username-and-password","text":"Now let's use the utilities provided by FastAPI to handle this.","title":"Code to get the username and password"},{"location":"tutorial/security/simple-oauth2/#oauth2passwordrequestform","text":"First, import OAuth2PasswordRequestForm , and use it as a dependency with Depends for the path /token : from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user OAuth2PasswordRequestForm is a class dependency that declares a form body with: The username . The password . An optional scope field as a big string, composed of strings separated by spaces. An optional grant_type . Tip The OAuth2 spec actually requires a field grant_type with a fixed value of password , but OAuth2PasswordRequestForm doesn't enforce it. If you need to enforce it, use OAuth2PasswordRequestFormStrict instead of OAuth2PasswordRequestForm . An optional client_id (we don't need it for our example). An optional client_secret (we don't need it for our example). Info The OAuth2PasswordRequestForm is not a special class for FastAPI as is OAuth2PasswordBearer . OAuth2PasswordBearer makes FastAPI know that it is a security scheme. So it is added that way to OpenAPI. But OAuth2PasswordRequestForm is just a class dependency that you could have written yourself, or you could have declared Form parameters directly. But as it's a common use case, it is provided by FastAPI directly, just to make it easier.","title":"OAuth2PasswordRequestForm"},{"location":"tutorial/security/simple-oauth2/#use-the-form-data","text":"Tip The instance of the dependency class OAuth2PasswordRequestForm won't have an attribute scope with the long string separated by spaces, instead, it will have a scopes attribute with the actual list of strings for each scope sent. We are not using scopes in this example, but the functionality is there if you need it. Now, get the user data from the (fake) database, using the username from the form field. If there is no such user, we return an error saying \"incorrect username or password\". For the error, we use the exception HTTPException : from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user","title":"Use the form data"},{"location":"tutorial/security/simple-oauth2/#check-the-password","text":"At this point we have the user data from our database, but we haven't checked the password. Let's put that data in the Pydantic UserInDB model first. You should never save plaintext passwords, so, we'll use the (fake) password hashing system. If the passwords don't match, we return the same error.","title":"Check the password"},{"location":"tutorial/security/simple-oauth2/#password-hashing","text":"\"Hashing\" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password.","title":"Password hashing"},{"location":"tutorial/security/simple-oauth2/#why-use-password-hashing","text":"If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous). from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user","title":"Why use password hashing"},{"location":"tutorial/security/simple-oauth2/#about-user_dict","text":"UserInDB(**user_dict) means: Pass the keys and values of the user_dict directly as key-value arguments, equivalent to: UserInDB ( username = user_dict [ \"username\" ], email = user_dict [ \"email\" ], full_name = user_dict [ \"full_name\" ], disabled = user_dict [ \"disabled\" ], hashed_password = user_dict [ \"hashed_password\" ], ) Info For a more complete explanation of **user_dict check back in the documentation for Extra Models .","title":"About **user_dict"},{"location":"tutorial/security/simple-oauth2/#return-the-token","text":"The response of the token endpoint must be a JSON object. It should have a token_type . In our case, as we are using \"Bearer\" tokens, the token type should be \" bearer \". And it should have an access_token , with a string containing our access token. For this simple example, we are going to just be completely insecure and return the same username as the token. Tip In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens. But for now, let's focus on the specific details we need. from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user Tip By the spec, you should return a JSON with an access_token and a token_type , the same as in this example. This is something that you have to do yourself in your code, and make sure you use those JSON keys. It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications. For the rest, FastAPI handles it for you.","title":"Return the token"},{"location":"tutorial/security/simple-oauth2/#update-the-dependencies","text":"Now we are going to update our dependencies. We want to get the current_user only if this user is active. So, we create an additional dependency get_current_active_user that in turn uses get_current_user as a dependency. Both of these dependencies will just return an HTTP error if the user doesn't exists, or if is inactive. So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active: from fastapi import Depends , FastAPI , HTTPException from fastapi.security import OAuth2PasswordBearer , OAuth2PasswordRequestForm from pydantic import BaseModel from starlette.status import HTTP_401_UNAUTHORIZED fake_users_db = { \"johndoe\" : { \"username\" : \"johndoe\" , \"full_name\" : \"John Doe\" , \"email\" : \"johndoe@example.com\" , \"hashed_password\" : \"fakehashedsecret\" , \"disabled\" : False , }, \"alice\" : { \"username\" : \"alice\" , \"full_name\" : \"Alice Wonderson\" , \"email\" : \"alice@example.com\" , \"hashed_password\" : \"fakehashedsecret2\" , \"disabled\" : True , }, } app = FastAPI () def fake_hash_password ( password : str ): return \"fakehashed\" + password oauth2_scheme = OAuth2PasswordBearer ( tokenUrl = \"/token\" ) class User ( BaseModel ): username : str email : str = None full_name : str = None disabled : bool = None class UserInDB ( User ): hashed_password : str def get_user ( db , username : str ): if username in db : user_dict = db [ username ] return UserInDB ( ** user_dict ) def fake_decode_token ( token ): # This doesn't provide any security at all # Check the next version user = get_user ( fake_users_db , token ) return user async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = fake_decode_token ( token ) if not user : raise HTTPException ( status_code = HTTP_401_UNAUTHORIZED , detail = \"Invalid authentication credentials\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) return user async def get_current_active_user ( current_user : User = Depends ( get_current_user )): if current_user . disabled : raise HTTPException ( status_code = 400 , detail = \"Inactive user\" ) return current_user @app . post ( \"/token\" ) async def login ( form_data : OAuth2PasswordRequestForm = Depends ()): user_dict = fake_users_db . get ( form_data . username ) if not user_dict : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) user = UserInDB ( ** user_dict ) hashed_password = fake_hash_password ( form_data . password ) if not hashed_password == user . hashed_password : raise HTTPException ( status_code = 400 , detail = \"Incorrect username or password\" ) return { \"access_token\" : user . username , \"token_type\" : \"bearer\" } @app . get ( \"/users/me\" ) async def read_users_me ( current_user : User = Depends ( get_current_active_user )): return current_user Info The additional header WWW-Authenticate with value Bearer we are returning here is also part of the spec. Any HTTP (error) status code 401 \"UNAUTHORIZED\" is supposed to also return a WWW-Authenticate header. In the case of bearer tokens (our case), the value of that header should be Bearer . You can actually skip that extra header and it would still work. But it's provided here to be compliant with the specifications. Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future. That's the benefit of standards...","title":"Update the dependencies"},{"location":"tutorial/security/simple-oauth2/#see-it-in-action","text":"Open the interactive docs: http://127.0.0.1:8000/docs .","title":"See it in action"},{"location":"tutorial/security/simple-oauth2/#authenticate","text":"Click the \"Authorize\" button. Use the credentials: User: johndoe Password: secret After authenticating in the system, you will see it like:","title":"Authenticate"},{"location":"tutorial/security/simple-oauth2/#get-your-own-user-data","text":"Now use the operation GET with the path /users/me . You will get your user's data, like: { \"username\" : \"johndoe\" , \"email\" : \"johndoe@example.com\" , \"full_name\" : \"John Doe\" , \"disabled\" : false , \"hashed_password\" : \"fakehashedsecret\" } If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of: { \"detail\" : \"Not authenticated\" }","title":"Get your own user data"},{"location":"tutorial/security/simple-oauth2/#inactive-user","text":"Now try with an inactive user, authenticate with: User: alice Password: secret2 And try to use the operation GET with the path /users/me . You will get an \"inactive user\" error, like: { \"detail\" : \"Inactive user\" }","title":"Inactive user"},{"location":"tutorial/security/simple-oauth2/#recap","text":"You now have the tools to implement a complete security system based on username and password for your API. Using these tools, you can make the security system compatible with any database and with any user or data model. The only detail missing is that it is not actually \"secure\" yet. In the next chapter you'll see how to use a secure password hashing library and JWT tokens.","title":"Recap"}]}